<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILNumerics</name>
    </assembly>
    <members>
        <member name="M:ILNumerics.Algorithms.Graphic.Triangularize(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Increase the number of triangles by doubling existing triangles
            </summary>
            <param name="vertices">Vertices</param>
            <param name="triangles">Triangle index definitions</param>
            <param name="iterations">Number of iterations, each iteration will make 4 triangles out of each triangle</param>
            <param name="outVertices">[Output] Vertices.</param>
            <param name="outTriangles">[Output] Triangles</param>
            <remarks><para>Incoming triangles are expected not to be degenerated. This means:
            Every edge is used only twice at most. No triangle shares more than 2
            corners with some other triangle. </para>
            	<para>None of the incoming arrays will get altered</para></remarks>
        </member>
        <member name="T:ILNumerics.ILMath">
            <summary>
            Main math class, exposes all static math functions. Users should write algorithms in a class derived from <c>ILMath</c>. 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.em(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILMath.EMInitializationMethod,ILNumerics.ILInArray{System.Double},System.Int32,System.Double)">
            <summary>
            Expectation maximization algorithm
            </summary>
            <param name="Samples">Input data, data points in columns</param>
            <param name="k">Number of clusters</param>
            <param name="method">[Optional] Method used for initializing the cluster centers, default: kmeans_random</param>
            <param name="UserCenters">[Optional] For method 'user': initial cluster centers, size samples.D[0] x k, for other methods ignored</param>
            <param name="maxiterexit">[Optional] Break after that number of iterations, if no convergence was reached</param>
            <param name="Sigma">[Output] Covariance estimation for all clusters, size d x d x k, d = samples.D[0]</param>
            <param name="centerconverg_exit">[Optional] Exit iteration if norm(L) falls below that value, default: 0.001</param>
            <returns>Estimated centers for all clusters, size samples.D[0] x k</returns>
            <remarks><para>The EM algorithm expects the data samples to be drawn from <paramref name="k"/> multivariate normal distributions. 
            It estimates the parameters 'center' and 'sigma (covariance)' of every distribution. Therefore, the position and 'shape' 
            of each distribution is calculated in such a way, that the likelyhood of generating the given sample points is maximized.</para>
            <para>The parameter k must be determined by the user. This reflects the a priori knowledge of the number of distributions 
            or clusters in the data.</para>
            <para>The algorithm exits, if one of the exit criteria is reached: 
            <list type="bullet"><item>norm(L) &lt; 'centerconverg_exit' - where L is the difference between 
            the centers from the last step and the centers just computed in the current step</item>
            <item>the number of iteration steps exceeds the limit of 'maxiterexit' iterations.</item></list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.em(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Single},ILNumerics.ILMath.EMInitializationMethod,ILNumerics.ILInArray{System.Single},System.Int32,System.Double)">
            <summary>
            Expectation maximization algorithm
            </summary>
            <param name="Samples">Input data, data points in columns</param>
            <param name="k">Number of clusters</param>
            <param name="method">[Optional] Method used for initializing the cluster centers, default: kmeans_random</param>
            <param name="UserCenters">[Optional] For method 'user': initial cluster centers, size samples.D[0] x k, for other methods ignored</param>
            <param name="maxiterexit">[Optional] Break after that number of iterations, if no convergence was reached</param>
            <param name="Sigma">[Output] Covariance estimation for all clusters, size d x d x k, d = samples.D[0]</param>
            <param name="centerconverg_exit">[Optional] Exit iteration if norm(L) falls below that value, default: 0.001</param>
            <returns>Estimated centers for all clusters, size samples.D[0] x k</returns>
            <remarks><para>The EM algorithm expects the data samples to be drawn from <paramref name="k"/> multivariate normal distributions. 
            It estimates the parameters 'center' and 'sigma (covariance)' of every distribution. Therefore, the position and 'shape' 
            of each distribution is calculated in such a way, that the likelyhood of generating the given sample points is maximized.</para>
            <para>The parameter k must be determined by the user. This reflects the a priori knowledge of the number of distributions 
            or clusters in the data.</para>
            <para>The algorithm exits, if one of the exit criteria is reached: 
            <list type="bullet"><item>norm(L) &lt; 'centerconverg_exit' - where L is the difference between 
            the centers from the last step and the centers just computed in the current step</item>
            <item>the number of iteration steps exceeds the limit of 'maxiterexit' iterations.</item></list></para>
            </remarks>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILMath.knn(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILMath.DistanceMetrics,System.Double,System.Boolean)" ignoriert -->
        <member name="M:ILNumerics.ILMath.testStable(ILNumerics.ILInArray{System.Double})">
            <summary>
            Test for numerical instability, expects positive data only!
            </summary>
            <param name="samples_normalized">Input data</param>
            <returns>true: no instability detected, false, possible instablility</returns>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILMath.knn(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILMath.DistanceMetrics,System.Double,System.Boolean)" ignoriert -->
        <member name="M:ILNumerics.ILMath.testStable(ILNumerics.ILInArray{System.Single})">
            <summary>
            Test for numerical instability, expects positive data only!
            </summary>
            <param name="samples_normalized">Input data</param>
            <returns>true: no instability detected, false, possible instablility</returns>
        </member>
        <member name="M:ILNumerics.ILMath.krr(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Calculate the kernel ridge regression (KRR) of X to Y
            </summary>
            <param name="X">Input data X, observations in columns</param>
            <param name="Y">Input data Y (regression target)</param>
            <returns>Kernel ridge regression model with linear kernel and no regularization</returns>
        </member>
        <member name="M:ILNumerics.ILMath.krr(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILMath.KRRTypes,ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Calculate the kernel ridge regression (KRR) of X to Y
            </summary>
            <param name="X">Input data X, observations in columns</param>
            <param name="Y">Input data Y (regression target)</param>
            <param name="kernel">Kernel type to use</param>
            <param name="Kernelparam">Kernel parameters, scalar constant, if invalid: defaults to 1</param>
            <param name="Regularization">Regularization constant (set to -1 to have no regularization)</param>
            <returns>The kernel ridge regression model</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ridge_regression(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Ordinary least squares regression/ ridge regression
            </summary>
            <param name="X">Data matrix, data points in columns</param>
            <param name="Y">Training targets (or 'labels') corresponding to <paramref name="X"/></param>
            <param name="Degree">Highest degree of polynomials for the design matrix</param> 
            <param name="Regularization">Regularization constant (usually some "small" summand for stabilizing the matrix inversion).</param>
            <returns>Train result used for applying the model to new data.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.pca(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Principal Component Analysis (PCA)
            </summary>
            <param name="A">Data matrix, size (m,n); each of n observations is expected in a column of m variables</param>
            <param name="outWeights">[Output] Weights for scaling the components according to the original data</param>
            <param name="outCenter">[Output] Vector pointing to the center of the input data A</param>
            <param name="outScores">[Output] Scaling factors for the component to recreate original data</param>
            <returns>PCA components; weights, center and scores are returned at optional output parameters</returns>
            <remarks>Principal Component Analysis (PCA) is commonly used as method for dimension reduction. It computes 
            a number of 'principal components' which span a space of orthogonal directions. The nice property is, these 
            directions are choosen such, as to maximize the variance of original data, once they are projected onto them. 
            We can simply pick only a subset of components, having associated a high variance and leave out other components, which do
            not contribute much to the distribution of the original data. The resulting subspace is constructed of fewer
            dimensions as the original space - with a smaller reconstrution error. Therefore, PCA is commonly used 
            for visualizing higher dimensional data in only two or three dimensional plots. It helps analyzing datasets which 
            otherwise could only be visualized by picking individual dimensions. By help of PCA, 'interesting' directions 
            in the data are identified.
            <para>Any output parameter are optional and may be ommited ore provided as null parameter: 
            <list type="bullet">
            <item><b>components</b> (return value) prinicipal components. Matrix of size m x m, m components are provided in columns. The first 
            component marks the direction in the data A, which corresponds to the largest variance (i.e. by projecting the data onto 
            that direction, the largest variance would be created). Adjacent components are all orthogonal to each other. 
            The components are ordered in columns of decreasing variance.</item>
            <item><b>weights</b> vectors. While the components returned are normalized to length 1, the 'weights' vector 
            contains the factors needed, to scale the components in order to reflect the real spacial distances in the 
            original data.</item>
            <item><b>center</b> of the original data. The vector points to the weight middle of A.</item>
            <item><b>scores</b> is a matrix of size m by n. For each datapoint given in A, it contains factors for each component 
            needed to reproduce the original data point in terms of the components.</item>
            </list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pca(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Principal Component Analysis (PCA)
            </summary>
            <param name="A">Data matrix, size (m,n); each of n observations is expected in a column of m variables</param>
            <param name="outWeights">[Output] Weights for scaling the components according to the original data</param>
            <param name="outCenter">[Output] Vector pointing to the center of the input data A</param>
            <param name="outScores">[Output] Scaling factors for the component to recreate original data</param>
            <returns>PCA components; weights, center and scores are returned at optional output parameters</returns>
            <remarks>Principal Component Analysis (PCA) is commonly used as method for dimension reduction. It computes 
            a number of 'principal components' which span a space of orthogonal directions. The nice property is, these 
            directions are choosen such, as to maximize the variance of original data, once they are projected onto them. 
            We can simply pick only a subset of components, having associated a high variance and leave out other components, which do
            not contribute much to the distribution of the original data. The resulting subspace is constructed of fewer
            dimensions as the original space - with a smaller reconstrution error. Therefore, PCA is commonly used 
            for visualizing higher dimensional data in only two or three dimensional plots. It helps analyzing datasets which 
            otherwise could only be visualized by picking individual dimensions. By help of PCA, 'interesting' directions 
            in the data are identified.
            <para>Any output parameter are optional and may be ommited ore provided as null parameter: 
            <list type="bullet">
            <item><b>components</b> (return value) prinicipal components. Matrix of size m x m, m components ar provided in columns. The first 
            component marks the direction in the data A, which corresponds to the largest variance (i.e. by projecting the data onto 
            that direction, the largest variance would be created). Adjacent components are all orthogonal to each other. 
            The components are ordered in columns of decreasing variance.</item>
            <item><b>weights</b> vectors. While the components returned are normalized to length 1, the 'weights' vector 
            contains the factors needed, to scale the components in order to reflect the real spacial distances in the 
            original data.</item>
            <item><b>center</b> of the original data. The vector points to the weight middle of A.</item>
            <item><b>scores</b> is a matrix of size m by n. For each datapoint given in A, it contains factors for each component 
            needed to reproduce the original data point in terms of the components.</item>
            </list></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.kMeansClust(ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,System.Int32,System.Boolean,ILNumerics.ILOutArray{System.Double})">
            <summary>
            K-Means clustering: find clusters in data matrix X
            </summary>
            <param name="X">Data matrix, data points are given as columns</param>
            <param name="k">Initial number of clusters expected</param>
            <param name="centerInitRandom">[Optional] false: pick the first k data points as initial centers, true: pick random datapoints (default)</param>
            <param name="maxIterations">[Optional] Maximum number of iterations, the computation will exit after that many iterations, default: 10.000</param>
            <param name="outCenters">[Input/Output/Optional] If not null on entry, outCenters will contain the centers of the clusters found, default: null</param>
            <returns>Vector of length n with with indices of the clustersm which were assigned to each datapoint</returns>
            <remarks><para>If <paramref name="outCenters"/> is given not null on input, the algorithm returns the computed centers in that parameter. A 
            matrix may be given on input, in order to give a hint of the initial center positions. This may help to find correct cluster centers - even if 
            the initial hint is not exact. In order to do so, the matrix given must be of the correct size (X.D[0] by k) and <paramref name="centerInitRandom"/>
            must be set to <c>false</c>.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.kMeansClust(ILNumerics.ILInArray{System.Single},ILNumerics.ILBaseArray,System.Int32,System.Boolean,ILNumerics.ILOutArray{System.Single})">
            <summary>
            K-Means clustering: find clusters in data matrix X
            </summary>
            <param name="X">Data matrix, data points are given as columns</param>
            <param name="k">Initial number of clusters expected</param>
            <param name="centerInitRandom">[Optional] false: pick the first k data points as initial centers, true: pick random datapoints (default)</param>
            <param name="maxIterations">[Optional] Maximum number of iterations, the computation will exit after that many iterations, default: 10.000</param>
            <param name="outCenters">[Input/Output/Optional] If not null on entry, outCenters will contain the centers of the clusters found, default: null</param>
            <returns>Vector of length n with with indices of the clustersm which were assigned to each datapoint</returns>
            <remarks><para>If <paramref name="outCenters"/> is given not null on input, the algorithm returns the computed centers in that parameter. A 
            matrix may be given on input, in order to give a hint of the initial center positions. This may help to find correct cluster centers - even if 
            the initial hint is not exact. In order to do so, the matrix given must be of the correct size (X.D[0] by k) and <paramref name="centerInitRandom"/>
            must be set to <c>false</c>.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Byte})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input Array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the Input Array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Double})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Single})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">Input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Magnitude of array elements</summary>
            <param name="A">Input array</param>
            <returns>Magnitude of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int64})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.abs(ILNumerics.ILInArray{System.Int32})">
            <summary>Absolute values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Absolute values of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Double})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acosc(ILNumerics.ILInArray{System.Single})">
            <summary>Arccosine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arccosine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Single})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.acos(ILNumerics.ILInArray{System.Double})">
            <summary>Arccosine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arccosine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.add(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Add arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise sum of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Determine, if all elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having specified or first non-singleton dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Double})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int64})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Int32})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Byte})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{System.Single})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.allall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Determine if array has nonzero elements in all dimensions</summary>
            <param name="A">Input Array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            all elements are found to be non-zero, false otherwise.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned. </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.and(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'and' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'and' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Determine, if any elements are nonzero</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having the specified or first non-singleton dimension reduced to 1, if any elements along that dimension are non-zero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.anyall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if array has any nonzero elements
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar logical array</returns>
            <remarks><para>The function evaluates all elements of A in all dimensions. It returnes 'true' (1) if
            <b>any</b> elements are found to be non-zero, false, if all elements are zero.</para>
            <para>If A is empty, a scalar logical 'false' (0) is returned.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.all(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Double,System.Double,System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Single,System.Single,System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.fcomplex,ILNumerics.fcomplex,ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{ILNumerics.complex,ILNumerics.complex,ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int64,System.Int64,System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Int32,System.Int32,System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.apply(System.Func{System.Byte,System.Byte,System.Byte},ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Apply an arbitrary function to two arrays</summary>
            <param name="func">A function c = f(a,b), which will be applied to elements in A and B</param>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>The combination of A and B. The result and size depends on the inputs:<list type="table">
            <item>
                <term>size(A) == size(B)</term>
                <description>Same size as A/B, elementwise combination of A and B.</description>
            </item>
            <item>
                <term>isscalar(A) || isscalar(B)</term>
                <description>Same size as A or B, whichever is not a scalar, the scalar value being applied to each element 
                (i.e. if the non-scalar input is empty, the result is empty).</description>
            </item>
            <item>
                <term>All other cases</term>
                <description>If A or B is a colum vector and the other parameter is an array with a matching column length, the vector is used to operate on all columns of the array. 
            Similarly, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length.</description>
            </item>
            </list></returns>
            <remarks><para>The <c>apply</c> function is also implemented for input if e.g. sizes (mxn) and (mx1). 
            In this case the vector argument will be combined to each column, resulting in an (mxn) array. 
            This feature is, however, officiallny not supported.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0,ILNumerics.ILSize)">
            <summary>
            Create new array, fill elements with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements</param>
            <param name="size">Size of new array</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0,System.Int32[])">
            <summary>
            Create new array, fill element with constant value
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="value">Constant value for all elements</param>
            <param name="size">Size of new array</param>
            <returns>New array according to size with all elements set to 'value'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[],System.Int32[])">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">System.Array of predefined elements</param>
            <param name="size">Size of every dimension for the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The System.Array given as <paramref name="elements"/>is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[],ILNumerics.ILSize)">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">System.Array of predefined elements</param>
            <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The System.Array given as <paramref name="elements"/>is taken 
            as storage for the new array without copy. Make sure not to reference that 
            System.Array directly afterwards.</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool. 
            </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(ILNumerics.ILSize,``0[])">
            <summary>
            Create array, given elements and size
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Variable argument list with elements</param>
            <param name="size">Size of the new array, must correspond to the number of elements in <paramref name="elements"/>.</param>
            <returns>Newly created array</returns>
            <remarks><para>The elements given as <paramref name="elements"/> are used 
            for the new array without copy. For <typeparamref name="T"/> being a reference type, make sure not to reference any  
            elements directly afterwards.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.array``1(``0[])">
            <summary>
            Create column vector from given elements 
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">List of elements</param>
            <returns>Newly created vector with elements given</returns>
            <remarks><para>If an System.Array was given as params argument, the array is directly taken 
            as storage for the new array without copy. Make sure not to reference the 
            System.Array directly afterwards!</para>
            <para>In order to prevent for memory leaks on long runnning algorithms, <c>System.Array</c>s should 
            not get created via the 'new' keyword - but fetched from the ILMemoryPool.</para>
            <para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>.
            This switch defaults to <c>false</c> which will cause the creation of a column vector. </para></remarks>
            <see cref="M:ILNumerics.ILMath.row``1(``0[])"/>
            <see cref="M:ILNumerics.ILMath.column``1(``0[])"/>
        </member>
        <member name="M:ILNumerics.ILMath.row``1(``0[])">
            <summary>
            Create row vector
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the row vector</param>
            <returns>New row vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.column``1(``0[])">
            <summary>
            Create column vector
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="elements">Elements of the column vector</param>
            <returns>New column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Single})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asinc(ILNumerics.ILInArray{System.Double})">
            <summary>Arcsine of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arcsine values of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Single})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.asin(ILNumerics.ILInArray{System.Double})">
            <summary>Arcsine of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Arcsine of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Single})">
            <summary>Arctangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan(ILNumerics.ILInArray{System.Double})">
            <summary>Arctangent of array elements </summary>
            <param name="A">Input array</param>
            <returns>Arctangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Arcus tangens of elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise arcus tangens of both inputs</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.atan2(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Arcus tangens of elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise arcus tangens of both inputs</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            </summary>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates (height)</param>
            <param name="outRadius">[Output] Radius if not null on entry</param>
            <param name="outZ">[Output] Z if not null on entry</param>
            <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
            <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cart2pol(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Transform scalar coordinates into polar (cylindrical) coordinates
            </summary>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates (height)</param>
            <param name="outRadius">[Output] Radius if not null on entry</param>
            <param name="outZ">[Output] Z if not null on entry</param>
            <returns>Angles; radius and Z are returned as output parameters, if on entry not null</returns>
            <remarks>Theta, radius and Z must be the same size or either one may be scalar. 
            Polar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create complex array from real and imaginary parts 
            </summary>
            <param name="real">Array with real part elements</param>
            <param name="imag">Array with imaginary part elements</param>
            <returns>Complex array constructed out of real and imaginary parts</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ccomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create complex array from real and imaginary parts
            </summary>
            <param name="real">Array with real part elements</param>
            <param name="imag">Array with imaginary part elements</param>
            <returns>Complex array constructed out of real and imaginary parts</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arguments is not the same.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ceil(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards positive infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded up to next integer value</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])">
            <summary>
            Create a cell row vector from given arrays 
            </summary>
            <param name="arrays">Arrays to be copied inside the cell</param>
            <returns>Cell vector</returns>
            <remarks><para>The new cell will be created as vector, having the array 'values' given as parameter as cell elements. Those elements will 
            be protected by changes from outside the cell.</para>
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <example>
            <para>A common use of the <c>cell</c> function is the concatenation of arrays and constants for subarray definitions, as shown in the following example:</para>
            <code>
            ILArray&lt;double&gt; A = counter(4,3,2); 
            A
            //&lt;Double&gt; [4,3]
            // 1          5          9 
            // 2          6         10 
            // 3          7         11 
            // 4          8         12 
            
            // extract 1st, 2nd and last row:
            ILArray&lt;double&gt; B = A[cell(0,1,end),full]; 
            B
            //&lt;Double&gt; [3,3]
            // 1          5          9 
            // 2          6         10 
            // 4          8         12 
            </code>
            <para>Here, <c>cell</c> is used to concatenate individual indices determining the rows to select for the subarray. Using a cell here is convenient, because arbitrary types 
            can be stored in cells - integer, floating point types or special placeholders, like expressions (<see cref="P:ILNumerics.ILMath.end"/> and <see cref="P:ILNumerics.ILMath.full"/>).</para>
            </example>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILSize,ILNumerics.ILBaseArray[])">
            <summary>
            Create cell, initialize with arrays and size
            </summary>
            <param name="size">Size of the new cell</param>
            <param name="arrays">List of arrays for the cell elements, column major order</param>
            <returns>Cell of specified size, initialized with arrays</returns>
            <remarks>If number of arrays given is smaller than the number of elements given by <paramref name="size"/>, trailing 
            elements in the cell returned will be set to null.
            <para>The <see cref="M:ILNumerics_ILMath_size(params int[])"/> function is convenient for the specification of size descriptors.</para>
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <example>
            <code>
            ILArray&lt;double> A = rand(10,20,30); 
            ILCell C = cell(size(3,2),A, A+1, zeros(2,3)); 
            C
            //Cell [3,2]
            // &lt;Double> [10,20,30]          &lt;String>        4th element  
            // &lt;Double> [10,20,30]                                 (null)
            // &lt;Double> [2,3]                                      (null)
            </code>
            </example>
        </member>
        <member name="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[],System.Int32[])">
            <summary>
            Create cell, initialize with arrays and size
            </summary>
            <param name="arrays">Predefined array with arrays, directly be used as new cell element storage</param>
            <param name="size">Size of newly created cell</param>
            <returns>Cell with size of <paramref name="size"/> and elements from <paramref name="arrays"/></returns>
            <remarks>The array given in <paramref name="arrays"/> is directly be used for the newly created cell. Make sure, not 
            to reference the system array afterwards. However, arrays  referenced from within the parameter <paramref name="arrays"/> 
            are stored as clone into the new cell. Therefore, those arrays are properly protected from changes by altering any array outside the cell.
            <para>Visit the <a href="http://ilnumerics.net/$Cells.html" target="ILMain">online documentation</a> for cell.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.cell(ILNumerics.ILBaseArray[])"/>
        </member>
        <member name="M:ILNumerics.ILMath.check``1(ILNumerics.ILInArray{``0},System.Func{ILNumerics.ILInArray{``0},ILNumerics.ILRetArray{``0}},System.Boolean,System.String,ILNumerics.ILInArray{``0})">
            <summary>
            Check if A is a valid parameter
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[optional] Exception message</param>
            <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception. If <paramref name="Default"/> was defined, this parameter is ignored.</param>
            <param name="Default">[optional] If <paramref name="A"/> is null on input, this value is returned. If no default is given (i.e: null), <paramref name="allowNullInput"/> is evaluated.</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInLogical,System.Func{ILNumerics.ILInLogical,ILNumerics.ILRetLogical},System.Boolean,System.String)">
            <summary>
            Check if A is a valid parameter
            </summary>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[optional] Exception message</param>
            <param name="evaluation">[optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[optional] Only if A is null -&gt; for true: returns null, false: throws exception</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.check(ILNumerics.ILInCell,System.Func{ILNumerics.ILInCell,ILNumerics.ILRetCell},System.Boolean,System.String)">
            <summary>
            Check if A is a valid parameter
            </summary>
            <param name="A">Input parameter</param>
            <param name="ErrorMessage">[Optional] Exception message</param>
            <param name="evaluation">[Optional] Evaluation function, checks input parameter and transforms it into result, gets only called for A other than null</param>
            <param name="allowNullInput">[Optional] Only if A is null -&gt; true: returns null, false: throws exception</param>
            <returns>Result of evaluation(A) or A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null on entry and <paramref name="allowNullInput"/> is false</exception>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.chol(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
            <summary>Cholesky factorization</summary>
            <param name="A">Input array A. A must be a symmetric/hermitian matrix. 
            Therefore the upper triangular part of A must be the transpose (complex conjugate for complex input) of the lower triangular part. No check 
            is made for that! <br/> 
            The elements of A will not be altered.</param>
            <param name="throwException">Throw an ILArgumentException if A 
            is found not to be positive definite.</param>
            <returns>Cholesky factorization</returns>
            <remarks><para>If <paramref name="throwException"/> is true and 
            A is found not to be positive definite, an ILArgumentException 
            will be thrown and the operation will be canceled.</para>
            <para>If <paramref name="throwException"/> is false, check the
            return value's dimension to determine the success of the 
            operation (unless you are sure, A was positive definite). 
            If A was found not to be positive definite the matrix returned 
            will be of dimension [k x k] and the result of the cholesky 
            factorization of A[0:k-1;0:k-1]. Here k is the first leading 
            minor of A at which A was found to be not positive definite.</para>
            The factorization is carried out by use of the LAPACK functions 
            DPOTRF, ZPOTRF, SPOTRF or CPOTRF respectively. </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Double})">
            <summary>
            Complex conjugate of A
            </summary>
            <param name="A">Input array</param>
            <returns>The array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{System.Single})">
            <summary>
            Complex conjugate of A
            </summary>
            <param name="A">Input array</param>
            <returns>The array itself</returns>
            <remarks>This overload is provided for convenience only. It eases the implementation of complex functions, where complex conjugate transposes are needed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">Input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.conj(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Complex conjugate of array A</summary>
            <param name="A">Input array</param>
            <returns>Complex conjugate of array A</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.convert``2(ILNumerics.ILInArray{``0})">
            <summary>
            Convert a numeric array to another numeric type
            </summary>
            <param name="X">Input array</param>
            <typeparam name="inT">Type of array to convert</typeparam>
            <typeparam name="outT">Type of array to return</typeparam>
            <returns>Converted array</returns>
            <remarks> The newly created array will be converted to the required type. 
            <para>The array returned will always use new memory! Even if the type requested 
            matches the incoming type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to double array
            </summary>
            <param name="X">Input array</param>
            <returns>double array</returns>
            <remarks><para>The function converts elements of X to double using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to float array
            </summary>
            <param name="X">Input array</param>
            <returns>float array</returns>
            <remarks><para>The new array converts elements of X to float using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to complex array
            </summary>
            <param name="X">Input array </param>
            <returns>complex array</returns>
            <remarks><para>Real input arrays will be converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to complex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to fcomplex array
            </summary>
            <param name="X">Input array </param>
            <returns>fcomplex array</returns>
            <remarks>
            <para>Real input arrays are converted to the real part of the complex array returned.</para>
            <para>The function converts elements of X to fcomplex using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to byte array
            </summary>
            <param name="X">Input array </param>
            <returns>byte array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. 
            The new array uses new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tological(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to logical array
            </summary>
            <param name="X">Input array </param>
            <returns>Logical array</returns>
            <remarks><para>The function converts elements of X to byte using standard explicit system conversions. Non-zero
            elements are converted to true, zero-elements are converted to false. 
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to Int32 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int32 array</returns>
            <remarks><para>The function converts elements of X to Int32 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert numeric array to Int64 array
            </summary>
            <param name="X">Input array </param>
            <returns>Int64 array</returns>
            <remarks><para>The function converts elements of X to Int64 using standard explicit system conversions.  
            The new array will always use new memory, even if the incoming type is the same as the output type.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.todouble(ILNumerics.ILBaseArray)">
            <summary>
            convert arbitrary numeric array to double array
            </summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>double array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.toint64(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to Int64 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Int64 array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.toint32(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to Int32 array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>Int32 array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tobyte(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to byte array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>byte array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tofcomplex(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to fcomplex array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>fcomplex array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tocomplex(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to complex array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>complex array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tosingle(ILNumerics.ILBaseArray)">
            <summary>convert arbitrary numeric array to float array</summary>
            <param name="X">numeric array, one of supported numeric type</param>
            <returns>float array</returns>
            <remarks>This function enables to convert arbitrary numeric (dense) arrays to a known output array type 
            - without knowing the concrete numeric type of the source. Supported element types include: double, 
            float, complex, fcomplex, byte, logical, Int32, Int64.
            <para>This function will always create new memory for the new array, even if both 
            arrays have the same element type.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if elements of X are 
            not of any supported numeric type</exception>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Single})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cos(ILNumerics.ILInArray{System.Double})">
            <summary>Cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic cosine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cosh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic cosine of array elements </summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic cosine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 to dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Int32[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <param name="start">Starting number</param>
            <param name="inc">Incrementing step</param>
            <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(System.Double,System.Double,ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <param name="start">Starting number</param>
            <param name="inc">Incrementing step</param>
            <returns>Double array with elements counting from start to start + (dimensions.NumberOfElements * inc)</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter(ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with elements counting from 1, double precision
            </summary>
            <param name="dimensions">Variable number of numeric scalar arrays with dimension specification</param>
            <returns>Double array with elements counting from 1 ... dimensions.NumberOfElements</returns>
            <remarks>This function may be used for the convenient creation of arrays for testing purposes.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray[])">
            <summary>
            Create n-dimensional array with counting elements 
            </summary>
            <param name="start">Initial value</param>
            <param name="increment">Increment for each element</param>
            <param name="dimensions">Variable number of numeric, scalar arrays with dimension specification</param>
            <returns>Array with elements counting from <paramref name="start"/> along the first dimension with steps of <paramref name="increment"/>.</returns>
            <remarks>
            <example><code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]> 
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.counter``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILSize)">
            <summary>
            Create n-dimensional array with counting elements 
            </summary>
            <param name="start">Initial value</param>
            <param name="increment">Increment for each element</param>
            <param name="dimensions">Variable int array with dimension specification</param>
            <returns>Array with elements counting from <paramref name="start"/> to dimensions.NumberOfElements - <paramref name="start"/>.</returns>
            <remarks>
            <example><code>
            // This will create elements counting from 1...24: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(4,3,2); 
            // This will create elements counting from 1...48 with intervals of 2.0: 
            <![CDATA[ILArray<double>]]> A = ILMath.counter(1.0,2.0,4,3,2); 
            // This will create an array with all elements having contant value of -4f:
            // (note: start, increment and dimension specifier do not need to be of the same type)
            <![CDATA[ILArray<float> A = ILMath.counter<float>(4.0,0,4,3,2);]]> 
            </code></example>  </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cov(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>
            Covariance matrix of A
            </summary>
            <param name="A">Input vector or data matrix, samples in columns, variables in rows</param>
            <param name="unbiased">[Optional] If true, calculate the best unbiased variance estimate if the observations are from a normal distribution. This normalizes by n-1 if n>1 (n = number of samples). If n == 1 normalization is always 1. If false always normalize by n.</param>
            <returns>Variance of vector A/Covariance matrix of A</returns>
            <remarks><para>If A is a vector <c>cov(A)</c> returns the variance of A</para>
            <para>If A is a m x n matrix, where each of the n columns is an m-dimensional observation, <c>cov(A)</c> is the n x n covariance matrix.</para>
            <para>The mean is removed from each column before calculating the result.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.cov(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>
            Covariance matrix of A
            </summary>
            <param name="A">Input vector or data matrix, samples in columns, variables in rows</param>
            <param name="unbiased">[Optional] If true, calculate the best unbiased variance estimate if the observations are from a normal distribution. This normalizes by n-1 if n>1 (n = number of samples). If n == 1 normalization is always 1. If false always normalize by n.</param>
            <returns>Variance of vector A/Covariance matrix of A</returns>
            <remarks><para>If A is a vector <c>cov(A)</c> returns the variance of A</para>
            <para>If A is a m x n matrix, where each of the n columns is an m-dimensional observation, <c>cov(A)</c> is the n x n covariance matrix.</para>
            <para>The mean is removed from each column before calculating the result.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Double})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{System.Single})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.fcomplex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.det(ILNumerics.ILInArray{ILNumerics.complex})">
             <summary>
             Determinant of square matrix
             </summary>
             <param name="A">Input matrix (square)</param>
             <returns>Determinant of A</returns>
             <remarks><para>The determinant is computed by decomposing A into upper and lower triangular part (using the LAPACK function ?getrf).<br/>
             Due to the properties of determinants, det(a) is the same as det(L) * det(U),where det(L) can easily be extracted from the permutation indices returned from LU decomposition. det(U) - with U being an upper triangular matrix - equals the product of the diagonal elements.</para>
             <para>For scalar A, a plain copy of A is returned.</para></remarks>
             <example>Creating a nonsingular 4x4 (double) matrix and it's determinant
             <code>ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,4,4);
            A[1] = 0.0;  // make A nonsingular
            A[14] = 0.0; //(same as: A[2,3] = 0.0;) 
             // A is now:
             //&lt;Double&gt; [4,4]
             //(:,:) 1e+001 * 
             // 0,10000   0,50000   0,90000   1,30000 
             // 0,00000   0,60000   1,00000   1,40000 
             // 0,30000   0,70000   1,10000   0,00000 
             // 0,40000   0,80000   1,20000   1,60000 
             
            ILMath.det(A) gives:
             //&lt;Double&gt; -360
            </code></example>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is empty or not a square matrix</exception>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on X a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diag``1(ILNumerics.ILInArray{``0},System.Int32)">
            <summary>
            Diagonal matrix or diagonal of matrix
            </summary>
            <param name="X">Input matrix or vector. If X is matrix, diag(X) returns the 
            elements on the diagPosition's diagonal as column vector. If X is vector, a square matrix of size 
            [length(X) + abs(diagPosition), length(X) + abs(diagPosition)] will be created, having 
            the elements of X on the diagPosition's diagonal.</param>
            <param name="diagPosition">[Optional] Index of diagonal to extract/create. Here 0 means the 
            main diagonal, diagPosition > 0 is above the main diagonal, diagPosition smaller 0 means 
            below the main diagonal.</param>
            <returns>Depending on 'X' a matrix or a vector with the elements on a diagonal.</returns>
            <remarks>The type of the ILArray returned will be the same as the type of X.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Double})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Int64})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Int32})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Byte})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{System.Single})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.diff(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Take n-th derivative
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <param name="N">[Optional] Degree of derivates. If not specified N=1 is assumed.</param>
            <returns>Array with first derivative of A along dimension <c>dim</c> of first non singleton dimension</returns>
            <remarks>N must be a number in range 1..L, where L is the length of A.Dimensions[dim]. 
            Otherwise an empty array will be returned.
            <para>If A is empty or scalar, or if N exceeds the length the specified dimension of A, 
            an empty array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.diff(System.Int32,ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            First derivative along specific dimension
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimensions to create derivative along</param>
            <returns>array with first derivative of A along dimension <c>dim</c></returns>
        </member>
        <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray)">
            <summary>
            Size of dimensions of A 
            </summary>
            <param name="A">Input array</param>
            <returns>Double array with the length of each dimension of A</returns>
            <remarks>If A is null, an empty array will be returned. Otherwise the array returned will always be a row vector of length s. s &gt;= 2</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.size(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            Length of one specific dimension of A
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Number of dimension to query the length for</param>
            <returns>Length of dimension 'dim'</returns>
        </member>
        <member name="M:ILNumerics.ILMath.size(System.Int32[])">
            <summary>
            Create a size descriptor
            </summary>
            <param name="dimensions">Arbitrary number of dimension length</param>
            <returns>Size descriptor</returns>
        </member>
        <member name="M:ILNumerics.ILMath.length(ILNumerics.ILBaseArray)">
            <summary>
            Longest dimension of A
            </summary>
            <param name="A">Input array</param>
            <returns>If A is null:0 - length of longest dimension of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.Longest</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ndims(ILNumerics.ILBaseArray)">
            <summary>
            Number of dimensions of A
            </summary>
            <param name="A">Input array</param>
            <returns>If A is null: 0 - else number of dimensions of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.NumberOfDimensions</remarks>
            
        </member>
        <member name="M:ILNumerics.ILMath.numel(ILNumerics.ILBaseArray)">
            <summary>
            Number of elements of A
            </summary>
            <param name="A">Input array</param>
            <returns>Number of elements of A</returns>
            <remarks>This is an alias/abreviation for A.Dimensions.NumberOfElements</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.distL1(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            pairwise L1 distance 
            </summary>
            <param name="A">input points (matrix)</param>
            <param name="B">input point (vector)</param>
            <returns>pairwise L1 distances between the data point provided in the input vector <paramref name="B"/> and the data points stored in the matrix <paramref name="A"/>.</returns>
            <remarks>
            <para>If <paramref name="B"/> is a colum vector, the distances between <paramref name="B"/> and the columns of <paramref name="A"/> are calculated. The number of rows of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of columns of <paramref name="A"/>: <code>A.S[1]</code>.</para>
            <para>If <paramref name="B"/> is a row vector, the distances between <paramref name="B"/> and the rows of <paramref name="A"/> are calculated. The number of columns of <paramref name="A"/> 
            must match the length of vector <paramref name="B"/> than. Therefore, the length of the returned vector of distances matches the number of rows of <paramref name="A"/>: <code>A.S[0]</code>.</para>
            <para>This function is cummulative, the single data point may be provided in <paramref name="A"/> and the data point matrix may be provided in <paramref name="B"/> as well.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.divide(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Divide elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise division of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initiialized with ILMath.returnType before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Double,System.Double)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initiialized with ILMath.returnType before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Single,System.Single)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initiialized with ILMath.returnType before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Single,System.Single)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <returns>Vector of eigenvalues of A. Size [n x 1]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The vector returned will be of complex inner type, since no further constraints are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues and eigenvectors of general square matrix A
            </summary>
            <param name="A">Input matrix A. Size [n x n]</param>
            <param name="V">Output matrix, eigenvectors EV of size [n x n]. May be null on input. If not null, content of V will be destroyed.</param>
            <returns>Diagonal matrix with eigenvalues of A. Size [n x n]</returns>
            <remarks><para>The eigenvalues of A are found by use of the Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The matrices returned will be of complex inner type, since no further constrains are set on the structure of A (it may be nonsymmetric). Use <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> functions for computing the real eigenvalues of symmetric matrices explicitly.</para>
            <para>A will be balanced first. This includes permutations and scaling of A in order to improve the conditioning of the eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)">
            <summary>
            Find eigenvalues  and eigenvectors 
            </summary>
            <param name="A">Input: square matrix, size [n x n]</param>
            <param name="V">Output (optional): eigenvectors</param>   
            <param name="propsA">Matrix properties, on input - if specified, 
            will be used to choose the proper method of solution. On exit will be 
            filled according to the properties of A.</param>
            <param name="balance">true: permute A in order to increase the 
            numerical stability, false: do not permute A.</param>
            <returns>eigenvalues as vector (if V is null) or as diagonoal 
            matrix (if V was requested, i.e. not null).</returns>
            <remarks><para>The eigenvalues of A are found by use of the 
            Lapack functions dgeevx, sgeevx, cgeevx and zgeevx. </para>
            <para>The arrays returned will be of complex inner type, 
            since no further constraints are set on the structure of 
            A (it may be nonsymmetric). Use 
            <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double})"/> 
            or <see cref="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            functions for computing the real eigenvalues of symmetric 
            matrices explicitly.</para>
            <para>Depending on the parameter <paramref name="balance"/>, 
            A will be balanced first. This includes permutations and 
            scaling of A in order to improve the conditioning of the 
            eigenvalues.</para></remarks>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.eig(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.MatrixProperties@,System.Boolean)"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if a 
            is not square</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Find all eigenvalues of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <returns>Array of size [n,1] with eigenvalues of A.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Find all eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors 
            will not be computed and V is not changed. In order to make the function return the vectors, V should be initiialized with ILMath.returnType before calling eigSymm.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">Specify the lowest limit for the range of eigenvalues to be queried.</param>
            <param name="rangeEnd">Specify the upper limit for the range of eigenvalues to be queried.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/></exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Double,System.Double)">
            <summary>
            Find some eigenvalues and -vectors of symmetric (hermitian) matrix
            </summary>
            <param name="A">Input matrix, Size [n x n], symmetric (hermitian for complex A) </param> 
            <param name="V">Output: n eigenvectors as columns. Size [n x n]. If V is null on input, the eigenvectors will not be computed and V is not changed. </param>
            <param name="rangeStart">The eigenvalues will be returned by increasing size. This will determine the number of the first eigenvalue to be returned.</param>
            <param name="rangeEnd">Determine the number of the last eigenvalue to be returned.</param>
            <returns>Diagonal matrix of size [n,n] with eigenvalues of A on the main diagonal.</returns>
            <remarks><para>For computation the Lapack functions dsyevr, ssyevr, chesvr and zheesv are used. </para>
            <para>Since A is symmetric, the eigenvalues will always be real. Therefore the return value will be of the same inner type as A.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A is not square or <paramref name="rangeEnd"/> &lt; <paramref name="rangeStart"/> or if either one is &lt;= 0.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compute eigenvalues <it>lambda</it> of symmetrical/hermitian inputs A and B: A*V=lamda*B*V
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <returns>Vector of eigenvalues. size [n x 1]</returns>
            <remarks>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] Returns eigenvectors in columns (size [n x n]). </param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. The return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eigSymm(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILMath.GenEigenType,System.Boolean)">
            <summary>
            Compute eigenvalues and eigenvectors (optional) of symmetric/hermitian input
            </summary>
            <param name="A">Square, symmetric/hermitian input matrix, size [n x n]</param>
            <param name="B">Square, symmetric/hermitian and positive definite matrix, size [n x n]</param>
            <param name="outV">[Output] If on input not null-&gt; returns eigenvectors in columns (size [n x n]). If null on input -&gt; eigenvectors will not get computed.</param>
            <param name="type">Determine the type of problem. This is one of the following types:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list>Here 'r' is the eigenvalue corresponding to the eigenvector 'V'.</param>
            <param name="skipSymmCheck">true: skip tests for A and B being hermitian.</param>
            <returns>Vector of eigenvalues. If the eigenvectors are requested as well (V not null on input), 
            the return value will be a diagonal matrix with the eigenvalues on the main diagonal.</returns>
            <remarks><para>The eigenvectors in 'V' are not normalized!</para>
            <para>Internally, the generalized eigenproblem A*V = r*B*V will be reduced to B<sup>-1</sup>*A*V = r*V using cholesky factorization. The 
            computations are handled by LAPACK functions DSYGV,SSYGV,CHEGV and ZHEGV.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if B was not positive definite</exception> 
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A and B was not of the same size</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if <paramref name="skipSymmCheck"/> is false and either A and/or B was found not to be symmetric/hermitian</exception>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the algorithm did not converge. All exceptions will contain an informational message describing the problem verbosely.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.empty">
            <summary>
            Create empty double array of size [0,0].
            </summary>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1(ILNumerics.ILSize)">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1(System.Int32[])">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty``1">
            <summary>
            Create empty array of size [0,0] and arbitrary element type
            </summary>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty(ILNumerics.ILSize)">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.empty(System.Int32[])">
            <summary>
            Create empty double array of specific size
            </summary>
            <param name="size">(Empty-) size of new empty array</param>
            <returns>Empty array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.returnType``1">
            <summary>
            Create new empty array, used for array class members
            </summary>
            <typeparam name="T">Element type</typeparam>
            <returns>Empty array which can afterwards be used for arbitrary assignements (Assign(), or 'array.A = ..' assignements)</returns>
            <remarks>The array returned will be an empty array initially. Its main purpose is to provide 
            a persistant array initialization. The array will not be disposed after leaving the current scope
            and can therefore be utilized for initializing class attributes. After initialization, use the 'ILArray.A = ...' property (C#) 
            or the ILArray.Assign() function to assign new values to the array.</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.pi">
            <summary>
            Definition of pi
            </summary>
            <remarks>This is an convenience alias for Math.PI</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.pif">
            <summary>
            Definition of pi, single precision
            </summary>
            <remarks>This is an convenience alias for Math.PI</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.macharF(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Single@,System.Single@,System.Single@,System.Single@)">
            <summary>
            Determine machine specific parameter
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.macharD(System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Int32@,System.Double@,System.Double@,System.Double@,System.Double@)">
            <summary>
            Determine machine specific parameter (double precision)
            </summary>
            <remarks>Source: Numerical Recipes in C, p.892</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.eq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
            <summary>
            Elementwise logical 'equal' operator
            </summary>
            <param name="A">Input array 1</param>
            <param name="B">Input array 2</param>
            <returns>Logical array having '1' for equal elements in A and B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither of A or B is scalar and the size of both arrays does not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Single})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.exp(ILNumerics.ILInArray{System.Double})">
            <summary>Exponential of array elements</summary>
            <param name="A">Input array</param>
            <returns>Exponential of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.eye(System.Int32,System.Int32)">
            <summary>
            Create double matrix having unity diagonal values  
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns>Unity matrix (diagonal matrix) of type double</returns>
        </member>
        <member name="M:ILNumerics.ILMath.eye``1(System.Int32,System.Int32)">
            <summary>
            Create unity matrix, arbitrary numeric type
            </summary>
            <param name="rows">Number of rows</param>
            <param name="columns">Number of columns</param>
            <returns>Unity matrix (diagonal matrix) of element type T</returns>
            <typeparam name="T">Element type</typeparam>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the type specified is not supported. Supported types are: double, float, complex, fcomplex, int, long, short, byte</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast inverse fourier transform (1D)
            </summary>
            <param name="A">Input (frequency domain)</param>
            <returns>Inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array</param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Real input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Tnput array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">Complex hermitian input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks><para>The transformation is computed along the first 
            non singleton dimension.</para>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (1D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast inverse fourier transform (1D)
            </summary>
            <param name="A">Input (frequency domain)</param>
            <returns>Inverse transformed output array</returns>
            <remarks>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array</param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in 
            the output having all imaginary part equal zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed along the first non 
            singleton dimension.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Real input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The output array returned will be complex hermitian. I.e. the real 
            part being even and the imaginary part being odd symmetrical.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if 
            the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Inverse fast fourier transform along specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL 
            (included), AMD ACML and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Inverse fast fourier transform, complex hermitian input
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <param name="dim">Dimension to compute FFT along. This parameter
            must be non-negative. </param>
            <returns>Real output array, same size as A</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the dim parameter is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The 2D transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The output array returned will be complex hermitian.</para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (2D, hermitian input)
            </summary>
            <param name="A">Complex hermitian input array (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Fast fourier transform (2D)
            </summary>
            <param name="A">input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the A array) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Input array</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. </para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifft2sym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Inverse fast fourier transform (2D)
            </summary>
            <param name="A">Complex hermitian input array, symmetric in first 2 dimensions</param>
            <param name="m">Transformation column length</param>
            <param name="n">Transformation row length</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The transformation is computed for the first 2 dimensions, regardless 
            of those dimensions being singleton or non-singleton. If A is an n-d array, 
            the transformation is repeated for trailing dimensions of A respectively. The 
            lengths of those trailing dimensions are not altered.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The data to be transformed (based on the array A) are resized according to 
            the length parameter m and n. If m or n is larger then the length of the corresponding 
            dimension of A, zeros will be padded, otherwise the dimensions are truncated respectively. </para>
            <para>The two dimensional transformation is equivalent to repeatedly transforming 
            the columns and after that transforming the rows of A. However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if one of n or m is negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Inverse fast fourier transform (n-D)
            </summary>
            <param name="A">Input array, n-D, complex hermitian (frequency domain)</param>
            <returns>Transformation result</returns>
            <remarks>
            <para>The n-dimensional inverse transformation is computed for the n-dimensional array A. 
            This is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter, complex hermitian</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Tnput array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftn(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, specific size)
            </summary>
            <param name="A">Input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result of size specified by 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ifftnsym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Inverse fast fourier transform (n-D, complex hermitian, specific size)
            </summary>
            <param name="A">Complex hermitian input array, n-D</param>
            <param name="dims">Transformation lengths, specifies the length of the dimensions 
            for the transformation array. The length of dims must be &gt; or equal to  the number of 
            dimensions of A. For elements in dim being smaller than corresponding dimension 
            length in A, the dimensions will be truncated, otherwise zeros will be padded.</param>
            <returns>Transformation result, real array of the size specified by the 'dims' parameter</returns>
            <remarks>
            <para>The n-dimensional transformation is computed for the n-dimensional array A. 
            Before the transform, the input is resized according to the 'dims' parameter. 
            Dimensions larger than corresponding entries in 'dim' are truncated, dimensions
            smaller than corresponding entries in 'dim' are zero padded.</para>
            <para>The n-dimensional transformation is equivalent to repeatedly (inplace) 
            computing one dimensional transformations along all dimensions of A.
            However, using this 
            function may be of magnitudes faster than using 1D transformations. This 
            depends on the algorithm and API provided by the underlying native library.</para>
            <para>Since a transform of complex hermitian input data results in the 
            output having the imaginary part equals zero, only the real part is 
            returned for convenience reasons.</para>
            <para>No check is made for A being hermitian! If A is not hermitian (by means 
            of round-off errors), the result will be wrong!</para>
            <para>The forward fourier transform and the inverse fourier transform of 
            a given data array A are mathematically equivalent. It's only a 
            scaling factor which is needed to make sure, A equals ifft(fft(A)). That 
            scaling is introduced in the inverse transform.</para>
            <para>The transformation is computed by use of the native library 
            which currently is set up for your processor and OS version. The underlying 
            library is automatically choosen at ILNumerics startup and accessed via the 
            static member ILMath.FFT. See the online documentation for more 
            details in how to tune/configure and select dedicated native libraries. 
            Currently supported libraries are: Intel MKL (included), AMD ACML 
            and FFTW3 (prepared, optional modules, not included due to licensing conflicts).</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">is thrown if the 
            dim parameter is null, its length is less then the number of dimensions of A 
            or any element of dims is non-negative</exception>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Double},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int64},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Single},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInArray{System.Byte},System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Byte})">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">[Optional] Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">[Optional] If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">[Optional] If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.find(ILNumerics.ILInLogical,System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutLogical)">
            <summary>
            Find nonzero elements in A
            </summary>
            <param name="A">Input array</param>
            <param name="limit">Number of elements to search for. If this value is <![CDATA[< 0]]> the function 
            will return at most 'limit' nonzero elements from the end of the array ordered by ascending index.
            Set to 0 to search full array (default).</param>
            <param name="C">If not null, the function will return the row indices of nonzero elements 
            as main return value. C will therefore hold the column indices of those elements. If A
            has more than 2 dimensions, the column indices will go along the 2nd dimension.</param>
            <param name="V">If not null on entrance, V will hold a copy of the values of nonzero elements returned.</param>
            <returns>Vector containing (sequential) indices of nonzero elements in A. If C was 
            not null, return value will contain row indices of nonzero elements. </returns>
            <remarks>The return type of the index vectors is always 'double'. The return type 
            of the element vector 'V' depends on the type of input array A. V and C may be null on 
            entrance, indicating their information is not needed. If V is not null (e.g. 'empty()') C must be 
            not null also. Any initial data of V or C will be lost.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fix(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards zero</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded towards zero</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.fliplr``1(ILNumerics.ILInArray{``0})">
            <summary>
            Reverse order of columns of matrix
            </summary>
            <typeparam name="T">Inner element type</typeparam>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its columns reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.fliplr(ILNumerics.ILInArray{System.Double})">
            <summary>
            Reverse order of columns of matrix
            </summary>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its columns reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.flipud``1(ILNumerics.ILInArray{``0})">
            <summary>
            Reverse order of rows of a matrix
            </summary>
            <typeparam name="T">Inner element type</typeparam>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its rows reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.flipud(ILNumerics.ILInArray{System.Double})">
            <summary>
            Reverse order of rows of a matrix
            </summary>
            <param name="A">Input matrix</param>
            <returns>Matrix of same size as A, having the order of its rows reversed</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions</exception>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Single})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.floor(ILNumerics.ILInArray{System.Double})">
            <summary>Round towards negative infinity</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded downwards to next integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.free``1(``0[])">
            <summary>
            Return a System.Array to the memory pool 
            </summary>
            <typeparam name="T">the element type</typeparam>
            <param name="obj4Dispose">the System.Array to be returned to the pool.</param>
            <remarks>Thes function allows the manual regristration of System.Arrays to the ILNumerics memory pool. See <see cref="M:ILNumerics.ILMath.New``1(System.Int32)"/> for a usage example.</remarks>
            <seealso cref="M:ILNumerics.ILMath.New``1(System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Byte}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int64}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Int32}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.horzcat``1(ILNumerics.ILInArray{``0}[])">
            <summary>
            Horizontal array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the second dimension (index 1).</param>
            <returns>Larger array having all arrays in 'arrays' placed next to each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.mvnpdf(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Probability density function for a multivariate normal random distribution
            </summary>
            <param name="A">Matrix of points in columns, where the probability density function is to be evaluated</param>
            <param name="mu">[Optional] Centers, size d x 1, if 'null': zeros are attempted, default: null</param>
            <param name="sigma">Covariance matrix, must be positive definite, size d x d or vector of lenght d</param>
            <returns>Random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
        </member>
        <member name="M:ILNumerics.ILMath.mvnpdf(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Probability density function for a multivariate normal random distribution
            </summary>
            <param name="A">Matrix of points in columns, where the probability density function is to be evaluated</param>
            <param name="mu">[Optional] Centers, size d x 1, if 'null': zeros are attempted, default: null</param>
            <param name="sigma">Covariance matrix, must be positive definite, size d x d or vector of lenght d</param>
            <returns>Random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ge(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'greater or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.gt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'greater than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being greater than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Imaginary part of complex array elements
            </summary>
            <param name="X">Complex input array</param>
            <returns>Imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.imag(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Imaginary part of complex array elements
            </summary>
            <param name="X">Complex input array</param>
            <returns>Imaginary part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ind2sub(ILNumerics.ILBaseArray,System.Int32)">
            <summary>
            Convert sequential index into subscript indices
            </summary>
            <param name="A">Input array</param>
            <param name="seqindex">Sequential index</param>
            <returns>Subscript indices</returns>
            <remarks><para>The index array returned will have the length of number of dimensions of A</para>
            <para>If A is a null or an empty array, the return value will be also be empty</para>
            </remarks>
            <exception cref="T:System.IndexOutOfRangeException">If seqindex is &lt; 0 or &gt;= numel(A)</exception>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Byte})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.invert(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Invert elements of A, return result into predefined output array
            </summary>
            <param name="A">Input array</param>
            <param name="outArray">Predefined array for results</param>
        </member>
        <member name="M:ILNumerics.ILMath.isempty(ILNumerics.ILBaseArray)">
            <summary>
            Test if array is empty
            </summary>
            <param name="A">Input array</param>
            <returns>True if at least one dimension of A has length 0, false otherwise</returns>
            <remarks>
            <para>This function is an alias for A.IsEmpty. Consider using the matrix property directly for improved performance.</para>
            </remarks>
            <seealso cref="P:ILNumerics.ILBaseArray.IsEmpty"/>
        </member>
        <member name="M:ILNumerics.ILMath.isequal(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Compares two arrays, return System.bool as result
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements and sizes of both arrays match; false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Compares elements of two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array</param>
            <param name="B">Input array</param>
            <returns>True, if all elements of both arrays are equal; false if any elements or the sizes are not equal</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isequalwithequalnans(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Compare two arrays, assume NaN and +/- infinity values are comparable and equal
            </summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>True if all non-NaN elements in A and B equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(System.Double)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.complex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(System.Single)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.fcomplex)">
            <summary>
            Find out, if value is finite
            </summary>
            <param name="input">Input value</param>
            <returns>True for finite values</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Double})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{System.Single})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isfinite(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds finite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is finite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Double})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{System.Single})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isinf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Locate infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Double})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{System.Single})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds invalid value elements (not-a-number)</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is invalid ("Not-a-Number"), 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Double})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{System.Single})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isneginf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds negative infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is negative infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isnull(ILNumerics.ILBaseArray)">
            <summary>
            Determine, if the array A is null (NULL, not assigned)
            </summary>
            <param name="A">Input array</param>
            <returns>True, if the array is null, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isnullorempty(ILNumerics.ILBaseArray)">
            <summary>
            Determine, if the array A is null (NULL or not assigned) or empty
            </summary>
            <param name="A">Input array</param>
            <returns>True, if the array is null or empty, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Double})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{System.Single})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.isposinf(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Finds positive infinite value elements</summary>
            <param name="A">Input array</param>
            <returns>Logical array with 1 if the corresponding elements of input array is positive infinite, 0 else.</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.le(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'lower or equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being lower or equal corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector of 100 elements 
            </summary>
            <param name="start">First value</param>
            <param name="end">Last value</param>
            <returns>Row vector with 100 elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.linspace``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector, generic output type
            </summary>
            <param name="start">First value, scalar, numeric</param>
            <param name="end">Last value, scalar, numeric</param>
            <param name="length">Number of elements to create, scalar, numeric</param>
            <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.linspace(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Create linearly spaced row vector, double precision
            </summary>
            <param name="start">First value</param>
            <param name="end">Last value</param>
            <param name="length">Number of elements to create</param>
            <returns>Row vector with 'length' elements linearly spaced between start and end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.loadArray``1(System.String,System.String)">
            <summary>
            Load single array from matfile file
            </summary>
            <typeparam name="T">Element type of the array to return</typeparam>
            <param name="filename">Path of the matfile on disk</param>
            <param name="arrayname">[Optional] name of the requested array in the matfile (default: empty string)</param>
            <returns>The array requested</returns>
            <remarks><para>If the matfile contains only one array, the <paramref name="arrayname"/> may
            be ommited. The only array is returned than.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logc(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Logarithm of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10c(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - complex output</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Logarithm of base 10 of array elements</summary>
            <param name="A">Input array</param>
            <returns>Complex logarithm of base 10 of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Single})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.log10(ILNumerics.ILInArray{System.Double})">
            <summary>Logarithm of base 10 of array elements - real output</summary>
            <param name="A">Input array</param>
            <returns>Logarithm of base 10 of array elements - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector of 30 elements 
            </summary>
            <param name="start">First exponent value</param>
            <param name="end">Last exponent value</param>
            <returns>Row vector with 30 elements logathmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.logspace(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create logarithmically spaced row vector
            </summary>
            <param name="start">First exponent value</param>
            <param name="end">Last exponent value</param>
            <param name="length">Number of elements to create</param>
            <returns>Row vector with 'length' elements logarithmically spaced between 10^start and 10^end</returns>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lt(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'smaller than' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A being smaller than corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <returns>Triangular matrices L and U composed into a single matrix as returned from LAPACK function ?getrf. Size [m x n]</returns>
            <remarks><para>The matrix returned is composed out of the lower triangular matrix L with unit diagonal and the strict upper triangular matrix U.</para>
            <code>
            :'''''''|
            |1 \    |
            | 1 \ R |
            |  1 \  |
            | L 1 \ |
            |    1 \|
            '''''''''
            </code>
            <para>This overload is mainly needed for further operations via Lapack libraries. If you need the 
            L and U matrices directly, you'd better use one of the overloaded versions 
            <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
             or <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> instead.</para>
            <para>The matrix L will be a solid ILArray.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            LU matrix decomposition. Decompose general matrix A into strictly upper part and lower part.
            </summary>
            <param name="A">Input matrix to be decomposed. Size [m x n]</param>
            <param name="U">[Output] Reference to U. On return this will be the strict upper triangular matrix of size [min(m,n) x n]. Must not be null on input.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that ILMath.multiply (L,U) will result in A.
            <para>L will only be a permuted version of a true triangular matrix. I.e. the rows of L will be permuted in order 
            to fullfill <c>ILMath.multiply(L,U) == A</c></para>
            <example> <code>
            //we construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct reference on U and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 0,20000  -1,00000  1,00000 
            // 0,80000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            // and U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            Pay attention to the structure of L. In the example above the first and third row are exchanged. This permutation reflects the pivoting done during the decomposition inside the Lapack function ?getrf. </example>
            <para>In order to access the permutation of L, one can use the overloaded version <see cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> which returns the permuation matrix P also.</para>
            <para>All of the matrices U and L returned will be solid ILArrays.</para>
            <para>lu uses the Lapack function ?getrf.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Decompose matrix A into uper and lower triangular part. Returns permutation matrix also. 
            </summary>
            <param name="A">Input matrix. Size [m x n]</param>
            <param name="U">[Output] Reference to upper triangular matrix. Size [min(m,n) x n]. Must not be null.</param>
            <param name="P">[Output] Reference to permutation matrix. Size [min(m,n) x min(m,n)]. Must not be null.</param>
            <returns>Lower triangular matrix L of size [m x min(m,n)]</returns>
            <remarks>A is decomposed into L and U, so that the equation 
            <c>ILMath.multiply(L,U) == ILMath.multiply(P,A)</c> 
            will hold except for round off error.
            <para>L and U will be true lower triangular matrices.</para>
            <example> <code>
            //Let's construct a matrix X: 
            ILArray&lt;double&gt; X = new ILArray&lt;double&gt;(new double[]{1, 2, 3, 4, 4, 4, 5, 6, 7},3,3).T;
            // now X.ToString() will give something like:
            // {&lt;Double&gt; 63238509 [3x3] Ref(2) 
            //(:,:) 
            // 1,00000  2,00000  3,00000 
            // 4,00000  4,00000  4,00000 
            // 5,00000  6,00000  7,00000 
            //}
            // construct references on U and P and call the decomposition
            ILArray&lt;double&gt; U = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; P = new ILArray&lt;double&gt;.empty();
            ILArray&lt;double&gt; L = ILMath.lu(X, ref U, ref P); 
            
            // L.ToString() is now: 
            // {&lt;Double&gt; 19634871 [3x3] Phys. 
            //(:,:) 
            // 1,00000   0,00000   0,00000 
            // 0,80000   1,00000   0,00000 
            // 0,20000  -1,00000   1,00000 
            //}
            // U is now: 
            //{&lt;Double&gt; 22584602 [3x3] Phys. 
            //(:,:) 
            // 5,00000  6,00000  7,00000 
            // 0,00000  -0,80000  -1,60000 
            // 0,00000  0,00000  0,00000 
            //}
            // and P is: 
            //{&lt;Double&gt; 2192437 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  1,00000 
            // 0,00000  1,00000  0,00000 
            // 1,00000  0,00000  0,00000 
            //}
            </code>
            In order to reflect the pivoting done during the decomposition inside ?getrf, the matrix P may be used on A:
            <code>
            (ILMath.multiply(P,A) - ILMath.multiply(L,U)).ToString();
            // will give:
            //{&lt;Double&gt; 59192235 [3x3] Phys. 
            //(:,:) 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            // 0,00000  0,00000  0,00000 
            //}
            </code>
            </example>
            <para>lu uses the Lapack function ?getrf.</para>
            <para>All of the matrices U,L,P returned will be solid ILArrays.</para>
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double})"/>
            <seealso cref="M:ILNumerics.ILMath.lu(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException"> if input A is not a matrix.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.copyUpperTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32)">
            <summary>
            Copy upper triangle from PHYSICAL array A
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <returns>Newly created physical array with the upper triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyUpperTriangle``1(``0[],System.Int32,System.Int32,System.Int32)">
            <summary>
            Copy upper triangle from system array A
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="arrIn">System array, size (m x n), column wise ordered</param>
            <param name="arrInM">Number of rows</param>
            <param name="arrInN">Number of columns</param>
            <param name="outM">Number of rows in output matrix</param>
            <returns>Newly created physical array with the upper triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A! copies the main diagonal also.
            the array returned will be of size (min(m,n) x n)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyLowerTriangle``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0)">
            <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <param name="val">Value for diagonal entries</param>
            <returns>Newly created physical array with the lower triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.copyLowerTrianglePerm``1(ILNumerics.ILInArray{``0},System.Int32,System.Int32,``0,System.Int32[])">
            <summary>
            Copy lower triangle from PHYSICAL array A, set diagonal to val, permuted version
            </summary>
            <typeparam name="T">Arbitrary inner type </typeparam>
            <param name="A">PHYSICAL ILArray</param>
            <param name="m">Number of rows</param>
            <param name="n">Number of columns</param>
            <param name="perm">Mapping for rows, must be converted fom LAPACK version to single indices </param>
            <param name="val">Value for diagonal entries</param>
            <returns>Newly created physical array with the lower triangle of A</returns>
            <remarks>No checks are made for m,n fit inside A!</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.perm2indicesForward(System.Int32[])">
            <summary>
            Relabel permutation indices from LAPACK ?getrf
            </summary>
            <param name="perm">Lapack pivoting permutation array</param>
            <returns>Index mapping for direct addressing the rows </returns>
            <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.perm2indicesBackward(System.Int32[])">
            <summary>
            Relabel permutation indices from LAPACK ?getrf - backward version
            </summary>
            <param name="perm">Lapack pivoting permutation array</param>
            <returns>Index mapping for direct addressing the rows </returns>
            <remarks>Exchange the row labels in the same manner as LAPACK did for pivoting, but backwards</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Double})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istrilow(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is a lower triangular matrix
            </summary>
            <param name="A">Matrix of numeric inner type</param>
            <returns>true if A is a lower triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.istriup(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is upper triangular matrix
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper triangular matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was not a matrix or if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishesslow(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is lower Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a lower Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishessup(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is upper Hessenberg matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a upper Hessenberg matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.ishermitian(ILNumerics.ILInArray{System.Single})">
            <summary>
            Determine if matrix A is Hermitian matrix 
            </summary>
            <param name="A">Matrix or scalar A of numeric inner type</param>
            <returns>true if A is a Hermitian matrix, false otherwise</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if A was null</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>
            Maximum values along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Maximum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the maximum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.maxall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Maximum for all elements of A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar maximum of all elements for A</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.max(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean of array along specified dimension
            </summary>
            <param name="A">Input Array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of elements along specified or first non singleton dimension</returns>
            <remarks>The return array has the same shape as A, but the specified or first non singleton dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Int64},ILNumerics.ILOutArray{System.Int64})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Int32},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Create two matrices for evaluation and visualization of 2 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="outY">[Output, Optional]: if on entry outY is not null, on return it will hold the values for the Y dimension</param>
            <returns>X values matrix along the values of the X input array. Corresponding values for Y are returned in outY</returns>
            <remarks>The matrices returned can be utilize to evaluate and visualize functions of 2 variables X and Y.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.meshgrid(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Create 3d arrays for evaluation and visualization of 3 dimensional functions
            </summary>
            <param name="X">Vector of x values</param>
            <param name="Y">Vector of y values</param>
            <param name="Z">Vector of z values</param>
            <param name="outY">[Output, Optional] If on entry outY is not null, on return it will hold the values for the y dimension</param>
            <param name="outZ">[Output, Optional] If on entry outZ is not null, on return it will hold the values for the z dimension</param>
            <returns>X value array along the values of the X input vector, arrays for y and z dimensions are returned in outY and outZ respectively</returns>
            <remarks>The arrays returned can be used to evaluate and visualize functions of 3 variables X, Y and Z.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Double},System.Int32)">
            <summary>Minimum value along specified dimension</summary>
            <param name="A">Input array</param>
            <param name="I">[Optional] If not null I will hold on return the indices into dim of  
            the values found. If, on entering the function, I is null, those indices 
            will not be computed and I will be ignored.</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array of same inner type and size as A, except for dimension 
            'dim' which will be reduced to length 1.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Minimum of A and B elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with the minimum elements of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Minimum of all elements of array A
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar minimum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.min(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mod(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Modulus of array elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of elementwise modulus operation</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Multiplicate an arbitrary number of matrices from left to right
            </summary>
            <param name="matrices">Input matrices </param>
            <returns>Result of matrix multiplication for all matrices</returns>
        </member>
        <member name="M:ILNumerics.ILMath.multiply(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            General matrix multiply this array
            </summary>
            <param name="A">Input matrix A</param>
            <param name="B">Input matrix B</param>
            <returns>Matrix with result of matrix multiplication</returns>
            <remarks>Both arrays must be matrices with matching dimension length. Therefore the number of rows 
            of B must equal the number of columns of A. An ILArgumentSizeException will be thrown otherwise. 
            The multiplication will be carried out inside optimized BLAS libraries if availiable. If not it 
            will be done in managed code. 
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException">If at least one arrays is not a matrix</exception>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If the size of both matrices do not match</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.multiplyElem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Multiply arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise multiplication of A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(System.Int32)">
            <summary>
            Choose samples from a multivariate random distribution
            </summary>
            <returns>n random numbers as taken from the multivariate random probability distribution with zero mean and unity covariance</returns>
            <remarks><para>This is an alias for <see cref="M:ILNumerics.ILMath.randn(params int[])"/>. If n was not specified, a single random number is generated.</para>
            <para>The samples are returned as row vector of size 1 x n.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd">
            <summary>
            Choose one sample from a multivariate random distribution
            </summary>
            <returns>Single random number, taken from the multivariate random probability distribution with zero mean and unity covariance</returns>
            <remarks><para>This is an alias for <see cref="M:ILNumerics.ILMath.randn(params int[])"/>. A single (scalar) random number is generated.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            choose samples from a multivariate random distribution  
            </summary>
            <param name="inMu">[optional] centers, size d x n; if d x 1 is given, optional parameter <paramref name="n"/> is used to replicate mu accordingly, if null, the values will be genereated with a center of zero</param>
            <param name="inSigma">[optional] covariance matrix, must be positive definite, size d x d or vector of lenght d, if null (not set), unitiy matrix is expected</param>
            <param name="n">[optional] number of samples to generate, per default (-1) the number of columns of <paramref name="mu"/> defines that number</param>
            <param name="sigmaIsSquaredCov">[optional] if false: safe the effort of finding the square root of <paramref name="sigma"/> parameter; default: true</param>
            <returns>random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
            <remarks><para>In order to safe the step of finding the root of sigma, the following options exist: 
            <list type="bullet">
            <item>Provide only the diagonal of a (virtual) diagonal matrix to <paramref name="sigma"/>.</item>
            <item>Compute the root manually, give it to sigma and set <paramref name="sigmaIsSquaredCov"/> to false.</item>
            </list></para>
            <para>In case <paramref name="sigmaIsSquaredCov"/> set to 'false' and <paramref name="sigma"/> is given, 
            the root is computed via cholesky factorization. The result of the last root finding process is cached and reused for 
            subsequent requests with the same set of <paramref name="n"/> and <paramref name="sigma"/> parameters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.mvnrnd(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            choose samples from a multivariate random distribution  
            </summary>
            <param name="inMu">[optional] centers, size d x n; if d x 1 is given, optional parameter <paramref name="n"/> is used to replicate mu accordingly, if null, the values will be genereated with a center of zero</param>
            <param name="inSigma">[optional] covariance matrix, must be positive definite, size d x d or vector of lenght d, if null (not set), unitiy matrix is expected</param>
            <param name="n">[optional] number of samples to generate, per default (-1) the number of columns of <paramref name="mu"/> defines that number</param>
            <param name="sigmaIsSquaredCov">[optional] if false: safe the effort of finding the square root of <paramref name="sigma"/> parameter; default: true</param>
            <returns>random numbers as taken from the multivariate random probability distribution given by mu and sigma</returns>
            <remarks><para>In order to safe the step of finding the root of sigma, the following options exist: 
            <list type="bullet">
            <item>Provide only the diagonal of a (virtual) diagonal matrix to <paramref name="sigma"/>.</item>
            <item>Compute the root manually, give it to sigma and set <paramref name="sigmaIsSquaredCov"/> to false.</item>
            </list></para>
            <para>In case <paramref name="sigmaIsSquaredCov"/> set to 'false' and <paramref name="sigma"/> is given, 
            the root is computed via cholesky factorization. The result of the last root finding process is cached and reused for 
            subsequent requests with the same set of <paramref name="n"/> and <paramref name="sigma"/> parameters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'not equal' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal to corresponding elements in B, '0' else</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.neq(ILNumerics.ILInArray{System.String},ILNumerics.ILInArray{System.String})">
            <summary>
            Elementwise logical 'not equal' operator
            </summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array having '1' for elements in A not equal elements in B, '0' else</returns>
            <remarks><para>On empty input - empty array will be returned.</para>
            <para>A and / or B may be scalar. The scalar value will operate on all elements of the other arrays in this case.</para>
            <para>If neither of A or B is scalar or empty, the dimensions of both arrays must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">if neither of A or B is scalar and the size of both arrays does not match</exception>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILMath.New``1(System.Int32)" ignoriert -->
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">Input matrix/ vector</param>
            <param name="degree">[Optional] Degree of norm (default = 2). For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices this must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns max(sum(abs(A), 2)), the largest value of the sums along the rows</item>
            </list>
            </param>
            <returns>Array of same type as input array A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">Input matrix/ vector</param>
            <param name="degree">[Optional] Degree of norm (default = 2). For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices this must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns max(sum(abs(A), 2)), the largest value of the sums along the rows</item>
            </list>
            </param>
            <returns>Array of same type as input array A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{System.Single},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">Input matrix/ vector</param>
            <param name="degree">[Optional] Degree of norm (default = 2). For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices this must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns max(sum(abs(A), 2)), the largest value of the sums along the rows</item>
            </list>
            </param>
            <returns>Array of same type as input array A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.norm(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
            <summary>
            Vector or matrix norm
            </summary>
            <param name="A">Input matrix/ vector</param>
            <param name="degree">[Optional] Degree of norm (default = 2). For vectors this must be one of: 
            <list type="bullet">
            <item>arbitrary double value : returns sum(pow(abs(A),degree))^(1/degree)</item>
            <item>System.double.PositiveInfinity: return Max(abs(A))</item>
            <item>System.double.NegativeInfinity: return Min(abs(A))</item>
            </list>
            For matrices this must be one out of: 
            <list type="bullet">
            <item>0: returns Frobenius norm: sqrt(sum(diag(multiply(A, A[1]))))</item>
            <item>1: returns 1-norm, max(sum(abs(A)))</item>
            <item>2: returns the largest singular value of A, max(svd(A))</item>
            <item>PositiveInfinity: returns max(sum(abs(A), 2)), the largest value of the sums along the rows</item>
            </list>
            </param>
            <returns>Array of same type as input array A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ones(System.Int32[])">
            <summary>
            Create new double array, set initial values to 1
            </summary>
            <returns>array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.ones(ILNumerics.NumericType,ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned must be casted to the appropriate actual type afterwards and assigned to a concrete array! Caution: 
            This overload is provided for compatibility reasons only! Use <see cref="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)"/> instead.
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones``1(System.Int32[])">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <typeparam name="T">Numeric type specification.</typeparam>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to the given type.</returns>
             <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>complex</item>
            <item>fcomplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones``1(ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to one
            </summary>
            <typeparam name="T">Numeric type specification.</typeparam>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to the given type.</returns>
             <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>complex</item>
            <item>fcomplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ones(ILNumerics.ILSize)">
            <summary>
            Create new double array, set initial values to 1
            </summary>
            <returns>Array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.or(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'or' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'or' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Single},System.Single)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.fcomplex)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Pseudo - inverse of input argument M
            </summary>
            <param name="M">Input matrix M</param>
            <returns>Pseudo inverse of input matrix M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses Lapack's function svd internally. Any singular values less than 
            the default tolerance will be set to zero. As tolerance the following equation is used: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest number greater than zero</item>
            </list>
            You may use a overloaded function to define an alternative tolerance. 
            </remarks>
            <seealso cref="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{System.Double},System.Double)"/>
        </member>
        <member name="M:ILNumerics.ILMath.pinv(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.complex)">
            <summary>
            Pseudo inverse of input matrix M
            </summary>
            <param name="M">Input matrix M</param>
            <param name="tolerance">Tolerance, see remarks (default = -1; use default tolerance)</param>
            <returns>Pseudo inverse of M</returns>
            <remarks>The function returns the pseudo inverse (Moore-Penrose pseudoinverse)
            of input matrix M. The return value will be of the same size as 
            the transposed of M. it will satisfy the following conditions: 
            <list type="bullet">
            <item>M * pinv(M) * M  = M </item>
            <item>pinv(M) * M * pinv(M) = pinv(M)</item>
            <item>pinv(M) * M is hermitian</item>
            <item>M * pinv(M) is hermitian</item>
            </list>
            pinv uses LAPACK's function svd internally. Any singular values less than 
            tolerance will be set to zero. If tolerance is less than zero, the following equation 
            is used as default: \\
            tol = length(M) * norm(M) * Double.epsilon \\
            with 
            <list type="bullet">
            <item>length(M) - the longest dimension of M</item>
            <item>norm(M) being the largest singular value of M, </item>
            <item>Double.epsilon - the smallest constructable double precision number greater than zero</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            </summary>
            <param name="theta">Angle to x axis</param>
            <param name="radius">Radius from z axis</param>
            <param name="Z">Height</param>
            <param name="outY">If on entry not null, the Y components are returned in outY</param>
            <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
            <returns>X component, Y and Z are returned as out parameter if requested</returns>
            <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pol2cart(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Transform polar/ cylindrical coordinates into scalar coordinates
            </summary>
            <param name="theta">Angle to x axis</param>
            <param name="radius">Radius from z axis</param>
            <param name="Z">Height</param>
            <param name="outY">If on entry not null, the Y components are returned in outY</param>
            <param name="outZ">If on entry not null, the Z components are returned in outZ</param>
            <returns>X component, Y and Z are returned as out parameter if requested</returns>
            <remarks>Theta, radius and Z must be of the same size or either one may be scalar. 
            Scalar coordinate arrays returned are of the same size then the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.pow(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Power elements</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Array with elementwise result of A <sup>B</sup></returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if all elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.prod(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>Product of array elements along specific dimension</summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array of same size as A, having dim's dimension reduced to 1, if any elements along that dimension are nonzero, '0' else. </para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            QR decomposition - raw Lapack output
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Orthonormal / unitary matrix Q and upper triangular 
            matrix R packed into single matrix. This is the output of the 
            lapack function ?geqrf.</returns>
            <remarks><para>Input matrix A will not be altered. </para>
            <para>The matrix returned is the direct output of the lapack 
            function [d,s,c,z]geqrf respectively. This means that it contains 
            the decomposition factors Q and R, but they are combined into a 
            single matrix for performance reasons. If you need one of the factors, 
            you would use the overloaded function 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})"/> 
            instead, which returns those factors separately.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            QR decomposition, returning Q and R
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition, size [m x m]</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds within roundoff errors. ('*' denotes 
            matrix multiplication)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            QR decomposition, returning Q and R, optionally economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition, size [m x n]</param>
            <param name="economySize">If true, the size of Q and R will 
            be [m x m] and [m x n] respectively. However, if m &lt; n, 
            the economySize parameter has no effect. </param>
            <returns>Orthonormal real / unitary complex matrix Q as result 
            of decomposition. Size [m x m] or [m x min(m,n)], depending 
            on <paramref name="economySize"/> (see remarks below)</returns>
            <remarks>The function returns Q and R such that the equation 
            <para>A = Q * R</para> holds with roundoff errors. ('*' 
            denotes matrix multiplication.)</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            QR decomposition with pivoting
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix 
            R as result of decomposition. Size [m x n] or [min(m,n) x n] 
            (see remarks). </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]</param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x min(m,n)]</returns>
            <remarks>The function returns Q, R and E such that the equation 
            <para>A * E = Q * R</para> holds with roundoff errors, where '*' 
            denotes matrix multiplication. E reflects the pivoting done 
            inside LAPACK in order to give R increasingly diagonal elements.</remarks>
            <seealso cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            QR decomposition with pivoting, possibly economical sized
            </summary>
            <param name="A">Input matrix A of size [m x n]</param>
            <param name="outR">[Output] Upper triangular matrix R as 
            result of decomposition. Size [m x n] or [min(m,n) x n] depending 
            on <paramref name="economySize"/> (see remarks).</param>
            <param name="economySize"><para>If true, <list type="bullet">
            <item>the size of Q and R will be [m x m] and [m x n] respectively. 
            However, if m &lt; n, the economySize parameter has no effect on 
            those sizes.</item>
            <item>the output parameter E will be returned as row permutation 
            vector rather than as permutation matrix</item></list></para>
            <para>If false, this function acts exactly as its overload 
            <see cref="M:ILNumerics.ILMath.qr(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})"/></para>
            </param>
            <param name="outE">[Output] Permutation matrix from pivoting. Size [m x m]. 
            If this is not null, the permutation matrix/ vector E will be returned.
            <para>E is of size [n x n], if <paramref name="economySize"/> is 
            true, a row vector of length n otherwise</para></param>
            <returns>Orthonormal / unitary matrix Q as result of decomposition. 
            Size [m x m] or [m x min(m,n)], depending on <paramref name="economySize"/> 
            (see remarks below)</returns>
            <remarks><para> If <paramref name="economySize"/> is false, the function 
            returns Q, R and E such that the equation A * E = Q * R holds within 
            roundoff errors. </para>
            <para>If <paramref name="economySize"/> is true, E will be a permutation 
            vector and the equation A[":",E] == Q * R holds (except roundoff).</para>
            <para>E reflects the pivoting of A done inside LAPACK in order to give R 
            increasingly diagonal elements.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Region creator for subarray specifications
            </summary>
            <param name="start">Begin of region, index of first element</param>
            <param name="end">End of region, last element</param>
            <returns>An array which specifies all indices of the region</returns>
            <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end"/> keyword - even in 
            conjunction with simple mathematical expressions.</remarks>
            <example><code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code></example>
        </member>
        <member name="M:ILNumerics.ILMath.r(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Stepped region creator for subarray specifications
            </summary>
            <param name="start">Begin of region, index of first element</param>
            <param name="end">End of region, last element</param>
            <param name="step">Increment, distance between created indices</param>
            <returns>An array which specifies the indices of the region</returns>
            <remarks>The r function provides a shorter way to specify regions in subarray
            expressions. Other than alternatives like <see cref="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>, 
            it also enables the use of the <see cref="P:ILNumerics.ILMath.end"/> keyword - even in 
            conjunction with simple mathematical expressions.</remarks>
            <example><code>ILArray&lt;double&gt; A = counter(5,4,3), B;
            
            // the following subarrays will all create the same B: 
            B = A[full,r(1,end-1),full]; 
            B = A[r(0,end),"1,2",":"];
            B = A[":;1:2;0:end"];
            
            // however, these expression will <b>not</b> work:
            B = A[":;0:end-1,:"]; // 'end' expression evaluation is not supported in strings. 
            </code></example>
        </member>
        <member name="M:ILNumerics.ILMath.rand(System.Int32[])">
            <summary>
            Pseudo random N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks><para>The elements lie within the range 0.0 ... 1.0 and are uniformly 
            distributed.</para>
            <para>The initial seed will be set to Environment.TickCount on the first call.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.randn(System.Int32[])">
            <summary>
            Normal randomly-distributed N-dimensional array elements.
            </summary>
            <param name="dimensions">int array or single int paramters specifying 
            dimensions for new array to be created.</param>
            <returns>N-dimensional array filled with random numbers.</returns>
            <remarks>The elements lie within the range 0.0 ... 1.0 and are choosen to be normally 
            distributed.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.randperm(ILNumerics.ILBaseArray)">
            <summary>
            Create a random permutation of integers 
            </summary>
            <param name="length">Number of unique integers to be created</param>
            <returns>Vector of length 'length' and element type double</returns>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Double},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{System.Single},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.rank(ILNumerics.ILInArray{ILNumerics.complex},System.Double)">
            <summary>
            Rank of matrix A
            </summary>
            <param name="A">Input matrix</param>
            <param name="tolerance">[Optional]Tolerance used to decide, if a singular value is 
            treated as zero. If a value &lt; 0 is specified the tolerance will be determined automatically (see below - default = -1.0)</param>
            <returns>Rank of matrix A</returns>
            <remarks>The rank is the number of singular values greater than 
            tolerance. If tolerance is smaller than zero, the following equation is used as 
            default: \\
            tol = length(A) * norm(A) * MachineParameterDouble.epsilon \\
            with 
            <list type="bullet">
            <item>length(A) - the longest dimension of A</item>
            <item>norm(A) being the largest singular value of A, </item>
            <item>MachineParameterDouble.eps - the distance between 1 and the smallest next greater value</item>
            </list>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Real part of complex array
            </summary>
            <param name="X">Complex input array</param>
            <returns>Real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Real part of complex array
            </summary>
            <param name="X">Complex input array</param>
            <returns>Real part of complex array</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert real array to complex array
            </summary>
            <param name="A">Input array</param>
            <returns>Complex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2complex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create complex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>Complex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>Real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single})">
            <summary>
            Convert real array to fcomplex array
            </summary>
            <param name="A">Input array</param>
            <returns>fcomplex array with A as real part, imaginary part is zero</returns>
        </member>
        <member name="M:ILNumerics.ILMath.real2fcomplex(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Create fcomplex array out of real and imaginary parts
            </summary>
            <param name="real">Real array for real part</param>
            <param name="imag">Real array for imaginary part</param>
            <returns>fcomplex array having the real- and part imaginary parts constructed out of 
            real and imag.</returns>
            <remarks>real and imag must have the same number of elements.
            The array returned will have the same size as the input arrays.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Byte},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int64},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Int32},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.repmat``1(ILNumerics.ILInArray{``0},System.Int32[])">
            <summary>
            Array replication 
            </summary>
            <param name="X">Input array to be replicated</param>
            <param name="size">Dimensions specifier, number of rows, columns .. to replicate this array</param>
            <returns>Reference ILArray as replication of X</returns>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Double},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{ILNumerics.complex},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Byte},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int64},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Int32},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape(ILNumerics.ILInArray{System.Single},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},System.Int32[])">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="newDimensions">New dimensions array. This may be 
            a comma seperated list or an int array</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new array is created, having 
            the size and number of dimensions specified by <paramref name="newDimensions"/>. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements specified 
            by <paramref name="newDimensions"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.reshape``1(ILNumerics.ILInArray{``0},ILNumerics.ILSize)">
            <summary>
            Array reshaping
            </summary>
            <param name="A">Input array A</param>
            <param name="dim">New dimension</param>
            <returns>Reshaped array</returns>
            <remarks>A will not be changed. A new reference array is created, having 
            the size and number of dimensions specified by dim. </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentSizeException"> 
            If the number of elements in A and the number of elements for the 
            new dimensions specified by <paramref name="dim"/> 
            do not match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Single})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.round(ILNumerics.ILInArray{System.Double})">
            <summary>Round to nearest integer</summary>
            <param name="A">Input array</param>
            <returns>Array of same size as A with elements rounded to nearest integer</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Double})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Single})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function for each element a is computed by: a / abs(a). Therefore, values returned will all lay on the unit circle.</para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int64})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int32})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Int16})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sign(ILNumerics.ILInArray{System.Byte})">
            <summary>Signum of array elements</summary>
            <param name="A">Input array</param>
            <returns>Array with elements signaling the sign of corresponding elements of A</returns>
            <remarks><para>The signum function produces following values: <list type="bullet"><item>-1 - for elements &lt; zero,</item><item> 0 - for elements equal zero,</item><item> 1 - for elements &gt; zero,</item></list></para><para>If the input array is empty, an empty array will be returned.</para>
                                    <para>The array returned will be a solid array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Double})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sin(ILNumerics.ILInArray{System.Single})">
            <summary>Sinus of array elements</summary>
            <param name="A">Input array</param>
            <returns>Sinus of elements from input array</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sinh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic sine of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic sine of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveUpperTriangularSystem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveLowerTriangularSystem(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveUpperTriangularSystem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveLowerTriangularSystem(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveUpperTriangularSystem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveLowerTriangularSystem(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <returns>Solution x solving the equation system: multiply(A, x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the structure and properties of A, the equation system will be solved in different ways:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>if A is square and symmetric or hermitian, A will be decomposed into a triangular equation system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the cholesky factorization is canceled. </para></item>
            <item>otherwise, if A is square only, it will be decomposed into upper and lower triangular martices using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU factorization here. The un-squared case is handled differently. A direct Lapack driver function (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.linsolve(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.MatrixProperties@)">
            <summary>
            Solve linear equation system
            </summary>
            <param name="A">Matrix A. Size [n x q]</param>
            <param name="B">Right hand side B. Size [n x m]</param>
            <param name="props">Matrix properties. If defined, no checks are made for the structure of A. If the 
            matrix A was found to be (close to or) singular, the 'MatrixProperties.Singular' flag in props will be set. 
            This flag should be tested on return, in order to verify the reliability of the solution.</param>
            <returns>The solution x solving multiply(A,x) = B. Size [n x m]</returns>
            <remarks><para>Depending on the <paramref name="props"/> parameter the equation system will be solved 
            differently for special structures of A:
            <list type="bullet">
            <item>If A is square (q == n) and an <b>upper or lower triangular</b> matrix, the system will directly 
            be solved via backward- or forward substitution. Therefore the Lapack function ?trtrs will be used, 
            whenever the memory layout of A is suitable. This may be the case even for reference ILArray's! 
            <example><code><![CDATA[ILArray<double> A = ILMath.randn(4); // construct 4 x 4 matrix 
            A = A.T; // A is a reference array now! The transpose is fast and does not consume much memory
            // now construct a right side and solve the equations: 
            ILArray<double> B = new ILArray<double> (1.0,2.0,3.0).T; 
            ILMath.linsolve(A,B); // ... will be carried out via Lapack, even for all arrays involved being reference arrays! ]]></code></example></item>
            <item><para>If A is square and symmetric or hermitian, A will be decomposed into a triangular equation 
            system using cholesky factorization and Lapack. The system is than solved using performant Lapack routines.</para>
            <para>If during the cholesky factorization A was found to be <b>not positive definite</b> - the 
            corresponding flag in props will be cleaned and <c>null</c> will be returned.</para></item>
            <item>Otherwise if A is square only, it will be decomposed into upper and lower triangular matrices 
            using LU decomposition and Lapack. The triangular system is than solved using performant Lapack routines.</item>
            <item>Otherwise, if A is of size [q x n] and q != n, the system is solved using QR decomposition. 
            A may be rank deficient. The solution is computed by use of the Lapack routine '?gelsy' and may be a 
            reference array.</item>
            </list></para>
            <para>Compatibility with Matlab<sup>(R)</sup>: If A is square, the algorithm used follows the same 
            logic as Matlab up to Rel 14, with the exception of Hessenberg matrices wich are solved via LU 
            factorization here. The un-squared case is handled differently. A direct Lapack driver function 
            (?gelsy) is used here. Therefore the solutions might differ! However, the solution will of course 
            fullfill the equation A * x = B without round off errrors. </para>
            <para>For specifiying the rank of A in the unsquare case (q != n), 
            <see cref="P:ILNumerics.ILMath.eps"/> is used.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveUpperTriangularSystem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a upper triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be upper triangular. No check is made for that!</param>
            <param name="B">Solution vector or matrix. Size [n x m]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via backward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A below the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.solveLowerTriangularSystem(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex},System.Int32@)">
            <summary>
            Solve system of linear equations A*x = b, with A being a lower triangular matrix
            </summary>
            <param name="A">Input matrix of size [n x n], must be lower triangular. No check is made for that!</param>
            <param name="B">Solution vector. Size [n x 1]</param>
            <param name="singularityDetect">[Output] This value gives the row of A, where a singularity has been detected (if any). If A is not singular, this will be a negative value.</param>
            <returns>Solution x solving A * x = b.</returns>
            <remarks><para>The solution will be determined via forward substitution</para>
            <para>Make sure, A and b are of correct size, since no checks are made for that!</para>
            <para>This function is used by ILMath.linsolve. There should be rare need for you to call this function directly.</para>
            <para>Elements of A above the main diagonal will not be accessed.</para>
            <para>If A has been found to be singular, the array returned will contain NaN values for corresponding elements!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int64},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Int32},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted in ascending order using a non-recursive quick sort algorithm. 
            Elements along the columns of A will get sorted independently from each other. A is not altered.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Boolean)">
            <summary>
            Sort data in A along first non singleton dimension
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Determine the direction of sorting (ascending/ descending)</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted using the quick sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the next row/column.
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Byte},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Sort data in A along dimension 'dim'
            </summary>
            <param name="A">Input array, n-dimensional</param>
            <param name="descending">Direction of sorting</param>
            <param name="dim">Dimension index to sort along</param>
            <param name="Indices">[Output] Returns permutation matrix</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks>The data in A will be sorted along the dimension <paramref name="dim"/> using a non-recursive quicksort 
            algorithm.  
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>Properties of sorting can be tuned by the settings of <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/> 
            and <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/>.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            <example><code>ILArray&lt;double&gt; A = ILMath.rand(1,5); 
            //A: 
            // 0.4324  0.9231  0.1231  0.1423  0.2991
            ILArray&lt;double&gt; I; 
            ILArray&lt;double&gt; R = ILMath.sort(A, out I, 1, false);
            //R: 
            // 0.1231  0.1423  0.2991  0.4324  0.9231  
            //I: 
            // 2  3  4  0  1
            </code>
            </example>
            <para>The quicksort algorithm is an unstable algorithm. Therefore, if in the input array some elements have 
            identical values, their relative order in the output vector is not garanteed to be unchanged.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String})">
            <summary>
            Sort strings in A along first non singleton dimension ascending
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Boolean)">
            <summary>
            Sort strings in A along first non singleton dimension
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},System.Int32,System.Boolean)">
            <summary>
            Sort strings in A along dimension 'dim'
            </summary>
            <param name="A">Input array. A may be an empty, scalar, vector or matrix.</param>
            <param name="dim">Dimension to sort along</param>
            <param name="descending">Specifies the direction of sorting: true: descending sort direction; false: ascending</param>
            <returns>Sorted array of the same size/shape as A</returns>
            <remarks><para>The strings in A will be sorted lexicographically in ascending order using the bucket sort algorithm. Data 
            along the first non singleton dimension will get sorted independently from data 
            in the other rows/columns.</para>
            <para>The sorting order of strings is determined char-wise by comparing the ASCII codes of the characters.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.String},ILNumerics.ILOutArray{System.Double},System.Int32,System.Boolean)">
             <summary>
             Sort data in A along dimension 'dim'
             </summary>
             <param name="A">Input array: empty, scalar, vector or matrix</param>
             <param name="descending">Specifies the direction of sorting</param>
             <param name="dim">Dimension to sort along</param>
             <param name="Indices">[Output] Returns permutation matrix also</param>
             <returns>Sorted array of the same size as A</returns>
             <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
             along the dimension <paramref name="dim"/> will get sorted independently from data 
             in the next row/column.</para>
             <para>This overload also returns an array 'Indices' which will hold the indices into the original 
             elements <b>after sorting</b>. Elements of 'Indices' are of type double.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sort``3(ILNumerics.ILInArray{``0},ILNumerics.ILOutArray{``2},System.Int32,System.Boolean,ILNumerics.Algorithms.ILKeyMapper{``0,``1})">
            <summary>
            Generic sort algorithm in A along dimension 'dim' 
            </summary>
            <param name="A">Input array: empty, scalar, vector or matrix</param>
            <param name="descending">Specifies the direction of sorting</param>
            <param name="dim">Dimension to sort along</param>
            <param name="Indices">[Input/Output] The values in Indices will be returned in the same sorted order as the elements 
            in A. This can be used to derive a permutation matrix of the sorting process.</param>
            <typeparam name="T">Element type of values of A</typeparam>
            <typeparam name="S">Subelement type. For element type of string this would be 'char'</typeparam>
            <typeparam name="I">Element type of indices</typeparam>
            <param name="keymapper">Instancce of an object of type ILKeyMapper. This object must 
            be derived from ILKeyMapper&lt;T,SubelementType&gt; and match the generic argument <typeparamref name="T"/>. It will be 
            used to split single elements into its subelements and map their content into bucket numbers. For all 
            reference types except those of type string you will have to write your own ILKeyMapper class for that purpose.</param>
            <returns>Sorted array of the same size as A</returns>
            <remarks><para>The data in A will be sorted using the quick sort algorithm. Data 
            along the dimension <paramref name="dim"/> will therefore get sorted independently from data 
            in the next row/column.</para>
            <para>This overload also returns an array 'Indices' which will hold the indices into the original 
            elements <b>after sorting</b>. Therefore, the unsorted indices must be provided by the user on entry. Indices must not be null.</para>
            <para>This generic version is able to sort arbitrary element types. Even user defined reference types can be sorted 
            by specifying a user defined ILKeyMapper class instance. Also the type of Indices may be arbitrarily choosen. In difference 
            to the regular sort function overload, Indices must manually be given to the function on entry. Elements in 'Indices'
            are sorted in the same order as the elements of A.</para>
            <para>By using this overload you may use the same permutation matrix several times to reflect the 
            manipulations done to A due multiple sort processes. The Indices given will directly be used for the sorting 
            disregarding initial order.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Single})">
            <summary>Square root of array elements - complex output</summary>
            <param name="A">Input array - positive and negative values allowed</param>
            <returns>Square root of elements of A - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrtc(ILNumerics.ILInArray{System.Double})">
            <summary>Square root of array elements - complex output</summary>
            <param name="A">Input array - positive and negative values allowed</param>
            <returns>Square root of elements of A - complex output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Square root of array elements</summary>
            <param name="A">Input array</param>
            <returns>Square root of elements of A </returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Square root of array elements</summary>
            <param name="A">Input array</param>
            <returns>Square root of elements of A </returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Single})">
            <summary>Square root of array elements - real output</summary>
            <param name="A">Input array - only positive values are allowed.</param>
            <returns>Square root of elements of A - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sqrt(ILNumerics.ILInArray{System.Double})">
            <summary>Square root of array elements - real output</summary>
            <param name="A">Input array - only positive values are allowed.</param>
            <returns>Square root of elements of A - real output</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.std(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean,System.Int32)">
            <summary>
            Standard deviation for values in A
            </summary>
            <param name="A">Input array</param>
            <param name="Weights">Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Dimension index of A to operate along, default: first non singleton dimension</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para>The standard deviation is computed by the formula 
            <c>std = sqrt(var(A,...))</c>. For further details on given parameters, see 
            <see cref="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{T},ILNumerics.ILInArray{T},bool,false);"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.std(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean,System.Int32)">
            <summary>
            Standard deviation for values in A
            </summary>
            <param name="A">Input array</param>
            <param name="Weights">Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Dimension index of A to operate along, default: first non singleton dimension</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para>The standard deviation is computed by the formula 
            <c>std = sqrt(var(A,...))</c>. For further details on given parameters, see 
            <see cref="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{T},ILNumerics.ILInArray{T},bool,false);"/>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.sub2ind(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Convert subscript indices to sequential index
            </summary>
            <param name="A">Input array</param>
            <param name="subscripts">Subscripts</param>
            <returns>Sequential index for subscript indices</returns>
            <remarks>The function returns the sequential index i into A referencing the same element as would be referenced by the subscript indices.</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.subtract(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Subtract arrays elementwise</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>New array with result of subtraction</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the 
            other array.</para>
            <para>If A or B is a colum vector and the other parameter is an array with a matching colum length, the vector is used to operate on all columns of the array. 
            Similar, if one parameter is a row vector, it is used to operate along the rows of the other array if its number of columns matches the vector length. This feature 
            can be used to replace the (costly) repmat function for most binary operators.</para>
            <para>For all other cases the dimensions of A and B must match.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the size of both arrays does not match any parameter rule.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Double})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{System.Single})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sumall(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Sum all elements of array A 
            </summary>
            <param name="A">Input array</param>
            <returns><para>Scalar sum of all elements of A.</para>
            <para>If A is empty, an empty array will be returned.</para></returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A was null.</exception>
            <seealso cref="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)"/>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.sum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements of A along specified dimension
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Array, same size as A, but having the 'dim's dimension 
            reduced to the length 1 with the sum of all
            elements along that dimension.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix A</param>
            <returns>Vector with min(M,N) singular values of A as column vector</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="U">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean)">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value (e.g. 'empty') signals the need of returning those values.</param>
            <param name="small">If true: return only first min(M,N) columns of outU will be 
            of size [min(M,N),min(M,N)]</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex})">
            <summary>
            Singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix U. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix V.
            This parameter must not be null. It might be an empty array on input.</param>
            <returns>Singluar values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{System.Single},ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Single},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},ILNumerics.ILOutArray{ILNumerics.fcomplex},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.svd(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},ILNumerics.ILOutArray{ILNumerics.complex},System.Boolean,System.Boolean)">
            <summary>
            singular value decomposition 
            </summary>
            <param name="A">Input matrix</param>
            <param name="outU">[Output] Left singular vectors of A as columns of matrix outU. 
            Setting this parameter to a non-null value signals the need of returning those values.</param>
            <param name="outV">[Output] Right singular vectors of X as rows of matrix outV.
            This parameter must not be null. It might be an empty array on input.</param>
            <param name="small">If true: return only first min(M,N) columns of outU and S (returned) will be 
            of size [min(M,N),min(M,N)]</param>
            <param name="discardFiniteTest">If true: the matrix given will not be checked for infinte or NaN values. If such elements 
            exist nevertheless, this may result in failing convergence or error. In worst case 
            the function may hang inside the Lapack lib! Use with care! </param>
            <returns>Singular values as diagonal matrix of same size and type as A</returns>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Single})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tan(ILNumerics.ILInArray{System.Double})">
            <summary>Tangens of array elements</summary>
            <param name="A">Input array</param>
            <returns>Tangens of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Single})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.tanh(ILNumerics.ILInArray{System.Double})">
            <summary>Hyperbolic tangent of array elements</summary>
            <param name="A">Input array</param>
            <returns>Hyperbolic tangent of array elements</returns>
            <remarks><para>If the input array is empty, an empty array will be returned.</para>
            <para>The array returned will be a dense array.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Double})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int64})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Single})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.trace(ILNumerics.ILInArray{System.Byte})">
            <summary>
            Trace of matrix
            </summary>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Scalar of same type as A with the sum of diagonal elements of A.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.triu``1(ILNumerics.ILInArray{``0})">
            <summary>
            Upper triangular part of matrix
            </summary>
            <typeparam name="T">Inner type of matrix</typeparam>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Array of size [m x n], holding upper triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.tril``1(ILNumerics.ILInArray{``0})">
            <summary>
            Lower triangular part of matrix
            </summary>
            <typeparam name="T">Inner type of matrix</typeparam>
            <param name="A">Input matrix, size [m x n]</param>
            <returns>Array of size [m x n], holding lower triangular part of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If A has more than 2 dimensions.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},System.Boolean,System.Int32)">
            <summary>
            Variance along dimension of A
            </summary>
            <param name="A">Input array A</param>
            <param name="Weights">[Optional] Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para> The result for <paramref name="biased"/> = true is computed by the following formula: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / A.D[dim];</code>
            If <paramref name="biased"/> is false (default) the normalization is done with the length of the working dimension of A as follows: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / (A.D[dim] - 1); </code>
            If <paramref name="Weights"/> is given, the parameter <paramref name="biased"/> is ignored.</para>
            <para>If <paramref name="Weights"/> is given, the normalization is applied to r as follows: 
            <code>w = w / sum(w); 
            r = A - sum(w * A);
            var = sum(w * (r * r)); 
            </code></para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.var(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},System.Boolean,System.Int32)">
            <summary>
            Variance along dimension of A
            </summary>
            <param name="A">Input array A</param>
            <param name="Weights">[Optional] Vector of scaling factors, same length as working dimension of A, default: no scaling</param>
            <param name="biased">[Optional] true: apply biased normalization to result, default: false (non-biased)</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Variances</returns>
            <remarks><para>On scalar A a scalar 0 of the same shape as A is returned.</para>
            <para>On empty A an empty array is returned, having the dimension to operate along reduced to length 1.</para>
            <para>The parameters <paramref name="Weights"/>, <paramref name="biased"/> and <paramref name="dim"/> are optional. 
            Ommiting either one will choose its respective default value.</para>
            <para> The result for <paramref name="biased"/> = true is computed by the following formula: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / A.D[dim];</code>
            If <paramref name="biased"/> is false (default) the normalization is done with the length of the working dimension of A as follows: 
            <code>r = (A - mean(A)); 
            var = sum(r * r) / (A.D[dim] - 1); </code>
            If <paramref name="Weights"/> is given, the parameter <paramref name="biased"/> is ignored.</para>
            <para>If <paramref name="Weights"/> is given, the normalization is applied to r as follows: 
            <code>w = w / sum(w); 
            r = A - sum(w * A);
            var = sum(w * (r * r)); 
            </code></para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.vec(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regulary spaced vector
            </summary>
            <param name="start">Start value</param>
            <param name="end">End value</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with interval 1. The last element 
            of the returned vector will be less than or equal to end, if start <![CDATA[<]]> end.</returns>
            <remarks>This is the same as vector (start,1,end).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If start <![CDATA[>]]> end</exception>
        </member>
        <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regularly spaced vector, spacing 1
            </summary>
            <param name="start">Start value</param>
            <param name="end">End value</param>
            <returns>Row vector of size 1xN, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 1. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vec``1(ILNumerics.ILBaseArray,ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)">
            <summary>
            Regulary spaced column vector
            </summary>
            <param name="start">Start value</param>
            <param name="step">Step size</param>
            <param name="end">End value</param>
            <returns>Column vector of length N, where N is the number of elements 
            between start and end, all equally spaced with stepsize of 'step'. The last element 
            of the returned vector will be less than or equal to end, if start &lt; end. If start 
            &gt; end, the elements in the vector will linearly decrease from 
            start to end. In this case, step must be negative.</returns>
            <remarks><para>The shape of the vector created is controlled by the setting switch <see cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>.
            This setting defaults to 'false' which will cause the creation of a column vector. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Double}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.fcomplex}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{ILNumerics.complex}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Byte}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int64}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Int32}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat(ILNumerics.ILInArray{System.Single}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other (along dimension 0).
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.vertcat``1(ILNumerics.ILInArray{``0}[])">
            <summary>
            Vertical array concatenation 
            </summary>
            <param name="arrays">Arrays to be concatenated with each other. All
            arrays must be of the same inner type. The dimensions of all arrays 
            must match - except for the first dimension (index 0).</param>
            <returns>Larger array having all arrays in 'arrays' placed beneath each other.
            </returns>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int64},ILNumerics.ILInArray{System.Int64})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.fcomplex},ILNumerics.ILInArray{ILNumerics.fcomplex})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{ILNumerics.complex},ILNumerics.ILInArray{ILNumerics.complex})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Byte},ILNumerics.ILInArray{System.Byte})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.xor(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>Elementwise logical 'xor' operator</summary>
            <param name="A">Input array A</param>
            <param name="B">Input array B</param>
            <returns>Logical array with the elementwise result of logical 'xor' for all elements in A and B</returns>
            <remarks><para>On empty input an empty array will be returned.</para>
            <para>A and/or B may be scalar. The scalar value will be applied on all elements of the other array.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILDimensionMismatchException">If neither A nor B is scalar or empty, the dimensions of both arrays must match.</exception>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(System.Int32[])">
            <summary>
            Create double array with all elements initialized to 0
            </summary>
            <param name="size">Size description</param>
            <returns>Zeros-filled array.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(ILNumerics.ILSize)">
            <summary>
            Create double array with all elements initialized to 0
            </summary>
            <param name="size">Size descriptor</param>
            <returns>Zeros-filled array.</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)">
            <summary>
            Create array with all elements initialized to default(T)
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="size">Size descriptor</param>
            <returns>New array, initialized to default(T)</returns>
        </member>
        <member name="M:ILNumerics.ILMath.zeros``1(System.Int32[])">
            <summary>
            Create new array of arbitrary element type, initialized to '0'
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="size">Size description</param>
            <returns>New array having the size determined by 'dims', initialized to '0'</returns>
            <remarks>For T deriving from Sytem.ValueType elements will be '0'. All other element types
            will be initialized to default(T).</remarks>
        </member>
        <member name="M:ILNumerics.ILMath.zeros(ILNumerics.NumericType,ILNumerics.ILSize)">
            <summary>
            Create array initialized with all elements set to zero
            </summary>
            <param name="type">Numeric type specification. One value out of the types listed in the <see cred="ILNumerics.NumericType"/>
            enum.</param>
            <param name="size">Size descriptor</param>
            <returns>Array of inner type corresponding to <paramref name="type"/> argument.</returns>
            <remarks>The array returned may be casted to the appropriate actual type afterwards. 
            <para>
            <list type="number"> 
            <listheader>The following types are supported: </listheader>
            <item>Double</item>
            <item>Single</item>
            <item>Complex</item>
            <item>FComplex</item>
            <item>Byte</item>
            <item>Int32</item>
            <item>Int64</item>
            </list>
            </para>
            <para>This function is provided for downward compatibility reasons only and will be removed in a future update. It is recommended to use the <see cref="M:ILNumerics.ILMath.zeros``1(ILNumerics.ILSize)"/> or <see cref="M:ILNumerics.ILMath.zeros``1(System.Int32[])"/> overloads instead.</para>
            <para>The interface of this function does not confirm to the rules of functions in ILNumerics. Therefore, in order to prevent for potential memory issues, the return value should be converted to 
            a concrete array type explicitely: </para>
            <example>
            <code>
            ILArray&lt;double&gt; A = todouble(zeros(NumericType.double, size(10,20))); 
            
            // better and easier would be: 
            ILArray&lt;double&gt; B = zeros&lt;double&gt;(10,20); 
            </code>
            </example>
            </remarks>
        </member>
        <member name="F:ILNumerics.ILMath.Lapack">
            <summary>
            Concrete interface wrapper class providing the native LAPACK functions
            </summary>
            <remarks>The LAPACK wrapper will be initialized the first time, 
            a call to any static method of ILMath is made. The decision, which 
            native module to load is done by use of native CPUID assembly statements.
            If the current processor does not support those calls or is not recognizable
            by ILNumerics, a generic - not optimized - version of native LAPACK code will
            be used than.</remarks>
        </member>
        <member name="F:ILNumerics.ILMath.FFTImplementation">
            <summary>
            Platform specific FFT implementation, <b>internally</b> used to compute fft 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.#cctor">
            <summary>
            Main math class providing static builtin functions
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.ILAtlasMinimumElementSize">
            <summary>
            Minimal size of dimensions, expensive operations will be carried out by native LAPACK libs. 
            </summary>
            <remarks>This property is not yet implemented. All computations (unless for scalars) will be using LAPACK.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Int64},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Int32},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Byte},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.median(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Calculate median along the specified dimension
            </summary>
            <param name="A">Input Array</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the median of 
            all elements along that dimension.</para>
            <param name="dim">[Optional] Index of dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <para>The result will have the same number of dimensions as A, but the specified dimension will have the 
            size 1.</para><para>If the specified dimension of A is empty, the median along that dimension will be NaN and that dimension will be 1.</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nanmean(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Mean of array along specified dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to work along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Mean of non-NaN elements along specified dimension</returns>
            <remarks><para>The return array has the same shape as A, but the selected dimension is reduced 
            to length 1. If A is scalar, an scalar array will be returned. On empty input, the output will be empty.
            </para><para>If A contains an all NaN vector along the specified dimension the resulting value will by NaN
            (as the nansum of these elements is 0 divided by 0 elements)</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{System.Double},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{System.Single},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.nansum(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            Sum elements along first non singleton dimension ignoring NaN values
            </summary>
            <param name="A">Input array</param>
            <param name="dim">[Optional] Index of the dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns>Sum of elements along specified of first non singleton dimension, ignoring nan values</returns>
            <remarks><para>The array returned will have the same size as <paramref name="A"/>, with the specified or first non singleton dimension 
            reduced to the length 1. It will contain the sum of all elements along that dimension after removing NaN values respectively. </para>
            <para>If A contains an all NaN vector along <paramref name="dim"/> , 
            the resulting sum will be 0 - not NaN! This corresponds to the sum of an empty vector.</para></remarks> 
        </member>
        <member name="M:ILNumerics.ILMath.nansum_internal(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Boolean)">
            <summary>
            Depending on settings, calculate nansum or nanmean
            </summary>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Double},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Int64},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Int32},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Byte},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{System.Single},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.select(ILNumerics.ILInArray{ILNumerics.complex},System.Int32,System.Int32)">
            <summary>
            Select the k-th smallest element from an array along a specific dimension
            </summary>
            <param name="A">Input array</param>
            <param name="k">The element to find. If k is smaller 1 or larger than the number of elements in list, the smallest/largest value will be returned.</param>
            <param name="dim">[Optional] Dimension to operate along. If omitted operates along the first non singleton dimension (i.e. != 1).</param>
            <returns><para>Array having the specified dimension reduced to the length 1 with the value of the k-the smallest element along that dimension.</para>
            <para>Exception: If the selected dimension is of size 0 it will remain 0 (an empty set).</para></returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Double[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Int64[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Int32[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(System.Single[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="M:ILNumerics.ILMath.quickselect_worker(ILNumerics.complex[],System.Int32,System.Int32,System.Int32,System.Int32@)">
            <summary>
            Quick select algorithm: Find the k-th smallest element in list.
            Will change the list parameter!
            </summary>
            <remarks><para>Elements in the array list will be reordered. Make sure to pass a copy if you intend to use that data later</para></remarks>
            <param name="list">The list to search in</param>
            <param name="left">The first index in the list to start the search</param>
            <param name="right">The last index in the list to end the search</param>
            <param name="k">The k-th smallest element to find in list[left:right]. If k is smaller than 1 or larger than the number of elements the smallest/largest value will be returned.</param>
            <param name="position">Returns the index in list where the smallest element was found</param>
            <returns>The k-th smallest element</returns>
        </member>
        <member name="P:ILNumerics.ILMath.end">
            <summary>
            Substitute for the index of the last element of a dimension
            </summary>
            <remarks>The 'end' placeholder can be used in subarray specification expressions. It will get 
            evaluated in a delayed manner, once the index of the dimension (and therefore the dimension length)
            is known. It than evaluates to the number of the index of the last element in the dimension.
            </remarks>
        </member>
        <member name="P:ILNumerics.ILMath.eps">
            <summary>
            Double precision epsilon - the smallest difference from 1.0
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.epsf">
            <summary>
            Single precision epsilon - the smalles difference from 1.0f
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.MachineParameterDouble">
            <summary>
            Give extensive numerical machine parameter informations - double precision
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.MachineParameterSingle">
            <summary>
            Give extensive numerical machine parameter informations - single precision
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.full">
            <summary>
            Address the whole dimension for subarray access
            </summary>
        </member>
        <member name="P:ILNumerics.ILMath.RandomGenerator">
            <summary>
            Random number generator used for any generation of random numbers.
            </summary>
            <remarks>This property is thread safe (by using the [ThreadStatic] attribute).</remarks>
        </member>
        <member name="T:ILNumerics.ILMath.EMInitializationMethod">
            <summary>
            Determine method of center initialization for EM algorithm
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.KMeans_random">
            <summary>
            Use the kmeans algorithm, choose random samples as centers for start 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.KMeans_firstK">
            <summary>
            Use the kmeans algorithm, choose first k samples as centers for start 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.EMInitializationMethod.User">
            <summary>
            Provide custom centers in the 'InitCenter' argument
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.KRRTypes">
            <summary>
            Type definitions for possible kernels in kernel ridge regression
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.linear">
            <summary>
            Linear kernel <c>k(x,y) = x'*y</c>
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.polynomial">
            <summary>
            Polynominal kernel <c>k(x,y) = (x'*y + c)^d</c>
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.KRRTypes.gaussian">
            <summary>
            Gaussian (exponential) kernel <c>k(x,y) = exp(-norm(x-y)/sigma)</c>
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.ILKRRResult">
            <summary>
            Encapsulates the result of a kernel ridge regression and makes it applicable to new data
            </summary>
        </member>
        <member name="T:ILNumerics.ILResult`1">
            <summary>
            Result datatype, used for storing computational results and applying them to new data within ILNumerics machine learning functions
            </summary>
            <typeparam name="T">Datatype of underlying array elements</typeparam>
        </member>
        <member name="M:ILNumerics.ILResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning</param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.ILMath.ILRidgeRegressionResult`1">
            <summary>
            This class stores the result of a ridge regression
            </summary>
            <typeparam name="T">Element type (precision) for the result</typeparam>
            <remarks>This class is returned from <see cref="M:ILNumerics.ILMath.ridge_regression(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double},ILNumerics.ILBaseArray,ILNumerics.ILBaseArray)"/>
            and all its overloads. The class stores all data needed to apply the regression result to new data points. Therefore a 
            function <see cref="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])"/> is provided.
            <para>The class implements the <c>IDisposable</c> interface and should be used inside a 'using' block or manually be disposed 
            after use.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Apply(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Apply the result on new datapoints
            </summary>
            <param name="X">New datapoints, same dimension as used for learning</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.ILMath.ILRidgeRegressionResult`1.Dispose">
            <summary>
            Dispose off the result and free all storages used 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.VAN">
            <summary>
            vector op. array - not in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.VAI">
            <summary>
            vector op. arra - in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.AVN">
            <summary>
            array op. vector - not in-place
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.BinOptItExMode.AVI">
            <summary>
            array op. vector - in-place
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.GenEigenType">
            <summary>
            Specifies the type of eigenproblem 
            </summary>
            <remarks>The enumeration describes possible problem definitions for generelized eigenproblems:
            <list type="bullet">
            <item>Ax_eq_lambBx: A*V = r*B*V</item>
            <item>ABx_eq_lambx: A*B*V = r*V</item>
            <item>BAx_eq_lambx: B*A*V = r*V</item>
            </list></remarks>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.Ax_eq_lambBx">
            <summary>
            A*V = r*B*V
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.ABx_eq_lambx">
            <summary>
            A*B*V = r*V
            </summary>
        </member>
        <member name="F:ILNumerics.ILMath.GenEigenType.BAx_eq_lambx">
            <summary>
            B*A*V = r*V
            </summary>
        </member>
        <member name="T:ILNumerics.ILMath.precisionHelper`1">
            <summary>
            Prevent JIT "optimizations" - force single precision to be applied
            </summary>
            <typeparam name="T">mainly float here</typeparam>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort">
            <summary>
            Bucket sort algorithm (for internal use)
            </summary>
            <remarks>This class is not intended to be used directly. Sorting functionality is supplied by <see cref="M:ILNumerics.ILMath.sort(ILNumerics.ILInArray{System.Double})"/></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILBucketSort.BucketSort``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``2},ILNumerics.Algorithms.ILKeyMapper{``0,``1},ILNumerics.Algorithms.ILBucketSort.SortMethod)">
            <summary>
            Bucket sort algorithm 
            </summary>
            <param name="input"></param>
            <param name="indices">Return corresponding source element indices</param>
            <param name="mapper"></param>
            <param name="method"></param>
        </member>
        <member name="T:ILNumerics.Algorithms.ILBucketSort.SortMethod">
            <summary>
            Sort method for bucket sorts
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.ConstantLength">
            <summary>
            Constant length
            </summary>
        </member>
        <member name="F:ILNumerics.Algorithms.ILBucketSort.SortMethod.VariableLenth">
            <summary>
            Variable length
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILKeyMapper`2">
            <summary>
            Key mapper class, to be overriden for user defined classes to be sorted with bucket sort
            </summary>
            <typeparam name="ElementType">Type of elements. Elements are constructed out of any number of subelements</typeparam>
            <typeparam name="SubelementType">Type of subelements</typeparam>
            <remarks>This class can be extended to enable sorting (bucket sort) for arbitrary types. The elements of those types may be devidable into subelements.
            <para>Examples of sortable classes:
            <list>
            <item>colors: number/type of subelements: 1/any (e.g. the color code). One should write a <![CDATA[ILKeyMapper<Color,int>]]>.</item>
            <item>strings: number/type of subelements: arbitrary/char. Here a sample ILASCIKeyMapper implementation exists already. This implementation is the default implementation used for bucket sort via ILMath.sort().</item>
            <item>trees: number/type of subelements: arbitrary/tree nodes. One should write a key mapper to map a node of a tree to a bucket number</item>
            <item>...</item></list></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`1)">
            <summary>
            Maps subelement types to bucket index
            </summary>
            <param name="inSubelement">Item</param>
            <returns>Bucket index</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.Map(`0,System.Int32,System.Int32)">
            <summary>
            Map subelemt - provide fallback on error
            </summary>
            <param name="element">Element item</param>
            <param name="position">Position of subelement in element item to be mapped</param>
            <param name="fallback">If position is out of range, give back fallback</param>
            <returns>Mapped bucket for subelement or fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.SubelementsCount(`0)">
            <summary>
            Count subelements in an element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.GetSubelement(`0,System.Int32)">
            <summary>
            Get subelement from element item
            </summary>
            <param name="element">Element item</param>
            <param name="idx">Position of subitem in element</param>
            <returns>Subitem referenced</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILKeyMapper`2.#ctor(System.Int32)">
            <summary>
            Construct key mapper
            </summary>
            <param name="NumberOfKeys">Maximm number of different subitems (keys)</param>
        </member>
        <member name="P:ILNumerics.Algorithms.ILKeyMapper`2.NumberOfKeys">
            <summary>
            Maximum number of keys (different subitems)
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILASCIIKeyMapper">
            <summary>
            Concrete implementation of a key mapper for strings
            </summary>
            <remarks>this class is the default key mapper, used for bucket sort on strings</remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.Char)">
            <summary>
            map subelement to bucket 
            </summary>
            <param name="inSubelement">subelement to be mapped</param>
            <returns>ASCII code of the subelement character</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.Map(System.String,System.Int32,System.Int32)">
            <summary>
            Map char out of string with fallback
            </summary>
            <param name="element">full string item</param>
            <param name="position">position of character in string</param>
            <param name="fallback">fallback bucket number, if position is out of range</param>
            <returns>ASCII code for character specified, fallback on error</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.GetSubelement(System.String,System.Int32)">
            <summary>
            give one char from string
            </summary>
            <param name="element">full string item</param>
            <param name="idx">character position in string</param>
            <returns>character in string</returns>
            <exception cref="T:System.IndexOutOfRangeException"> if idx is not within element ranges</exception>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.SubelementsCount(System.String)">
            <summary>
            Count numer of characters in string
            </summary>
            <param name="element">element item</param>
            <returns>number of characters in string - length of string</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILASCIIKeyMapper.#ctor">
            <summary>
            construct ASCII key mapper for 256 buckets
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILIntLimitedKeyMapper">
            <summary>
            Integer key mapper - sample implementation for bucket sort
            </summary>
            <remarks>This mapper may be used for sorting integers with bucketsort. 
            <para>The integers to be sorted must be positive and limited. It corresponds to the number of buckets to be created.</para>
            <para>This implementation serves as a sample implementation for bucket sort. You should consider using quicksort instead, which is implemented for ILMath.sort()</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.GetSubelement(System.Int32,System.Int32)">
            <summary>
            Gives subelement - i.e. the element itself
            </summary>
            <param name="element">element</param>
            <param name="idx">(ignored)</param>
            <returns>element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32,System.Int32,System.Int32)">
            <summary>
            map element - ignoring position &amp; fallback
            </summary>
            <param name="element">integer element</param>
            <param name="position">(ignored)</param>
            <param name="fallback">(ignored)</param>
            <returns>integer element</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.Map(System.Int32)">
            <summary>
            map (copy) subelement
            </summary>
            <param name="inSubelement">subelement</param>
            <returns>subelement</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.SubelementsCount(System.Int32)">
            <summary>
            number of subelements in an element (Here: always 1)
            </summary>
            <param name="element">element</param>
            <returns>1</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILIntLimitedKeyMapper.#ctor(System.Int32)">
            <summary>
            construct integer key mapper
            </summary>
            <param name="limit">maximum number of buckets to be used</param>
        </member>
        <member name="T:ILNumerics.Misc.ILListItem`2">
            <summary>
            List items to be used in ILQueueList
            </summary>
            <typeparam name="T1">Data type</typeparam>
            <typeparam name="T2">Index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0)">
            <summary>
            construct list item by data
            </summary>
            <param name="item">item data</param>
            <remarks>the indet will be set to its default value</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILListItem`2.#ctor(`0,`1)">
            <summary>
            construct list item, takes item data and index
            </summary>
            <param name="item">item data</param>
            <param name="index">index</param>
        </member>
        <member name="P:ILNumerics.Misc.ILListItem`2.Index">
            <summary>
            index stored with this item
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILQueueList`2">
            <summary>
            Queuelist - a queue with partial list properties 
            </summary>
            <typeparam name="T1">data type</typeparam>
            <typeparam name="T2">index type</typeparam>
            <remarks>This class is not intended to be used directly. Internally it serves as a helper class for sorting.</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0,`1)">
            <summary>
            add indexed item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(`0)">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILListItem{`0,`1})">
            <summary>
            add item at end of queue
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Enqueue(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            add queue list to end of this queue list
            </summary>
            <param name="list">queue list to be added</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Dequeue">
            <summary>
            Remove from start of queue
            </summary>
            <returns>item from start of queue</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(`0)">
            <summary>
            Add to start of queue
            </summary>
            <param name="item">item data to add to start of queue</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.AddToStart(ILNumerics.Misc.ILQueueList{`0,`1})">
            <summary>
            concatenate 2 queuelists
            </summary>
            <param name="qlist">queue list to be added at start of this queuelist</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Sort``1(ILNumerics.Algorithms.ILKeyMapper{`0,``0})">
            <summary>
            sort utilizing bucket sort
            </summary>
            <typeparam name="SubelementType">subelement type</typeparam>
            <param name="mapper">keymapper mapping subelement items to buckets</param>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.ToArray">
            <summary>
            convert (copy) items to system array
            </summary>
            <returns>system array with items</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.Clear">
            <summary>
            Clear this queue list from all elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.GetEnumerator">
            <summary>
            Create enumerator utilizing 'foreach'
            </summary>
            <returns>enumerator for contained elements</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILQueueList`2.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            gives enumerator for internal list items (ILListItem)
            </summary>
            <returns>ILListItem's</returns>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.Count">
            <summary>
            number of items currentliy in the queue (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILQueueList`2.ListItems">
            <summary>
            Gives enumerator for contained items (ILListItem)
            </summary>
        </member>
        <member name="T:ILNumerics.Algorithms.ILQuickSort">
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
            <summary>
            the class provides a number of one dimensional quicksort implementations for several datatypes/ properties
            </summary>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscST(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescST(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXST(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MminimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXST(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline 1 dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks><para>Quick sort algorithm is used for ranges of minimum lengths specified by 
            <see cref="P:ILNumerics.Settings.MinimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Double[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.UInt64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.UInt64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.UInt32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.UInt32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.UInt16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.UInt16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Int64[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Int64[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Int32[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Int32[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Int16[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Int16[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Single[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Single[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(ILNumerics.fcomplex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(ILNumerics.fcomplex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(ILNumerics.complex[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(ILNumerics.complex[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Char[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Char[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100. The stack array
            is cached internally.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescMT(System.Byte[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, multithreaded
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>        
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory defaults to length 100.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortAscIDXMT(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, ascending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.QuickSortDescIDXMT(System.Byte[],System.Double[],System.Int32,System.Int32,System.Int32)">
            <summary>
            inline one dimensional quick sort, descending, arbitrary element spacing, indices aware
            </summary>
            <param name="vecP">data array, 1dim, replaced on output with sorted values</param>
            <param name="lo">lowest index of sorting range</param>
            <param name="hi">highest index of sorting range</param>
            <param name="idxP">indices vector, content will in-place be sorted along with <paramref name="vecP"/></param>
            <param name="inc">spacing between elements (dimension specifier)</param>
            <remarks>
            <para>This function provides a low level in-place implementation of the quicksort algorithm. It is used by the 
            higher level sorting API provided by <see cref="M:ILNumerics.ILMath.sort"/>. It is recommended to use the overloads 
            of <see cref="M:ILNumerics.ILMath.sort()"/> instead of this function. That way, the decision, which lower level function
            is to be called is made by the library automatically.</para>
            <para>A quicksort algorithm is used for ranges of minimum lengths specified by 
            <see cref="F:ILNumerics.Settings.s_minimumQuicksortLength"/> and above. 
            Below that length, a simple insertion sort is used instead.</para>
            <para>The algorithm implements a non-recursive quicksort variant. Therefore a small amount of 
            memory is needed to perform the sorting. That 'stack' memory is preserved from the ILMemoryPool. 
            The size is determined by the value of 
            <see cref="F:ILNumerics.Settings.s_maxSafeQuicksortRecursionDepth"/>.</para>
            <para><b>Handling of NaN values (for double,float,complex or fcomplex arrays element datatypes only):</b> 
            if the input array contains any NaN values, those elements will be sorted to the end of the array on output.</para>
            <para>This function internally parallelizes the sorting in a very efficient manner. It usually outperforms 
            non-parallelized versions of the quicksort algorithm for larger arrays. For smaller arrays, it may be more 
            efficient, to use the non parallelized version instead: <see cref="M:ILNumerics.ILMath.QuickSortAsc(double[], int, int, int)"/></para></remarks>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Double*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Double*,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Double*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Double*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Double*,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,System.Single*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Double*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Double*,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.fcomplex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXAsc(System.Int32,System.Int32@,System.Int32,System.Double*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNIDXDesc(System.Int32,System.Int32@,System.Int32,System.Double*,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNAsc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="M:ILNumerics.Algorithms.ILQuickSort.checkNaNDesc(System.Int32,System.Int32@,System.Int32,ILNumerics.complex*)">
            <summary>
            sort nan elements to the end, test if the array is already sorted
            </summary>
            <returns>true, if already sorted</returns>
        </member>
        <member name="T:ILNumerics.ILSpecialData">
            <summary>
            A helper class that can be used to generate various simple yet non-trivial test data sets
            </summary>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sinc(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32)">
            <summary>
            Generate sinc function in 2D, single precision, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
            <remarks>The function generates 4 zero crossings in each direction</remarks>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincf(System.Int32,System.Int32,System.Single)">
            <summary>
            Generate sinc function in 2D, useful for plotting examples
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <param name="periods">Influences the number of periods to be drawn in both directions. 1 will result in 4 zero crossings, higher values result in more, lower values in less zero crossings.</param>
            <returns>Matrix with sinc data in 2 dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincos1D(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sincos1Df(System.Int32,System.Double)">
            <summary>
            Create specified periods of sine and cosine data, single precision
            </summary>
            <param name="numSamples">Number of samples</param>
            <param name="periods">Number of (full) periods to be generated, must be &gt; 0</param>
            <returns>Matrix with sine data in first column, cosine data in second column</returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.waterfall(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.waterfallf(System.Int32,System.Int32)">
            <summary>
            Create demo data for surface plots looking like a waterfall
            </summary>
            <param name="rows">Number of rows</param>
            <param name="cols">Number of columns</param>
            <returns>Matrix with data showing a waterfall terrain. </returns>
        </member>
        <member name="M:ILNumerics.ILSpecialData.sphere(System.Int32,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create surface data of a sphere
            </summary>
            <param name="n">Number of facettes per angle</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
        </member>
        <member name="M:ILNumerics.ILSpecialData.moebius(System.Int32,System.Double,System.Double,ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double},ILNumerics.ILOutArray{System.Double})">
            <summary>
            Create surface data for a M旦bius strip 
            </summary>
            <param name="n">Granularity (number of facettes)</param>
            <param name="w">Width</param>
            <param name="R">Radius</param>
            <param name="X">[Output] X coords</param>
            <param name="Y">[Output] Y coords</param>
            <param name="Z">[Output] Z coords</param>
            <remarks>M旦bius strip is a surfcae, crated by cutting a regular strip, twisting one end by 180 deg and glueing 
            both ends together again.</remarks>
        </member>
        <member name="T:ILNumerics.ILArray`1">
             <summary>
             The main rectangular array to be used in algorithms 
             </summary>
             <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
             complex floating point type.</typeparam>
             <remarks>This class serves as the main rectangular array, holding arbitrary elements (usually numeric types) 
             in arbitrary dimensions.
             <para>Arrays of this type may use any type as generic element. However, common mathematical functions and operators 
             are defined for a limited number of inner types only. All binary operations (+,-,*,/,<![CDATA[<,>,<=]]>,etc.) are 
             defined for two arrays with the same <i>numeric type</i>, would it be from the <c>System</c> namespace (<c>double</c>, 
             <c>int</c>,...) or <c>ILNumerics.complex</c>/ <c>ILNumerics.fcomplex</c>. Most algebraic functions require floating point 
             types. See the <see cref="T:ILNumerics.ILMath"/> class for a list of all computational functions.</para>
             <para>Arrays are capable of creating flexible <a href="http://ilnumerics.net/$Subarray0.html" target="ILMain">subarrays</a> 
             and to get altered at runtime. Read about all details of ILNumerics arrays in the 
             <a href="http://ilnumerics.net/$Arrays.html" target="ILMain">ILNumerics Array documentation</a>.</para>
             <para>Arrays of this type are dense arrays. Cloning arrays is done as lazy 
             copy on write, i.e. clones do only use new memory, if attempting to write on them. Arrays integrate into the memory 
             management of ILNumerics. Read about the most <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">important 
             simple rules</a>, for using arrays in custom computational functions.</para>
             <para>Arrays come with overloaded mathematical operators, allowing for a convenient syntax. A 
             sophisticated memory management in the back will make sure, that as little memory as needed is used, even in 
             expressions like: a + c * 2 / abs(sin(c) * -b / log(a)). Here all arrays are of the same size. Evaluating 
             this expression does only need the memory of twice the size of one array. Memory gets collected and reused 
             for every subexpression evaluation. Further optimization options exist, as described in 
             <a href="http://ilnumerics.net/$PerfMemoryOpt.html" target="ILMain">Optimizing Algorithm Performance</a>.</para>
             </remarks>
             <example><para>A simple example demonstrating some uses of arrays in a very simple application:</para>
             <code>using System;
            using System.Collections.Generic;
            using System.Linq;
            using System.Text;
            using ILNumerics; 
            
            
            namespace ConsoleApplication1 {
                class Program : ILMath {
                    static void Main(string[] args) {
                        ILArray&lt;double&gt; A = rand(10,20);
                        ILArray&lt;double&gt; B = A * 30 + 100; 
                        ILLogical C = any(multiply(B,B.T)); 
                        Console.Out.Write(-B); 
                        Console.ReadKey(); 
                    }
                }
            }
            </code>
             </example>
             <seealso cref="T:ILNumerics.ILLogical"/>
             <seealso cref="T:ILNumerics.ILCell"/>
        </member>
        <member name="T:ILNumerics.ILBaseArray`1">
            <summary>
            Typed base class for all ILNumerics data storage classes for any storage type. 
            </summary>
            <remarks><para>You should not use this type directly. It serves as a base class 
            for all typed storages only and will be used by derived classes like ILArray<![CDATA[<>]]>.</para>
            <para>If you are looking for an (untyped) base class to be used as generic class for any ILArray types, you should use ILBaseArray instead!</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILBaseArray">
            <summary>
            Base type for all arrays in ILNumerics
            </summary>
            <remarks>All numerical arrays derive from ILBaseArray. ILBaseArrays itself 
            cannot be instantiated. Currently, only ILArray<![CDATA[<>]]> exist, which describe 
            a rectangular array as full (solid) or referencing array. There are plans to 
            extend the collection of derived types to encompass triangular, diagonal and sparse arrays. 
            </remarks>
        </member>
        <member name="F:ILNumerics.ILBaseArray.m_name">
            <summary>
            Name of this array
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(a) to <c>ILRetArray&lt;typeof(A)&gt;</c>
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> and size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.complex)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(ILNumerics.fcomplex)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.String)~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="s">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="s"/> and size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.op_Implicit(System.Double[])~ILNumerics.ILBaseArray">
            <summary>
            Implicit cast from scalar of typeof(A) to ILRetArray&lt;typeof(A)&gt;
            </summary>
            <param name="a">Input scalar</param>
            <returns>A ILRetArray of same type as <paramref name="a"/> ans size 1x1</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>'Equals' accepts two vectors even if the orientations do not match. Therefore, a row vector 
            with the same element values than another column vector would be considered equal to each other.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is created by taking the values currently stored in the array into account.
            Therefore, the function iterates over all elements in the array - which makes it somehow an expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Clone">
            <summary>
            Clone this array (shallow) 
            </summary>
            <returns>ILBaseArray as new representation of this storages data.</returns>
            <remarks>The object returned will be of the same size than this array.
            This this is a 'shallow' copy only! I.e., if elements are copied only. If they are 
            references to any objects, those objects are not replicated.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Print values of this instance to a stream. 
            </summary>
            <param name="outStream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way 
            the values will be serialized.</param>
            <remarks><para>If method 'Formatted' is used, any occurences of NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style for the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as 
            the array name for writing. This array instance will be the only array in the mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToString">
            <summary>
            Convert to string
            </summary>
            <returns>String representation of content</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ToString(System.Int32)">
            <summary>
            Convert to string with limited length
            </summary>
            <param name="maxLength">Maximal length of returned string; set to 0 to not limit result</param>
            <returns>String representation of content</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray.ShortInfo">
            <summary>
            Short textual summary of this instance, used for debug output
            </summary>
            <returns>String representation of type and size</returns>
            <remarks>The type of elements and the size of the array are displayed. If the array
            is scalar, its value is displayed next to the type.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray.Dispose">
            <summary>
            Dispose this array and all its content
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Size">
            <summary>
            Size descriptor specification
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Dimensions">
            <summary>
            [deprecated] Use 'Size' as size descriptor!
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.D">
            <summary>
            [deprecated] Use 'S' as size descriptor!
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.Name">
            <summary>
            Gets the name of this array or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsComplex">
            <summary>
            Determine if this array is of complex inner type.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray.IsNumeric">
            <summary>
            Determine if this array is of numeric inner type.
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this array into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.Deserialize(System.IO.Stream)">
            <summary>
            Deserialize / restore array from binary stream 'inStream'
            </summary>
            <param name="inStream">System.IO.Stream to reconstruct the 
            array from</param>
            <returns>Array reconstructed from stream.</returns>
            <exception cref="T:System.Runtime.Serialization.SerializationException">If the array could not get restored</exception>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The selected value</returns>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@,System.Boolean)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#Generic#IEnumerable{ElementType}#GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the us of ILNumerics arrays in foreach loops.
            <para>This iterator implements IEnumerable&lt;ElementType> explicitely and is used in situations, 
            where instances of ILNumerics arrays are casted to instances of the IEnumerable interface. This iterator 
            is not integrated into the ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops directly.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseArray`1.Storage">
            <summary>
            Access to internal typed storage 
            </summary>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GetArrayForRead">
            <summary>
            Get direct reference to inner System.Array storage for <b>read access</b> - use with care! 
            </summary>
            <returns>Reference to inner System.Array for reading</returns>
            <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the array may exceeds the number of elements! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GetArrayForWrite">
            <summary>
            Direct reference to inner System.Array storage for write access - use with care!
            </summary>
            <returns>Reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics. Keep in mind, the length 
            of the System.Array may exceed the number of elements of the ILNumerics array.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only. 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>!</para>
            <para>Unlike (almost) all other member function of an array, this function
            does not keep track of internal memory management. It means, the storage which this array is based 
            upon, will not be set free after the function returns. You (as the user of the array) will have to pay 
            attention yourself, when to call dispose on the array - if necessary. Also, for elements of reference
            types (e.g. ILCell), retrieving and storing elements from/into the System.Array directly does 
            not simulate a value semantic as all other functions do! This means, references are copied. Attention
            must be paid to dereference / clone elements accordingly. </para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
            </example> 
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.GiveStorageAwayOrClone">
            <summary>
            Gives away internal storage for further use (e.g. in ILArray), disposes this array
            </summary>
            <returns>Internal storage</returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Reshape(ILNumerics.ILSize)">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions"/>
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Reshape(System.Int32[])">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="size">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.Shifted(System.Int32)">
            <summary>
            Create array from this array and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1);
            // D is now: &lt;double&gt; [4,3,2]
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.TryGetStorage4InplaceOp(`0[]@)">
            <summary>
            Give that storage away for in-place operations, if possible (depends on scope and temp type of array)
            </summary>
            <returns>true if the storage of the array is about to get disposed anyway</returns>
            <remarks>The function investigates the state of the array. If this is a temporary array in 
            the outer most scope, it would get disposed after the </remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Subtraction(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise subtraction operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of subtraction</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Addition(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise addition operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of addition</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Multiply(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise multiplication operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of multiplication</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Division(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise division operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of division</returns>
            <remarks>The operator is defined for both arrays of the same numeric 'ElementType' (double, float, complex,
            fcomplex, int, long, byte).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Modulus(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            Elementwise modulus operator
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result of modulus operation</returns>
            <remarks>The operator is defined for 2 arrays of the same numeric real element types: double, float, int, long, byte.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the array elements are of an unsupported type</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Equality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'Equalty' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Inequality(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'unequalty' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'greater or equal' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_LessThanOrEqual(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'smaller or equal' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Sizes and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_GreaterThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'greater' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Dimension and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_LessThan(ILNumerics.ILDenseArray{`0},ILNumerics.ILDenseArray{`0})">
            <summary>
            'smaller' operator of two arrays
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Logical array of same size than A and B, result of operation along all elements</returns>
            <remarks>Dimension and types of A and B must match.</remarks>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Explicit(ILNumerics.ILDenseArray{`0})~`0">
            <summary>
            Explicitly convert scalar array to System.Value type (ElementType)
            </summary>
            <param name="val">Array of arbitrary type and size of 1x1</param>
            <returns>Single value of type ElementType and of scalar size (1x1)</returns>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If input array is not scalar</exception>
            <exception cref="T:System.NullReferenceException">If val is null</exception>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_Implicit(`0)~ILNumerics.ILDenseArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">Single element of ElementType type</param>
            <returns>New array of type ILRetArray<![CDATA[<ElementType>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILDenseArray`1.op_UnaryNegation(ILNumerics.ILDenseArray{`0})">
            <summary>
            Negate elements of array - if applicable
            </summary>
            <param name="A">Input array</param>
            <returns>New solid arrray having the elements of A negated</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If elements of the array are not of 
            any supported numeric type</exception>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.Storage">
            <summary>
            internal access to the underlying storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.C">
            <summary>
            Clone of this array (fast, lazy and shallow)
            </summary>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.T">
            <summary>
            Return transposed version of this array
            </summary>
            <remarks>For matrices, this swaps columns with rows. For arrays, the dimensions are shifted by one.
            <para>Note, for complex elements, <b>no</b> conjugate is created! Use conj(A.T) if this is intended.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.MaxValue">
            <summary>
             [deprecated] Get maximum value of array - if any
            </summary>
            <remarks>This property is marked as deprecated and will be removed in a future version. Use one of the 
            following alternatives instead: 
            </remarks>
            <seealso cref="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)"/>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.MinValue">
            <summary>
             [deprecated] Get minimum value of array - if any
            </summary>
            <remarks>This property is marked as deprecated and will be removed in a future version. Use one of the 
            following alternatives instead: 
            <list type="bullets">
            <item><seealso cref="M:ILNumerics.ILBaseArray`1.GetLimits(`0@,`0@)"/></item>
            <item><seealso cref="M:ILNumerics.ILMath.minall(ILNumerics.ILInArray{System.Double})"/></item>
            </list></remarks>
        </member>
        <member name="P:ILNumerics.ILDenseArray`1.ReferenceCount">
            <summary>
            Get number of arrays, referencing the same underlying data storage 
            </summary>
            <return>This number is always greater than or equal to 1.</return>
            <remarks>For temporary arrays, calling this property does not - as usual - 
            disposes the array</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Create new ILArray, specify (dense) storage
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize)">
            <summary>
            create new ILArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0},System.Boolean)">
            <summary>
            create new ILArray, specify storage and if the new array should be disposed automatically
            </summary>
            <param name="storage"></param>
            <param name="registerForDisposal"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(ILNumerics.ILSize,System.Boolean)">
            <summary>
            create new ILArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
            <param name="registerForDisposal"></param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize)">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],ILNumerics.ILSize,System.Boolean)">
            <summary>
            create new ILArray from System.Array, optionally register the array for disposal 
            </summary>
            <param name="elements">System.Array</param>
            <param name="registerForDisposal">if true, the array will be disposed once the current scope is closed</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="size">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.#ctor(`0[])">
            <summary>
            create new ILArray from System.Array
            </summary>
            <param name="elements">variable length System.Array</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(System.Int32[])">
            <summary>
            [deprecated] Create empty array of arbitrary size
            </summary>
            <param name="size">Dimension sizes</param>
            <returns>New empty array</returns>
            <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="M:ILNumerics.ILMath.empty``1"/> instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.empty(ILNumerics.ILSize)">
            <summary>
            [deprecated] Create empty array of arbitrary size
            </summary>
            <param name="size">Dimension sizes</param>
            <returns>New empty array</returns>
            <remarks>This function is markes as deprecated and only included for compatibility reasons.
            It will be removed in a future version. Use <see cref="M:ILNumerics.ILMath.empty``1"/> instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns>New ILArray of type ILArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. If A is null: empty array.</returns>
            <remarks><para>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion</para>
            <para>The size of the result depends on the global option <c>Settings.CreateRowVectorByDefault</c></para></remarks>
            <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(System.Array)~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of the output array (shallow copy).</remarks>
            <seealso cref="P:ILNumerics.Settings.CreateRowVectorsByDefault"/>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILArray{`0}">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of a temp array
            </summary>
            <param name="A">Temporary array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of an input array
            </summary>
            <param name="A">Input array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILArray{`0}">
            <summary>
            "Persistence cast" make a steady array out of an input array
            </summary>
            <param name="A">Input array</param>
            <returns>Steady ILArray, will survive multiple usages</returns>
            <remarks>This is one of the most important casts in the ILNumerics framework. It changes temporary 
            arrays from temporary state to ('steady') ILArrays and persistent state. The inner storage is kept and used for 
            the new array. The new arrays can than get used multiple times in any function. In contrast to
            that, ILRetArrays are disposed off after first use.</remarks>
        </member>
        <member name="M:ILNumerics.ILArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Convert dense array to scalar temporary cell 
            </summary>
            <param name="A">Input array</param>
            <returns>Scalar cell having the only element with a clone of array</returns>
        </member>
        <member name="M:ILNumerics.ILArray`1.Assign(ILNumerics.ILRetArray{`0})">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to '='
            </summary>
            <param name="value">New array</param>
            <remarks>By using this method, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])"/> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial.</remarks>
            <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})"/>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="P:ILNumerics.ILArray`1.a">
            <summary>
            Assign another array to this array variable. This is an optional, yet more efficient alternative to using '='
            </summary>
            <param name="value">New array</param>
            <remarks>By assigning to this property, this array is immediately released to the memory pool and replaced by the new array. In difference to that, 
            by using the common '=' assignment operator, the array is released only at the time, the current 
            <see cref="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])"/> block  is left. Therefeore, prefere this method, if a 
            smaller memory pool is crucial. However, for variables of type <c>ILArray</c>, regular assignments are allowed as well.</remarks>
            <seealso cref="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})"/>
        </member>
        <member name="P:ILNumerics.ILArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/ manipulation/ deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILBaseCell">
            <summary>
            The class implements additional functionality needed for cells
            </summary>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Concat(ILNumerics.ILInCell,System.Int32)">
            <summary>
            Concatenate this cell 
            </summary>
            <param name="A">Cell to concatenate this cell with</param>
            <param name="dim">Dimension index along which to concatenate the cells.</param>
            <returns>New cell with concatenation of all elements of both cells</returns>
            <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single array of a known type from a cell position
            </summary>
            <typeparam name="T">Element type of the array</typeparam>
            <param name="indices">Position of the array within this cell</param>
            <returns>Lazy, shallow clone of the array found at the given position</returns>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetBaseArray(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single element from the given position
            </summary>
            <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
            <returns>A clone of the scalar element found</returns>
            <remarks>
            <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices"/>. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetCell(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a subcell of this cell
            </summary>
            <param name="indices">Subcell definition, arbitrary size</param>
            <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices"/></returns>
            <remarks>The cell returned will have the size and shape specified by <paramref name="indices"/>.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetEnumerator">
            <summary>
            Enumerator returning elements as scalar cells
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetValue(System.Int32[])">
            <summary>
            Retrieve single element from this cell
            </summary>
            <param name="idx">Position of the element</param>
            <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
        </member>
        <member name="M:ILNumerics.ILBaseCell.GetValue``1(System.Int32[])">
            <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            </summary>
            <typeparam name="T">Expected type of the value to be returned</typeparam>
            <param name="indices">Location of the single element addressed</param>
            <returns>A clone of the single element addressed by <paramref name="indices"/></returns>
            <remarks>The element returned will have the type given by <typeparamref name="T"/>. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.</remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            Test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">The array element type to check the cell element against</typeparam>
            <param name="position">Position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int></code>), 
            one may use <code>cell.IsTypeOf&lt;int>(0)</code></para>
            <para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell>(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="size">New size of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this cell.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Reshape(System.Int32[])">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="size">New size of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this cell.</exception>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILBaseCell.Repmat(System.Int32[])" ignoriert -->
        <member name="M:ILNumerics.ILBaseCell.Shifted(System.Int32)">
            <summary>
            Dimension shifted cell from this cell
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this cell</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILCell A = cell(2,4); <br/>
            ILCell B = A.Shifted(1); <br/>
            // B is now: ILCell [4,2] <br/>
            // <br/>
            ILCell C = cell(2,4,3);<br/>
            ILCell D = C.Shifted(1); <br/>
            // D is now: ILCell [4,3,2] <br/>
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseCell.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILBaseCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
            <remarks>This property is an alias for 'Shifted(1). </remarks>
            <seealso cref="M:ILNumerics.ILBaseCell.Shifted(System.Int32)"/>
        </member>
        <member name="P:ILNumerics.ILBaseCell.Storage">
            <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseCell.C">
            <summary>
            Clone of this cell
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics.Server are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
            <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hirarchy of other cells and arrays, in order to clone a cell, the cells elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para></remarks>
        </member>
        <member name="T:ILNumerics.ILBaseLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[<byte>]]> and an ILLogical is, the ILLogical 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.#ctor(ILNumerics.Storage.ILDenseStorage{System.Byte},System.Boolean)">
            <summary>
            Constructor creating ILLogical from dense storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new ILLogical</param>
            <param name="isTempArray">Indicate whether the result is supposed to be a temporary array (true) or persistent (false)</param>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.sumElements">
            <summary>
            Sum all elements of this storage. 
            </summary>
            <returns>Number of non zero elements</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of this array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Reshape(System.Int32[])">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Shifted(System.Int32)">
            <summary>
            Create logical array from this logical and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4); 
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range">Arrays specifying the ranges to create subarray from</param>
            <returns>Subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.ShortInfo">
            <summary>
            Short summary of this logical array
            </summary>
            <returns>Type and size information</returns>
        </member>
        <member name="M:ILNumerics.ILBaseLogical.empty(ILNumerics.ILSize)">
            <summary>
            [deprecated] create empty ILLogical 
            </summary>
            <returns>empty ILLogical.</returns>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.NumberNonZero">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.T">
            <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILBaseLogical.C">
            <summary>
            Create clone of this array 
            </summary>
        </member>
        <member name="T:ILNumerics.ILCell">
            <summary>
            ILCell: container class holding and managing arbitrary array objects 
            </summary>
            <remarks>
            ILCell acts as general purpose container. It stores arbitrary arrays of arbitrary element type. 
            Read and write access to cells provide value semantics - changes on arrays stored inside/ and 
            retrieved from a cell cannot change the corresponding original array. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILCell.#ctor(System.Int32[])">
            <summary>
            [deprecated] create new cell object, elements will be 'null' 
            </summary>
            <param name="size">dimension sizes of the new cell</param>
            <remarks><para>After creation, the cell elements can be set by use 
            of the indexer methods or by using corresponding methods of ILCell like SetValue()</para>
            <para>Consider using <see cref="M:ILNumerics.ILMath.cell()"/> in order to create 
            cell arrays.</para></remarks>
            <seealso cref="P:ILNumerics.ILCell.Item(System.Int32[])"/>
            <seealso cref="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])"/>
            <seealso cref="M:ILNumerics.ILBaseCell.GetArray``1(ILNumerics.ILBaseArray[])"/>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILCell">
            <summary>
            Convert temporary cell to persistent cell
            </summary>
            <param name="A">Temporary cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILCell">
            <summary>
            Convert input parameter cell to persistent cell
            </summary>
            <param name="A">Input parameter cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILCell">
            <summary>
            Convert output parameter cell to persistent cell
            </summary>
            <param name="A">Output parameter cell</param>
            <returns>Persistent cell</returns>
        </member>
        <member name="M:ILNumerics.ILCell.Assign(ILNumerics.ILRetCell)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILCell.SetRange(ILNumerics.ILInCell,ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
            <remarks>All common array modification/ reshaping/ removing/ expansion rules apply.
            <para>Like for almost all operations on cell, the values stored in the cell are 
            not connected to the original cell elements outside the cell (value semantics).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILInArray`1">
            <summary>
            Rectangular array, used as input parameter only 
            </summary>
            <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks><para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            input parameter to functions.</para><para>When writing your own function all <i>input</i> parameters should be of type <c>ILInArray</c>. 
            Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1"/> and all "out" parameters of type <see cref="T:ILNumerics.ILOutArray`1"/>.</para>
            <para>Other than being used to transfer arguments into functions, <c>ILInArray</c> should not be used.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILArray`1"/>
            <seealso cref="T:ILNumerics.ILRetArray`1"/>
            <seealso cref="T:ILNumerics.ILOutArray`1"/>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            create new ILInArray, specify (dense) storage
            </summary>
            <param name="storage"></param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(ILNumerics.ILSize)">
            <summary>
            create new ILInArray, specify dimensions
            </summary>
            <param name="dimensions"></param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(`0[],ILNumerics.ILSize)">
            <summary>
            create new ILInArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="dimensions">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(`0[],System.Int32[])">
            <summary>
            create new ILInArray from System.Array
            </summary>
            <param name="elements">System.Array</param>
            <param name="dimensions">dimension specifier</param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.#ctor(`0[])">
            <summary>
            create new ILInArray from System.Array
            </summary>
            <param name="elements">variable length System.Array</param>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0)~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">System type of size scalar</param>
            <returns>New ILInArray of type ILInArray <![CDATA[<typeof(val)>]]> of size 1x1 
            holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(System.Array)~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly convert n-dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILInArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILInArray{`0}">
            <summary>
            Implicitly casts three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Implicitly cast ILInArray to ILRetCell
            </summary>
            <param name="array">Input array</param>
            <returns>1x1 cell holding the array</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert temporary to input parameter array
            </summary>
            <param name="array">Temp array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert persistent to input parameter array
            </summary>
            <param name="array">Persistent array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="M:ILNumerics.ILInArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILInArray{`0}">
            <summary>
            Convert output paramter array to input parameter array
            </summary>
            <param name="array">Output parameter array</param>
            <returns>Input parameter array, will survive the current scope only</returns>
        </member>
        <member name="P:ILNumerics.ILInArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/ manipulation/ deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILInCell">
            <summary>
            ILCell : container class holding arbitrary array objects 
            </summary>
            <remarks>
            ILCell acts as general purpose container. It stores arbitrary arrays of arbitrary element type. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">size of the new cell</param>
            <remarks>object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILInCell.#ctor(System.Int32[])">
            <summary>
            create new cell object, elements will be 'null' 
            </summary>
            <param name="size">dimension sizes of the new cell</param>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILRetCell)~ILNumerics.ILInCell">
            <summary>
            Convert temporary cell to input parameter type cell
            </summary>
            <param name="cell">Temporary cell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILInCell">
            <summary>
            Convert temporary cell to input parameter type cell
            </summary>
            <param name="cell">ILCell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="M:ILNumerics.ILInCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILInCell">
            <summary>
            Convert output parameter type cell to input parameter type cell
            </summary>
            <param name="cell">Output parameter type cell</param>
            <returns>Input parameter type cell</returns>
        </member>
        <member name="P:ILNumerics.ILInCell.Item(System.Int32[])">
            <summary>
            Return single element in a scalar cell 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <remarks>
            <para>The indexer retrieves a single element from within the cell. It returns the single element 
            in a new (scalar) cell. Use dereferencing functions like GetArray&lt;T>() in order to retrieve 
            the element value (ie. the array addressed) without a cell container.</para>
            <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell"/>.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILInCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Cell array with subcell range from this instance, addressed by <c>indices</c> </returns>
            <remarks>
            <para>The indexer is used to query subcell ranges. All general indexing/ subarray addressing rules apply.
            The elements addressed are returned within a new temporary cell instance.</para>
            <para>Input parameter type cells are immutable! They are not intended to be altered! Therefore, 
            write access on such cells is disabled. In order to alter content of a cell, assign the cell to a regular
            persistent cell of type <see cref="T:ILNumerics.ILCell"/>.</para></remarks>
        </member>
        <member name="T:ILNumerics.ILInLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <![CDATA[ILArray<byte>]]>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <![CDATA[ILArray<byte>]]>.
            The difference between <![CDATA[ILArray<byte>]]> and logical arrays is, the logical array 
            storing a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Int32[])">
            <summary>
            constructor - create logical array of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            constructor - create logical array of specified size
            </summary>
            <param name="size">
            dimension object
            </param>
            <remarks>
            The size parameter may not be null. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">input array storage, the storage will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create logical array of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILInLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_LogicalNot(ILNumerics.ILInLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="A">Input array</param>
            <returns>New logical array, having the element values of A inverted</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(ILNumerics.ILInLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to bool
            </summary>
            <param name="A">logical array</param>
            <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
            <remarks>If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Boolean)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert scalar byte to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Byte scalar</param>
            <returns>New logical array of size 1x1 holding the only element of type <c>byte</c>
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Int32)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[])~ILNumerics.ILInLogical">
            <summary>
            implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1 dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Array)~ILNumerics.ILInLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILInLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILInLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILInLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="P:ILNumerics.ILInLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly)
            </summary>
            <param name="range">Range specification</param>
            <returns>Logical array with the elements specified by range</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays are derived from <c><![CDATA[ILArray<byte>]]></c>. It consumes
            1 byte per element and is the output parameter of all relational comparisons
            as well as the input parameter for all functions consuming <c><![CDATA[ILArray<byte>]]></c>.
            The difference between arrays and logical arrays is: the logical array 
            stores a integer value with the number of nonzero elements as additional information. 
            Therefore functions like 'find' are able to determine the lenght of output array to 
            be created omitting the need of multiple walks through the array. Therefore ILLogicalArrays 
            consume (a little) more time while construction but are much more performand on functions like 
            'find'.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Int32[])">
            <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            dimension object
            </param>
            <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            constructor - create logical array of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data"> byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="dimension">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Boolean)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert boolean scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Boolean scalar</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(ILNumerics.ILLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to bool
            </summary>
            <param name="A">logical array</param>
            <returns>true if <b>all</b> elements of A are non-zero, false otherwise 
            </returns>
            <remarks> If A is null or empty, the function returns false. Otherwise allall returns true, 
            if all elements of A are non-zero and returns false, if A contains any zero elements.</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Int32)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Array)~ILNumerics.ILLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException"> if type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.op_LogicalNot(ILNumerics.ILLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="in1">Input array</param>
            <returns>New solid logical array, inverted element values</returns>
        </member>
        <member name="M:ILNumerics.ILLogical.SetValue(System.Byte,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
            <summary>
            Alter a range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="M:ILNumerics.ILLogical.Assign(ILNumerics.ILRetLogical)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access
            </summary>
            <param name="range">Range specification</param>
            <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILLogical.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="T:ILNumerics.ILOutArray`1">
            <summary>
            Rectangular array, used as output parameter only 
            </summary>
            <typeparam name="ElementType">Inner type. This will mostly be a system numeric type or a 
            complex floating point type.</typeparam>
            <remarks><para>This class extends the primary <c>ILArray</c> by optimizing its behavior for the case when used as an
            output parameter of functions.</para><para>When writing your own function all <i>output</i> parameters should be of type <c>ILOutArray</c>. Do not
            use <c>out ILArray</c>! Similary, all return types should be of type <see cref="T:ILNumerics.ILRetArray`1"/> and all input parameters of type <see cref="T:ILNumerics.ILInArray`1"/>.</para>
            <para>Other than being used to retrieve results from functions, <c>ILOutArray</c> should not be used.</para>
            </remarks>
            <seealso cref="T:ILNumerics.ILArray`1"/>
            <seealso cref="T:ILNumerics.ILRetArray`1"/>
            <seealso cref="T:ILNumerics.ILInArray`1"/>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.#ctor(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Create new output parameter array
            </summary>
            <param name="storage">Dense storage for the new array</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILOutArray{`0}">
            <summary>
            Creates an output parameter type array from regular array
            </summary>
            <param name="A">Original array</param>
            <returns>Output parameter type array, references the original array</returns>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.Assign(ILNumerics.ILRetArray{`0})">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.SetValue(`0,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILOutArray`1.SetRange(ILNumerics.ILInArray{`0},ILNumerics.ILBaseArray[])">
            <summary>
            Alter range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="P:ILNumerics.ILOutArray`1.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILOutArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation/manipulation/deletion
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of this array</returns>
        </member>
        <member name="T:ILNumerics.ILOutLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.</remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Int32[])">
            <summary>
            Constructor - create logical array of type <c>Byte</c> of specified size
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILArray &lt; byte &gt; of the specified dimensions 
            will be created. The type of storage will be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            Constructor - create logical array of type <c>byte</c> of specified size
            </summary>
            <param name="size">
            Size descriptor
            </param>
            <remarks>
            The size parameter may not be null. An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing singleton dimensions). 
            Depending on the requested size an logical array of the specified dimensions 
            will be created. The element type is be <c>bool</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating logical array from dense storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            Constructor creating logical array from (dense) storage
            </summary>
            <param name="A">Input array, the storage of this ILArray will directly be used for 
            storage of the new logical array</param>
            <param name="numberNonZero">Number of nonzero elements in A. Must be positive or 0.</param>
            <remarks>Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            Constructor - create logical array of specified size from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an logical array of the specified size 
            will be created. The type of storage will be <c>byte</c>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating logical array, provide predefined storage
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Dimensions specification.</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating logical array, predefined storage (fast version)
            </summary>
            <param name="data">predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Dimensions specification.</param>
            <param name="nonZeroCount">number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILOutLogical">
            <summary>
            Convert logical array to output parameter type array
            </summary>
            <param name="A">Source logical array</param>
            <returns>Output parameter type array</returns>
        </member>
        <member name="M:ILNumerics.ILOutLogical.SetValue(System.Byte,System.Int32[])">
            <summary>
            Set single value to element at index specified
            </summary>
            <param name="value">New value</param>
            <param name="idx">Index of element to be altered</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.SetRange(ILNumerics.ILInLogical,ILNumerics.ILBaseArray[])">
            <summary>
            Alter a range of this array
            </summary>
            <param name="value">Array with new values</param>
            <param name="range">Range specification</param>
        </member>
        <member name="M:ILNumerics.ILOutLogical.Assign(ILNumerics.ILRetLogical)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">new array</param>
        </member>
        <member name="P:ILNumerics.ILOutLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access
            </summary>
            <param name="range">Range specification</param>
            <returns>Reference pointing to the elements of this array specified by range. If used for removal: 
            the array will be changed to a referencing array having the parts requested removed and reshaped accordingly.</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying or altering single/any elements 
            in this array. <c>range</c> may contains index specifications for one ... any 
            dimension. The array returned will have the size specified by range.</para>
            <para>The indexer may also be used for removing parts of the array. Therefore an empty array 
            (of the same type) or 'null' must be assigned to the range specified by <c>range</c> using the set-access. <c>range</c> 
            must contain exactly one dimension specification other than null. This may be any vector-sized numeric ILArray of any 
            type. If <c>range</c> applies 
            to less dimensions than dimensions existing in the array, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.</para>
            <para>In case of removal the ILArray returned will be a reference array.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutLogical.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="T:ILNumerics.ILRetArray`1">
            <summary>
            N-dimensional, generic array class, temporary variant, is disposed after first use
            </summary>
            <typeparam name="ElementType">Inner element type</typeparam>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0)~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly convert scalar to array of size 1x1 (scalar).
            </summary>
            <param name="val">Single element of ElementType type</param>
            <returns>New array of of size 1x1 holding the only element with value of val.
            </returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(System.Array)~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The inner type of input array <paramref name="A"/> must match the requested type
            <typeparamref name="ElementType"/>. The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(`0[0:,0:,0:])~ILNumerics.ILRetArray{`0}">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3-dimensional System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILRetArray{`0})~ILNumerics.ILRetCell">
            <summary>
            Convert array to temporary cell 
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary scalar cell, having the only element with a clone of A</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILInArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>Temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.op_Implicit(ILNumerics.ILOutArray{`0})~ILNumerics.ILRetArray{`0}">
            <summary>
            'Clone' conversion
            </summary>
            <param name="A">Source array</param>
            <returns>temporary ILArray, will be disposed after next operation</returns>
            <remarks>This conversion is for convenient reasons only. It enables the direct 
            use of (persistent) ILArray objects in situations where (temporary) ILRetArray 
            is required. One example is the conversion of ILArray as return type. 
            A (fast) clone will be made. This is an alias for A.C.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Concat(ILNumerics.ILInArray{`0},System.Int32)">
            <summary>
            Concatenate this array 
            </summary>
            <param name="A">n-dimensional storage</param>
            <param name="dim">Dimension index along which to concatenate the arrays.</param>
            <returns>New array with copy elements of this array and A</returns>
            <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered. If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting array has the size of both input arrays, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILArray&lt;double&gt; A = rand(5,4,6);
            foreach (double element in A) {
                // all elements are scalar double values
                String.Format("Element: {0} ", element);
                // Note: 'element' cannot be used to alter the collection! 
            } </code>
            </example> 
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The requested element</returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Reshape(ILNumerics.ILSize)">
            <summary>
            Reshaped copy of this array
            </summary>
            <param name="dimensions">New dimensions of the array</param>
            <returns>Reshaped copy of the array</returns>
            <remarks><para>The current instance will not be changed. A new storage is created, having 
            the elements of this array and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in <paramref name="dimensions"/>
            do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Shifted(System.Int32)">
            <summary>
            Create array from this array and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1);
            // B is now: &lt;double&gt; [4,2]
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="size">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.C">
            <summary>
            Clone of this array (fast, cheap and shallow)
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Size">
            <summary>
            Size descriptor 
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.T">
            <summary>
            Return transposed version of this array
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetArray`1.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray creation
            </summary>
            <param name="range">Range specification, defining the size of the subarray</param>
            <returns>Subarray as copy of a part of this array</returns>
            <remarks>Consult the ILNumerics subarray documentation for all subarray indexing rules.</remarks>
        </member>
        <member name="T:ILNumerics.ILRetCell">
            <summary>
            ILCell: container class holding arbitrary array objects 
            </summary>
            <remarks>
            ILCell acts as general purpose container. It stores arbitrary arrays of arbitrary element type. 
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],System.Int32[])">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            Create cell object with pre-created data in specified dimensions 
            </summary>
            <param name="data">Predefined element data array, will be used for new cell (no copy will be made)</param>
            <param name="size">Size of the new cell</param>
            <remarks>Object array data will directly be used for storage. No 
            copy will be made. However, any arrays referenced by data are dereferenced for storage inside the cell. The size must match prod(size)</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.#ctor(System.Int32[])">
            <summary>
            Create new cell object, elements will be 'null' 
            </summary>
            <param name="size">Size descriptor of the new cell</param>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive integer to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Double)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive double to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar double value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Single)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive float to a scalar temporary cell
            </summary>
            <param name="value">Primitive scalar float value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Byte)~ILNumerics.ILRetCell">
            <summary>
            Convert primitive byte to a scalar temporary cell
            </summary>
            <param name="value">Primitive byte int value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.Int32[])~ILNumerics.ILRetCell">
            <summary>
            Encapsulate integer System.Array into a scalar temporary cell
            </summary>
            <param name="value">Primitive System.Int32 value - no copy will be made!</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String)~ILNumerics.ILRetCell">
            <summary>
            Convert string to a scalar temporary cell
            </summary>
            <param name="value">String value</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(System.String[])~ILNumerics.ILRetCell">
            <summary>
            Encapsulate array of strings into a scalar temporary cell
            </summary>
            <param name="value">String array - no copy will be made!</param>
            <returns>New scalar temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILRetCell">
            <summary>
            Convert cell to temporary cell
            </summary>
            <param name="A">Cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILInCell)~ILNumerics.ILRetCell">
            <summary>
            Convert input parameter cell to temporary cell
            </summary>
            <param name="A">Input parameter cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILOutCell)~ILNumerics.ILRetCell">
            <summary>
            Convert output parameter cell to temporary cell
            </summary>
            <param name="A">Output parameter cell</param>
            <returns>Temporary cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.op_Implicit(ILNumerics.ILBaseLogical)~ILNumerics.ILRetCell">
            <summary>
            Wrap single logical array into a new scalar temporary cell
            </summary>
            <param name="A">Logical array</param>
            <returns>Scalar cell</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Concat(ILNumerics.ILInCell,System.Int32)">
            <summary>
            Concatenate this cell 
            </summary>
            <param name="A">Cell to concatenate this cell with</param>
            <param name="dim">Dimension index along which to concatenate the cells.</param>
            <returns>new cell with concatenation of all elements of both cells</returns>
            <remarks>The array returned will be a copy of both cells involved. 
            If <paramref name="dim"/> is larger than 
            the number of dimensions of one of the arrays its value will be used in modulus. 
            <para>The resulting cell has the size of both input cells, laid beside one 
            another along the <paramref name="dim"/> dimension.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.ExportValues(ILNumerics.Storage.ILStorage[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetArray``1(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single array of a known type from a cell position
            </summary>
            <typeparam name="T">Element type of the array</typeparam>
            <param name="indices">Position of the array within this cell</param>
            <returns>Lazy, shallow clone of the array found at the given position</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetBaseArray(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a single element from the given position
            </summary>
            <param name="indices">Position of the element to retrieve, must evaluate to a scalar position</param>
            <returns>A clone of the scalar element found</returns>
            <remarks>
            <para>The method returns a lazy, shallow clone of the content of the cell element specified by <paramref name="indices"/>. 
            However, the return type (<code>ILBaseArray</code>) is not strongly typed and may contain <b>any</b> element. According to the 
            true element stored in the cell, this might be an array of arbitrary type, null or even another cell. Moreover, handling 
            <code>ILBaseArray</code> directly is not recommended for ILNumerics, since this would hinder the memory management from proper 
            functioning. Therefore: <b>The use of this method is not recommended and left to ILNumerics experts - for very 
            specific and rare situations.</b></para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetCell(ILNumerics.ILBaseArray[])">
            <summary>
            Retrieve a subcell of this cell
            </summary>
            <param name="indices">Subcell definition, arbitrary size</param>
            <returns>A cell with a lazy, shallow clone of the elements of this cell, addressed by <paramref name="indices"/></returns>
            <remarks>The cell returned will have the size and shape specified by <paramref name="indices"/>.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetEnumerator">
            <summary>
            Enumerator returning elements as scalar cells
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of cells in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILRetCell.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetLimits(ILNumerics.Storage.ILStorage@,ILNumerics.Storage.ILStorage@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetValue(System.Int32[])">
            <summary>
            Retrieve single element from this cell
            </summary>
            <param name="idx">Position of the element</param>
            <returns>Lazy, shallow clone of the element to retrieve or null, if there is no element at this place</returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.GetValue``1(System.Int32[])">
            <summary>
            Retrieve a typed single element from within the cell, supports deep indexing
            </summary>
            <typeparam name="T">Expected type of the value to be returned</typeparam>
            <param name="indices">Location of the single element addressed</param>
            <returns>A clone of the single element addressed by <paramref name="indices"/></returns>
            <remarks>The element returned will have the type given by <typeparamref name="T"/>. It is an error to specify 
            a different type as the true type of the element specified. An exception is thrown if both types differ.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            Test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">The array element type to check the cell element against</typeparam>
            <param name="position">Position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<code>ILArray&lt;int></code>), 
            one may use <code>cell.IsTypeOf&lt;int>(0)</code></para>
            <para>In order to test, if a cell element is of type <code>ILCell</code>, one can provide the type <code>ILCell</code> as type parameter: 
            <code>cell.IsTypeOf&lt;ILCell>(0)</code>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <code>ILCell</code>. The reason of this is: the type of elements of <code>ILCell</code> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.ILRetCell.Repmat(System.Int32[])">
            <summary>
            Create replication of this cell
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this cell, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created by multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetCell.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this cell
            </summary>
            <param name="dimensions">New dimensions of the cell</param>
            <returns>Reshaped copy of the cell</returns>
            <remarks><para>The current instance will not be changed! A new cell is created, having 
            the elements of this cell and a shape as determined by <paramref name="dimensions"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="dimensions"/> do not match the number of elements in this cell.</exception>
        </member>
        <member name="M:ILNumerics.ILRetCell.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Shifted(System.Int32)">
            <summary>
            Dimension shifted cell from this cell
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this cell</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILCell A = cell(2,4); 
            ILCell B = A.Shifted(1);
            // B is now: ILCell [4,2] 
            
            ILCell C = cell(2,4,3);
            ILCell D = C.Shifted(1);
            // D is now: ILCell [4,3,2]
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style. </para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly) 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements stored in the cell.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetCell.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>Writing cells to *.mat files is NOT SUPPORTED yet! </para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.C">
            <summary>
            Clone of this cell
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays on write access.</para>
            <para>Cells profit from the same efficient clone creation process. However, since a cell may store an arbitrarily deep 
            hierarchy of other cells and arrays, in order to clone a cell, the cell elements have to be cloned as well - in an 
            recursive manner. Clones play an important role for ILNumerics cells. They are used to implement value semantics for cell
            elements. I.e.: the cloned cell returned cannot not be used to alter elements of the original cell in any way.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Size">
            <summary>
            Size descriptor
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsColumnVector">
            <summary>
            Test if this array instance is a column vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsRowVector">
            <summary>
            Test if this array instance is a row vector
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Dimension.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.T">
            <summary>
            Transposed version of this ILCell
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Storage">
            <summary>
            Access to the more specialized version (ILCellStorage) of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="Index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example><code>
            ILArray&lt;double&gt; A = ILMath.counter(1,12);
            A[2] gives: 3.0
            </code>But the transpose 
            <code>
            A.T[2] gives also: 3.0
            </code> 
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILRetLogical">
            <summary>
            Boolean array for high performance relational operations on arbitrary arrays 
            </summary>
            <remarks>
            Logical arrays store true/false conditions as elements. Each element consumes
            one byte. Logical arrays are the output parameter of all relational comparisons.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage)">
            <summary>
            Constructor creating ILRetLogical from dense storage
            </summary>
            <param name="A">input array, the storage given will directly be used for 
            storage of the new logical array</param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.Storage.ILLogicalStorage,System.Int64)">
            <summary>
            create temporary logical from predefined storage
            </summary>
            <param name="A">the storage will directly be used as storage of the new logical array</param>
            <param name="numberNonZero">number of nonzero elements in A. Must be positive or 0.</param>
            <remarks> Providing this parameter prevents the constructor from having to count the 
            'true' elements in A.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(ILNumerics.ILSize)">
            <summary>
            create temporary logical array of specified size
            </summary>
            <param name="size">
            variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <remarks>
            The size parameter may not be null or an empty array. An exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size a logical temporary array of the specified size 
            will be created. </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],System.Int32[])">
            <summary>
            Constructor - create ILRetLogical of specified size 
            from data array
            </summary>
            <param name="size">
            Variable length int array specifying the number and size of dimensions to 
            be created.
            </param>
            <param name="data">byte array matching the size of the dimensions 
            specified. The data will directly be used as storage! No copy will be made!</param>
            <remarks>
            The size parameter may not be null or an empty array! An Exception will be 
            thrown in this case. The dimensions will be trimmed before processing 
            (removing trailing non singleton dimensions). 
            Depending on the requested size an ILRetLogical of the specified size 
            will be created. The type of storage will be <code>byte</code>.
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize)">
            <summary>
            Constructor creating ILRetLogical, provide predefined storage
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Size descriptor</param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.#ctor(System.Byte[],ILNumerics.ILSize,System.Int64)">
            <summary>
            Constructor creating ILRetLogical, predefined storage (fast version)
            </summary>
            <param name="data">Predefined storage elements. The array will directly be used 
            as underlying storage. No copy will be made! </param>
            <param name="size">Size descriptor</param>
            <param name="nonZeroCount">Number of nonzero elements in <paramref name="data"/>. 
            Providing this parameter prevents from counting the 'true' elements (again). </param>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Clone">
            <summary>
            Clone of this array
            </summary>
            <remarks><para>
            Clones of all arrays in ILNumerics are done in a very fast, lazy way. This means, 
            at the time the clone is made, no relevant memory is copied. Elements of both arrays rather point to the same 
            underlying System.Array. A reference counting mechanism ensures the detaching of thoses arrays 
            on write access.</para>
            <para>The clone returned will be of the same type as this instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Concat(ILNumerics.ILInLogical,System.Int32)">
            <summary>
            Concatenate this array
            </summary>
            <param name="A">N-dimensional array. Except for dimensions <paramref name="dim"/>
            the dimensions of A must match the dimensions of this storage</param>
            <param name="dim">Index of dimension to concatenate arrays along.
            If dim is larger than the number of dimensions of any of the arrays,
            its value will be used in modulus the number of dimensions.</param>
            <returns>New array having the size 
            of both input arrays layed behind each other along the dim's-dimension</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Equals(System.Object)">
            <summary>
            Compare elements and shape of this array with another array
            </summary>
            <param name="A">Other array</param>
            <returns>true if shape and element values of both arrays match, false otherwise</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.ExportValues(System.Byte[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="outArray">[Output] System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'outArray' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetEnumerator">
            <summary>
            Enumerator returning elements as ElementType
            </summary>
            <returns>Enumerator</returns>
            <remarks>This method enables the use of ILNumerics arrays in foreach loops.
            <para>The iterator is returned, if arrays are directly used in foreach statements. The iterator 
            is compatible with ILNumerics memory management.</para></remarks>
            <example><code>ILDenseStorage&lt;T&gt; A = ILMath.rand(5,4,6);
            foreach (double element in A) {
            // all elements are scalar double values
            String.Format("Element: {0} ",element);
            // Note: 'element' cannot be used to alter the collection! 
            } 
            </code></example> 
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetHashCode">
            <summary>
            Generate a hash code based on the current arrays values
            </summary>
            <returns>Hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a costly 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetLimits(System.Byte@,System.Byte@)">
            <summary>
            Get minimum and maximum value of all elements - if any
            </summary>
            <param name="min">[Output] Minimum value</param>
            <param name="max">[Output] Maximum value</param>
            <returns>true if the limits exists and could be computed, false otherwise</returns>
            <remarks>Empty arrays will return false. In this case the output parameter will be: default(ElementType).
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.GetValue(System.Int32[])">
            <summary>
            Get single element from this array
            </summary>
            <param name="idx">Indices, location of element</param>
            <returns>The requested element</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Reshape(ILNumerics.ILSize)">
            <summary>
            Create reshaped copy of this logical array
            </summary>
            <param name="size">New dimensions of the array</param>
            <returns>Reshaped copy of this array</returns>
            <remarks><para>The current instance will not be changed! A new array is created, having 
            the elements of this array and a shape as determined by <paramref name="size"/>.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 
            <paramref name="size"/> do not match the number of elements in this array.</exception>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Repmat(System.Int32[])">
            <summary>
            Create replication of this array
            </summary>
            <param name="dims">Dimensions specifier. If the number of elements in <paramref name="dims"/> is 
            less than the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimension stored inside the storge the resulting 
            storage will get its number of dimensions extended accordingly. </param>
            <returns>Array being created out of multiple replications of this array along 
            arbitrary dimensions according to <paramref name="dims"/></returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Serialize(System.IO.Stream)">
            <summary>
             Serialize this ILArray into a binary stream.
            </summary>
            <param name="outStream">System.IO.Stream to receive the byte stream 
            for this ILBaseArray</param>
            <returns>True on success, false on error.</returns>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Shifted(System.Int32)">
            <summary>
            Create logical array from this logical and shift dimensions
            </summary>
            <param name="shift">Number of dimensions to shift</param>
            <returns>Shifted version of this array</returns>
            <remarks><para>The shift is done 'to the left':</para>
            <example><code>ILArray&lt;double&gt; A = zeros(2,4);
            ILArray&lt;double&gt; B = A.Shifted(1); 
            // B is now: &lt;double&gt; [4,2] 
            
            ILArray&lt;double&gt; C = zeros(2,4,3);
            ILArray&lt;double&gt; D = C.Shifted(1); 
            // D is now: &lt;double&gt; [4,3,2] 
            </code></example>
            <para>The dimensions are shifted circulary to the left. This 
            can be imagined as removing the first dimensions from the beginning of the list of 
            dimensions and "append" them to the end in a ringbuffer style.</para>
            <para>For dimension shifts of '1', you may consider using the 
            <see cref="P:ILNumerics.ILDenseArray`1.T"/> property for readability.</para>
            <para><paramref name="shift"/> must be positive. It is taken modulus the number of dimensions.</para>
            <seealso cref="P:ILNumerics.ILDenseArray`1.T"/></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range">Arrays specifying the ranges to create subarray from</param>
            <returns>Subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)">
            <summary>
            Send values of this instance to stream. 
            </summary>
            <param name="stream">Stream to write the values into.</param>
            <param name="format">Format string to be used for output. See <see cref="M:System.String.Format(System.String,System.Object)"/> for a specification
            of valid formating expressions. This flag is only used, when 'method' is set to 'Serial'.</param>
            <param name="method">A constant out of <see cref="T:ILNumerics.ILArrayStreamSerializationFlags"/>. Specifies the way in which
            the values will be serialized.</param>
            <remarks><para>If the 'Formatted' method is used, any occurences of the NewLine character(s) 
            will be replaced from the format string before applying to the elements. This is done to 
            prevent the format from breaking the 'page' style of the output.</para>
            <para>If 'method' is set to 'Matlab', the array will be written as Matfile version 5.0. No compression will be used. The internal 'Name' property will be used as the
            array name for writing. This array instance will be the only array in the .mat file. If you want to write several arrays bundled into one mat file, use the MatFile class to
            create a collection of arrays and write the MatFile to stream.</para></remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast one dimensional System.Array to ILNumerics array (vector)
            </summary>
            <param name="A">1-dimensional system array, arbitrary type</param>
            <returns>ILNumerics array of same element type as elements of A. 
            Row vector. If A is null: empty array.</returns>
            <remarks>The System.Array A will directly be used for the new ILNumerics array! 
            No copy will be done! Make sure, not to reference A after this conversion!</remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Array)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert n-dim. System.Array to ILNumerics array
            </summary>
            <param name="A">Arbitrarily sized System.Array</param>
            <returns>If A is null: empty array. Else: new ILNumerics array of the same size as A</returns>
            <remarks>The resulting ILArray will reflect all dimensions of 
            A. Elements of A will get copied to elements of output array (shallow copy).</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILCastException">If type of input does not match 
            ElementType</exception>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast two dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">2D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Byte[0:,0:,0:])~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast three dimensional System.Array to ILNumerics array
            </summary>
            <param name="A">3D System.Array</param>
            <returns>If A is null: empty array. ILNumerics array of same size and type as A otherwise.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Boolean)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert boolean System.Byte to scalar logical array
            </summary>
            <param name="val">System.Byte</param>
            <returns>Scalar logical array with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~System.Boolean">
            <summary>
            Implicitly convert logical array to System.Boolean
            </summary>
            <param name="A">Logical array</param>
            <returns>true if elements of A are non-zero, false otherwise 
            </returns>
            <remarks>If A is null or empty, the function returns false. Otherwise returns true, 
            if all elements of A are non-zero and returns false, if A contains zero elements.
            <para>The behavior depends on the setting of the ILSettings.LogicalArrayToBoolConversion switch.
            Per default, only scalar arrays are allowed to be converted implicitely. This can be changed 
            to implicitely convert non-scalar arrays by using ILMath.any on the array.</para>
            <seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion"/>
            <seealso cref="M:ILNumerics.ILMath.any(ILNumerics.ILInArray{System.Double},System.Int32)"/>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(System.Int32)~ILNumerics.ILRetLogical">
            <summary>
            Implicitly convert integer scalar to logical array of size 1x1 (scalar).
            </summary>
            <param name="val">Scalar value</param>
            <returns>New logical array of size 1x1 holding the only element of type Byte 
            with value of val.</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical to temporary logical array
            </summary>
            <param name="a">Original logical array</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical input parameter type array to temporary logical array
            </summary>
            <param name="a">Logical input parameter type</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILOutLogical)~ILNumerics.ILRetLogical">
            <summary>
            Convert logical output parameter type array to temporary logical array
            </summary>
            <param name="a">Logical output parameter type</param>
            <returns>Temporary logical array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILArray{System.Byte}">
            <summary>
            Implicitly cast to ILArray&lt;byte&gt;
            </summary>
            <param name="a">A ILRetLogical</param>
            <returns>ILArray&lt;byte&gt;</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILArray{System.Byte})~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast from ILArray&lt;byte&gt;
            </summary>
            <param name="a">An ILArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILRetLogical)~ILNumerics.ILInArray{System.Byte}">
            <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            </summary>
            <param name="a">An ILInArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_Implicit(ILNumerics.ILInArray{System.Byte})~ILNumerics.ILRetLogical">
            <summary>
            Implicitly cast from ILInArray&lt;byte&gt;
            </summary>
            <param name="a">An ILInArray&lt;byte&gt;</param>
            <returns>logical return array</returns>
        </member>
        <member name="M:ILNumerics.ILRetLogical.op_LogicalNot(ILNumerics.ILRetLogical)">
            <summary>
            Invert values of array elements 
            </summary>
            <param name="in1">Input array</param>
            <returns>New logical array, inverted element values</returns>
        </member>
        <member name="P:ILNumerics.ILRetLogical.NumberNonZero">
            <summary>
            Number of 'true' elements in this array
            </summary>
            <remarks>This value caches the number of 'true' elements in this logical array. 
            It may be used for information purposes but is actually needed internally for performance 
            reasons.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.T">
            <summary>
            Shift the dimensions of this array by one (transpose for matrix)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.C">
            <summary>
            Create clone of this array 
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.S">
            <summary>
            Size descriptor shortcut
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Size">
            <summary>
            Size descriptor
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsColumnVector">
            <summary>
            Test if this array instance is a column vector (e.g. n x 1)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsRowVector">
            <summary>
            Test if this array instance is a row vector (e.g. 1 x n)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsComplex">
            <summary>
            Determine if this array has complex elements.
            </summary>
            <remarks><para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsEmpty">
            <summary>
            Test if this instance is an empty array (number of elements stored = 0)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsMatrix">
            <summary>
            Test if this instance is a matrix
            </summary>
            <remarks>In order for an array to be a matrix the number of <b>non singleton</b> 
            dimensions must equal 2. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsNumeric">
            <summary>
            Determine if this array holds numeric values.
            </summary>
            <remarks>An ILArray is numeric as long as its elements are one of the 
            following types: 
            <list type="table">
            <listheader>
                <term>inner type</term>
            </listheader>
            <item>
                <term>System.double</term>
                <description>floating point, real, 8 bytes </description>
            </item>
            <item>
                <term>System.float</term>
                <description>floating point real, 4 bytes</description>
            </item>
            <item>
                <term>ILNumerics.complex</term>
                <description>floating point complex, 16 bytes</description>
            </item>
            <item>
                <term>ILNumerics.fcomplex</term>
                <description>floating point complex, 8 bytes</description>
            </item>
            <item>
                <term>System.char</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.byte</term>
                <description>integer, real, 1 byte</description>
            </item>
            <item>
                <term>System.Int16</term>
                <description>integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.Int32</term>
                <description>integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.Int64</term>
                <description>integer, real, 8 byte</description>
            </item>
            <item>
                <term>System.UInt16</term>
                <description>unsigned integer, real, 2 byte</description>
            </item>
            <item>
                <term>System.UInt32</term>
                <description>unsigned integer, real, 4 byte</description>
            </item>
            <item>
                <term>System.UInt64</term>
                <description>unsigned integer, real, 8 byte</description>
            </item>
            </list>
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsScalar">
            <summary>
            Test if this instance is a scalar
            </summary>
            <remarks>This attribute is readonly. It returns: Size.NumberOfElements == 1.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.IsVector">
            <summary>
            Test if this array is a vector
            </summary>
            <remarks>In order for an array to be a vector the number of <b>non singleton</b> 
            dimensions must equal 1. Keep in mind that all ILArrays have at least 2 dimensions. Therefore 
            it is not sufficient to test for the number of dimensions, but to take the number of 
            <b>non singleton</b> dimensions into account. This attribute is readonly.</remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Length">
            <summary>
            Length of the longest dimension of this instance
            </summary>
            <remarks>This property is readonly.
            <para>Calling this member will dispose this instance afterwards (for temporary arrays).</para></remarks>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Name">
            <summary>
            Gets the name of this array (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.ILRetLogical.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access (readonly)
            </summary>
            <param name="range">Range specification</param>
            <returns>Logical array with the elements specified by range</returns>
            <remarks>Query access: for N-dimensional arrays trailing dimensions will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in range.
            <para>The indexer may be used for querying any elements 
            in this array. <c>range</c> may contains index specifications for one ... to any 
            dimension. The array returned will have the size specified by range.</para>
            </remarks>
        </member>
        <member name="T:ILNumerics.ILOutCell">
            <summary>
            ILCell : container class holding arbitrary array objects 
            </summary>
            <remarks>
            ILCell acts as general purpose container. It stores arbitrary arrays of arbitrary element type. 
            
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutCell.#ctor(ILNumerics.Storage.ILCellStorage)">
            <summary>
            do not use this constructor! Out arrays are to be created implicitely only!
            </summary>
            <param name="cellStorage">storage of source cell</param>
        </member>
        <member name="M:ILNumerics.ILOutCell.op_Implicit(ILNumerics.ILCell)~ILNumerics.ILOutCell">
            <summary>
            Implicitely convert persistent cell to output parameter type cell 
            </summary>
            <param name="A">Original cell</param>
            <returns>Output parameter cell</returns>
        </member>
        <member name="M:ILNumerics.ILOutCell.Assign(ILNumerics.ILRetCell)">
            <summary>
            Replaces storage of this array with new array elements, registers this array for out-of-scope disposal
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.ILBaseArray,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILOutCell.SetValue(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            Set single element of the cell
            </summary>
            <param name="value">The new value</param>
            <param name="idx">Indices specifying the location to set the element to</param>
            <remarks>The function supports the following features: 
            <list type="bullet">
            <item>Automatic expansion of the cell, when addressing an element outside of the cells size limits.</item>
            <item>Before storing the new element into the cell, an old element may existing on the same location gets disposed.</item>
            <item>A clone of the new value is stored, therefore, none of the source and the stored element are altered, whenever the other cell is altered (value semantics).</item>
            <item>The function supports deep index addressing. This is the only way of altering array elements inside the cell - without recreation.</item>
            </list>
            <para>Removal of parts of the cell is <b>not</b> supported. If null or an empty array is provided as <paramref name="value"/>, the corresponding 
            element is overwritten or removed.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILOutCell.a">
            <summary>
            Replace the elements of this array with another array's elements, preventing memory leaks
            </summary>
            <param name="value">New array</param>
        </member>
        <member name="P:ILNumerics.ILOutCell.Item(System.Int32[])">
            <summary>
            Get/set/remove single element 
            </summary> 
            <paramref name="indices" value="index to element"/>
            <value>Inner element, new inner element or null</value>
            <remarks>The type of access depends on the length of indices. If indices contains only one element, 
            the array will be accessed via sequential index access. This is sometimes called referred to as 'linear' 
            index addressing. 
            Sequential index access reflects the index of internal storage the way the data are actually organized 
            in memory. This access method is mainly convinient for vectors where you are not interested of orientation.
            The following example demonstrates sequential index access for ILArray's (which also holds for ILCells): 
            <example>For <c>ILArray&lt;double&gt; A = ILMath.counter(1,12);</c>, <c>A[2]</c> gives: 3.0.
            But the transpose 
            <c>A.T[2]</c> gives also: 3.0.
            For matrices and N-dimensional arrays this holds as well: 
            <code>
            ILArray&lt;double&gt; A = ILMath.counter(1.0,1.0,3,2,2);
            A = 
            [1.0 4.0
             2.0 5.0 
             3.0 6.0 
            
             7.0 10.0
             8.0 11.0
             9.0 12.0]
            
            A = ILMath.Reshape(A,3,2,2); 
            A[10] gives 11.0
            A[10,1] gives ILArgumentException -> out of range
            A[2,1,1] gives 12.0
            A[2,1] gives 6.0 (set trailing dimension to '0')</code></example>
            <para>If the element addressed is a ILCell itself, a deep reference to this element will be returned instead. 
            I.e. all elements of the ILCell will be recursively replaced with references to itself. Therefore, altering the 
            elements returned will not alter the elements contained in the cell.</para>
            <para>
            <list type="bullet">
            <listheader>The type of the element returned depends on the type of the element addressed:</listheader>
            <item>For ILArray&lt;ElementType&gt; the array returned will be a clone of the original array.</item> 
            <item>For ILCell the ILBaseArray returned is a deep reference of the original elements stored.</item>
            <item>For other types the behavior is undefined. (since other types are not implemented yet ;)</item>
            </list> </para>
            <para>This indexer may also be used for direct access to inner elements of (elements of elements of ...) this cell:
            <example>
            <code>
            ILCell innerCell = new ILCell(2,1); 
            innerCell[0] = ILMath.vec(10,200); 
            innerCell[1] = new int[] {-10,-20,-30};
            ILCell cell = new ILCell(2,1); 
            cell[0] = innerCell; 
            cell[1] = new string[] {"foobla"}; 
            // cell is now: 
            // [ILCell,(1x2)] 
            //      [innerCell[0], ILArray&lt;double&gt;(1x181)]
            //      [innerCell[0], ILArray&lt;double&gt;(1x3)]
            // [ILArray&lt;string&gt;,(1x1)]
            
            cell[0,0] -&gt; will give innerCell eq. ILCell (1x2)
            cell[0,1] -&gt; will give ILArray&lt;string&gt;
            cell[0,0,0,1] -&gt; will give innerCell[1] eq. ILArray&lt;int&gt;(1x3)
            </code>
            </example> 
            In the last example above the trailing indices specified make the indexer walk down into the ILCell element and retrieve 
            the content of this element. This kind of index access may be done as deep as you want. Just 
            append the inner indices into inner elements to the right side of index specification. Addressing inner elements 
            this way is the only way to alter elements <b>directly</b> inside the ILCell. </para>
            <para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para></remarks>
        </member>
        <member name="P:ILNumerics.ILOutCell.Item(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray access. Get/set regular subarray. 
            </summary>
            <param name="indices">Address range</param>
            <returns>Reference cell array with subarray addressed by <c>indices</c>. </returns>
            <remarks>Query access: for N-dimensional cell arrays missing trailing dimensions indices will be choosen to be 0. Therefore you 
            may ommit those trailing dimensions in <c>indices</c>.
            <para>The indexer may be used for querying or altering single/any elements 
            in this cell. <c>indices</c> may contains index specifications for one to any 
            dimension. The cell array returned will have the size specified by <c>indices</c>.</para>
            <para>Values returned will be reference cells. All elements contained will be 'deep references' created by 
            recursively walking downwards the elements and replacing them by references to itself. Therefore altering the 
            values returned will not alter the original elements.</para>
            <para>The indexer may also be used for removing parts of the cell. Therefore null must be assigned to the range specified by <c>indices</c> (using the set-access). <c>indices</c> 
            must contain exactly one dimension specification other than 'full' in this case. This may be any vector-sized numeric ILArray of any 
            numeric type. If <c>indices</c> apply to fewer dimensions than the number of dimensions existing, the upper dimensions will be 
            merged and the array will be reshaped before applying the removal to it.
            <example>
            <code>
            ILCell C = new ILCell(4,10); 
            C[":",2] = null;  // &gt;- will remove the third column (index: 2) from the cell.
            C[full,vec(2,5)] = null;  &gt;- will remove columns 3...6
            C[1,1] = null; &gt;- will produce an error. Only one dimension can be specified not full! 
            </code></example></para>
            <para>The general behavior of this access methods is full compatible with the corresponding Matlab/Octave/Scilab access: a(:) = []. </para>
            <para>Output parameter type cell carry a reference to the original array they were created from. 
            Modifications of outpur parameter type cells are immediately applied to the original array also.</para></remarks>
        </member>
        <member name="T:ILNumerics.Data.ILAVLTree">
            <summary>
            AVL balanced search tree
            </summary>
            <remarks>The tree stores unique keys (type:System.Int64, configurable via build) in a balanced search tree.
            <para>The implementation is optimized for random seek access and consecutive write access - if no matching key found. 
            Also, the next higher key for a given query can be returned in O(1).</para>
            <para>The AVL tree class is not intended to be used directly. It supports the ILNumerics infrastructure (ILMemoryPool) 
            internally.</para></remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Add(System.Int64)">
            <summary>
            Check and add a key to the collection
            </summary>
            <param name="key">Key</param>
            <remarks>The function makes sure, the key is stored in the tree.</remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Remove(System.Int64)">
            <summary>
            Remove key from tree
            </summary>
            <param name="key">Key to be removed</param>
            <remarks>The function makes sure, the tree does not contain a node with the given key.</remarks>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Next(System.Int64)">
            <summary>
            Find next higher key
            </summary>
            <param name="key">Key to find</param>
            <returns>The key with the next higher value compared with <paramref name="key"/>, or -1 if no such key exists</returns>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.Clear">
            <summary>
            Clear the tree from all keys
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.CheckTree">
            <summary>
            check the consistency of the tree
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Data.ILAVLTree.Count">
            <summary>
            Return number of keys currently existing in the tree
            </summary>
        </member>
        <member name="T:ILNumerics.Data.ILAVLTree.ILAVLTreeNode">
            <summary>
            an AVL tree node 
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.key">
            <summary>
            Key
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.right">
            <summary>
            Right child
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.left">
            <summary>
            Left child
            </summary>
        </member>
        <member name="F:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.balance">
            <summary>
            Balance factor for the node
            </summary>
        </member>
        <member name="M:ILNumerics.Data.ILAVLTree.ILAVLTreeNode.ToString">
            <summary>
            Rext representation of the node 
            </summary>
            <returns>String representation for the node</returns>
        </member>
        <member name="M:ILNumerics.Data.ILIntList.GetArray">
            <summary>
            caution! This may bring the ILIntList in inconsistent state! 
            </summary>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILAxisCollection">
            <summary>
            Collection of all 3 axes contained in each subfigure
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILAxisCollection.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.Interfaces.IILCreationFactory)">
            <summary>
            create new ILAxisCollection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Item(System.Int32)">
            <summary>
            Get / set ILAxis by index
            </summary>
            <param name="index">index of axis: XAxis = 0, YAxis = 1, ZAxis = 2</param>
            <returns>ILAxis specified by index</returns>
            <value>new ILAxis to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Item(ILNumerics.Drawing.AxisNames)">
            <summary>
            Get / set ILAxis by name enum
            </summary>
            <param name="name">one of the enum values: XAxis, YAxis, ZAxis</param>
            <returns>ILAxis specified by name</returns>
            <value>new ILAxis to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.XAxis">
            <summary>
            Get access to the X-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.YAxis">
            <summary>
            Get access to the Y-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.ZAxis">
            <summary>
            Get access to the Z-axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.MaxTicLabelSize">
            <summary>
            Maximum size of all axes contained in the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.Visible">
            <summary>
            Set visibility for all axes simultaneously
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.LinesVisible">
            <summary>
            set visibility of axis lines simultaneously
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILAxisCollection.GridVisible">
            <summary>
            set visibility of all axis grid lines simultaneously
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILGraphCollection">
            <summary>
            Collection of graph objects - all graphs currently contained in a subfigure
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.OnChange(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.GraphCollectionChangeReason,ILNumerics.Drawing.Interfaces.IILPanelConfigurator)">
            <summary>
            triggers the ILGraphCollectionChanged event
            </summary>
            <param name="sender"></param>
            <param name="reason"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.OnGraphChanged(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.ILGraphChangedEventArgs)">
            <summary>
            triggers GraphChanged event, bubbles from single graph
            </summary>
            <param name="graphArgs">event arguments from graph</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.#ctor(ILNumerics.Drawing.Interfaces.IILCreationFactory)">
            <summary>
            Create new ILGraphCollection
            </summary>
            <param name="panel">Output panel </param>
            <param name="clippingData"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Dispose">
            <summary>
            dispose all graphs contained in this collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Limits_Changed(System.Object,ILNumerics.Drawing.ClippingChangedEventArgs)">
            <summary>
            called once the limits of a graph have changed
            </summary>
            <param name="sender">graph</param>
            <param name="e">event args, holding a reference to the clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Clear">
            <summary>
            clear all graphs from the collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSurfGraph(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Add a new surface graph, provide all coordinate data
            </summary>
            <param name="Z">matrix holding Z coordinates (heights)</param>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSurfGraph(ILNumerics.ILInArray{System.Single})">
            <summary>
            Add a new surface graph to collection
            </summary>
            <param name="data">matrix holding data to be plotted</param>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot(ILNumerics.Drawing.Plots.ILPlot)">
            <summary>
            add a plot to a new scene graph
            </summary> 
            <param name="plot">plot to be added to the panel</param>
            <returns>newly created scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSceneGraph">
            <summary>
            Add a new scene graph to collection
            </summary>
            <returns>reference to newly created surface graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddSceneGraph(ILNumerics.Drawing.Graphs.ILSceneGraph)">
            <summary>
            add an newly created scene graph instance to the collection of graphs 
            </summary>
            <param name="sceneGraph">exisisting instance of scene graph</param>
            <remarks><para>This overload may be used to add user defined graphs to 
            the collection of graphs in order to use them in ILPanels. The user 
            defined graph needs to derive from scene graph. It may uses all shapes 
            compatible with ILSceneGraph. (ILLine,ILPolygon,ILLitBox,ILQuads,ILTriangles, etc...)
            </para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddImageSCGraph(ILNumerics.ILInArray{System.Single})">
            <summary>
            Add a new imagesc graph to collection
            </summary>
            <param name="data">matrix holding data to be drawn</param>
            <returns>newly created graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddLineGraph(ILNumerics.ILInArray{System.Double})">
            <summary>
            Add line graph(s)
            </summary>
            <param name="data">vector or matrix with date to be plotted. For matrices, the columns will be used to create new graphs.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddLineGraph(ILNumerics.ILInArray{System.Single})">
            <summary>
            Add line graph(s)
            </summary>
            <param name="data">vector or matrix with date to be plotted. For matrices, the columns will be used to create new graphs.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddLineGraph(ILNumerics.ILInArray{System.Double},ILNumerics.ILInArray{System.Double})">
            <summary>
            Add X/Y line graph(s)
            </summary>
            <param name="X">X coordinates. If this is a matrix, every column provides data for an individual graph.</param>
            <param name="Y">Y coordinates. Same size as 'X'.</param>
            <returns>newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddLineGraph(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            Add X/Y line graph(s)
            </summary>
            <param name="X">X coordinates. If this is a matrix, every column provides data for an individual graph.</param>
            <param name="Y">Y coordinates. Same size as 'X'.</param>
            <returns>newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot2DGraph(ILNumerics.ILInArray{System.Single})">
            <summary>
            [Depricated] Add new line graph(s) (2D) to collection
            </summary>
            <param name="data">vector/array with date to be plotted. For arrays, the columns will be used.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.AddPlot2DGraph(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            [Depricated] Add new X/Y 2D line graph(s), provide X and Y coordinates
            </summary>
            <param name="X">X coordinates. If this is a matrix, every column will produce an individual graph.</param>
            <param name="Y">Y coordinates. Same size than 'X'.</param>
            <returns>Array of newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Add(ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.GraphType)">
            <summary>
            Add new numeric graph(s) of arbitrary (math) type
            </summary>
            <param name="data">data to be plotted</param>
            <param name="properties">determine GraphType</param>
            <returns>List with newly created graph(s)</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Add(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.GraphType)">
            <summary>
            Add new graph(s) of arbitrary type, provide both axis data
            </summary>
            <param name="xData">x coordinates </param>
            <param name="graphType">type of graph to be added</param>
            <param name="yData">y coordinates</param>
            <returns>List with newly created graph(s)</returns>
            <remarks>The return value will be a list of all graphs created (and added),
            since more than one graph may have been specified. This depends on the 
            shape of the data provided.
            <para>Currently only Plot2D graphs are supported as GraphType! </para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the data provided are nor 
            numeric or the size for one of the arrays <typeparamref name="xData"/> or <typeparamref name="yData"/> 
            do not match. </exception>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILGraphCollection.Remove(ILNumerics.Drawing.Graphs.ILGraph)">
            <summary>
            Remove a graph from the collection and rescale data limits
            </summary>
            <param name="key">key of graph to be removed</param>
            <returns>the ILGraph removed or null, if the key does not exist</returns>
            <remarks>If the graph has been removed, the clipping data will be updated and a change event will be fired. </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILGraphCollection.Limits">
            <summary>
            Clippping volume for data in all graphs of the collection
            </summary>
            <remarks>This gives back the real ILClippingData object (no copy)</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILLightCollection">
            <summary>
            collection of 8 lights, individual configurable
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILLightCollection.Enabled">
            <summary>
            set: enable/disable all lights; get: return true, if at least one light is enabled, false else 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILLightCollection.Item(System.Int32)">
            <summary>
            get light at specific index
            </summary>
            <param name="i">index of light, valid: 0...7</param>
            <returns>Light at index i</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILSubfigureCollection">
            <summary>
            Collection of all subfigures contained in an ILFigureControl
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.#ctor">
            <summary>
            create new ILSubfigureCollection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Add(System.Int32,ILNumerics.Drawing.ILSubfigure)">
            <summary>
            Add subfigure to subfigure collection
            </summary>
            <param name="key">the key to identify the new subfigure</param>
            <param name="subfigure">the new subfigure</param>
            <remarks>If a subfigure with the key already exist in the collection, 
            it will be replaced by the new subfigure</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Contains(System.Int32)">
            <summary>
            Determine if a subfigure with the key given exist
            </summary>
            <param name="key">key of subfigure</param>
            <returns>true if a subfigure with the given key exists, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILSubfigureCollection.Purge(System.Int32)">
            <summary>
            Reduce the number of subfigures to the given number
            </summary>
            <param name="number">number of subfigures to remain</param>
            <remarks>If more than number subfigures exist, they will be removed. Highest keys will be removed first.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Item(System.Int32)">
            <summary>
            Get / set subfigure by key
            </summary>
            <param name="key">key of subfigure</param>
            <returns>subfigure specified by key</returns>
            <value>subfigure to be stored into the collection</value>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Count">
            <summary>
            number of subfigures currently stored in the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Keys">
            <summary>
            get all keys for all subfigures as key collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILSubfigureCollection.Figures">
            <summary>
            Get all subfigures as value collection
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Collections.ILTickCollection">
            <summary>
            List of labeled ticks for an axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILLabelingElement">
            <summary>
            Base class for text elements 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.#ctor(ILNumerics.Drawing.ILPanel,System.Drawing.Font,System.Drawing.Color)">
            <summary>
            [abstract] Create a new labeling element 
            </summary>
            <param name="panel">panel hosting the element</param>
            <param name="font">default font for the element</param>
            <param name="color">default color for the element</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.#ctor(ILNumerics.Drawing.ILPanel,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.CoordSystem)">
            <summary>
            [abstract] Create a new labeling element 
            </summary>
            <param name="panel">panel hosting the element</param>
            <param name="font">default font for the element</param>
            <param name="color">default color for the element</param>
            <param name="coordSystem">world / screen rendering method</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.Dispose">
            <summary>
            Dispose off this element's ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.m_renderer_CacheCleared(System.Object,System.EventArgs)">
            <summary>
            if the renderer cleares its cache, the expression needs to be re-interpreted
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size,System.Drawing.Point@)">
            <summary>
            add offset to an existing point according to internal alignment
            </summary>
            <param name="size">size of content to be aligned</param>
            <param name="point">original point</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size)">
            <summary>
            return offset according to current setting of m_alignment
            </summary>
            <param name="size">size of an element to align</param>
            <returns>offset according to Alignment property</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.offsetAlignment(System.Drawing.Size,System.Drawing.Point)">
            <summary>
            return offset according to current setting of m_alignment
            </summary>
            <param name="size">size of an element to align</param>
            <param name="p">point inside rectangle of size 'size'</param>
            <returns>offset according to Alignment property</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabelingElement.interprete(System.String)">
            <summary>
            interprete the expression and cache render queue
            </summary>
            <param name="expression"></param>
        </member>
        <member name="E:ILNumerics.Drawing.Labeling.ILLabelingElement.Changed">
            <summary>
            fires when an element's property has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Size">
            <summary>
            Size of the label for rendering, regardless of orientation
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Color">
            <summary>
            color used to display the element
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Font">
            <summary>
            Get/set system font used to draw the text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Orientation">
            <summary>
            Get the orientation for the labeling element or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Anchor">
            <summary>
            Get/set the relative offset of the 'Position' point rel. to the overall label size, range 0..1 for X and Y 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Interpreter">
            <summary>
            Text interpreter used to transform labeling source into bitmap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Renderer">
            <summary>
            device dependent renderer, used to draw the labeling bitmap onto panel
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabelingElement.Text">
            <summary>
            Get / set the text expression defining the content to be displayed 
            </summary>
            <remarks><para>The expression may contain markups according to 
            the specific interpreter instance.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.OnChange">
            <summary>
            fires the change event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.OnLabeledTickAdding(System.Single@,System.String@,System.Int32)">
            <summary>
            fires LabeledTickAdding event
            </summary>
            <param name="value">existing value</param>
            <param name="label">existing label</param>
            <param name="index">index of new tick in collection</param>
            <returns>true: a registrar requested to cancel the adding, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.AxisNames)">
            <summary>
            creates new ILTickCollection
            </summary>
            <param name="axisName"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Clear">
            <summary>
            Clear the collection of labeled ticks
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Replace(System.Collections.Generic.List{System.Single})">
            <summary>
            replace current collection of labeled ticks with a new one
            </summary>
            <param name="ticks"></param>
            <remarks>This will fire a Change event.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Add(System.Single,System.String)">
            <summary>
            Add a labeled tick to the ticks collection.
            </summary>
            <param name="value">current position</param>
            <param name="label">current value</param>
            <remarks>This function will fire the LabeledTickAdding event. This 
            gives users the chance to modify the tick and/or the label before 
            it gets added. She can also cancel the adding for the tick at all. <br/>
            No Change event for the axis will be fired from this method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.Add(System.Single)">
            <summary>
            Add a labeled tick to the ticks collection
            </summary>
            <param name="value">position for tick</param>
            <remarks>No Change event will be fired</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.CreateAuto(System.Single,System.Single,System.Int32)">
            <summary>
            fill (replace) labels with nice labels for range  
            </summary>
            <param name="min">lower limit</param>
            <param name="max">upper limit</param>
            <param name="tickCount">maximum number of ticks</param>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabels(System.Single,System.Single,System.Int32,ILNumerics.Drawing.TickLabelRenderingHint)">
            <summary>
            Determine nice looking label positions for range specified
            </summary>
            <param name="min">lower limit</param>
            <param name="max">upper limit</param>
            <param name="numMaxLabels">maximum number of labels </param>
            <param name="format">format string used to convert numbers to strings</param>
            <param name="hint">rendering hint, specifies preferred method</param>
            <returns>list of tick labels</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabelsAuto(System.Single,System.Single,System.Int32,System.String)">
            <summary>
            Create nice labels, prefere even numbers over best optimal tick count
            </summary>
            <param name="min">min</param>
            <param name="max">max</param>
            <param name="numMaxLabels">max labels count</param>
            <param name="format">format string used to convert numbers to strings</param>
            <returns>nice label list</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.NiceLabelsFill(System.Single,System.Single,System.Int32)">
            <summary>
            find tick labels by distinct divisors (10,5,2). Chooses the divisor which best produces the best number according to numberTicks
            </summary>
            <param name="min">minimum</param>
            <param name="max">maximum</param>
            <param name="numberTicks">maximum number of ticks</param>
            <param name="format">format string for string conversion</param>
            <returns>list of tick labels</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.niceNumber(System.Double,System.Boolean)">
            <summary>
            create "nice" number in fractions of 2 or 5
            </summary>
            <param name="value">value</param>
            <remarks>This code was adopted from Paul Heckbert
            from "Graphics Gems", Academic Press, 1990. </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.GetEnumerator">
            <summary>
            Get Enumerator, enumerating over all labeled ticks
            </summary>
            <returns>Enumerator</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Collections.ILTickCollection.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Get enumerator enumerating over labeled ticks
            </summary>
            <returns>enumerator</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Collections.ILTickCollection.Changed">
            <summary>
            Fires, when the collection of ticks has changed 
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Collections.ILTickCollection.LabeledTickAdding">
            <summary>
            fires, if a new labeled tick is about to be added to the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.TicksAllowOverlap">
            <summary>
            determine the max number of pixels allowing a tic labels to be rendered inside the padding area of the next label 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.RenderingHint">
            <summary>
            Get the prefered placement for tick labels or sets it
            </summary>
            <remarks>Tick labels will not stricly rely on this setting, but rather 
            try to find the optimal tick positions depending on the current 
            rendering situation, taking the hint into account.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Mode">
            <summary>
            Positioning mode for ticks ([Auto],Manual)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.NearColor">
            <summary>
            get / set the color for near ticks (label side)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.FarColor">
            <summary>
            get / set the color for backside ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.LabelColor">
            <summary>
             Get/ set the default color for tick labels 
            </summary>
            <remarks>The color may be overwritten for individual labels</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Padding">
            <summary>
            padding between ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Precision">
            <summary>
            number of digits to be displayed in axis ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Display">
            <summary>
            Get/ set which sides ticks for axis will be displayed on
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Direction">
            <summary>
            How ticks are displayed (inside/outside)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.TickFraction">
            <summary>
            length for ticks, fraction of the overall axis length. Default: 0.02
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Count">
            <summary>
            Number of ticks currently stored into the collection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Axis">
            <summary>
            The axis this tick collection is assigned to
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Collections.ILTickCollection.Size">
            <summary>
            Get maximum size of 
            all tick labels in pixels on screen
            </summary>
            <remarks>This property does not take the orientation into account. The size 
            of the content will be returned as if the orientation was straight horizontally.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Controls.DummyNamespaceClass">
            <summary>
            this class is for downward compatibility reasons only. It serves no functionality and will silently be removed in the future
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILBorderFitLabel">
            <summary>
            Label with flexible configurable orientation of it's text 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILMovingDockPanel">
            <summary>
            Label with flexible configurable orientation of it's text 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMovingDockPanel.BackgroundGradientStrength">
            <summary>
            Intensity of lighting / darkner effect for background color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMovingDockPanel.BackgroundGradientDeg">
            <summary>
            orientation for background gradient effect
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMovingDockPanel.Orientation">
            <summary>
            set the orientation of text (Horizontal/Vertical)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILMovingDockPanel.StandardOrientation">
            <summary>
            The type of orientation (hor./ vert) if the control is not docked
            </summary>
            <remarks>Setting this value will not alter the way the display is
            currently drawn until the control returns from a docked state the next time.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILMovingDockPanel.IsMoving">
            <summary>
            True, if the control is currently moved around by the user
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBorderFitLabel.Caption">
            <summary>
            The labels text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBorderFitLabel.VerticalAlign">
            <summary>
            vertical alignment for the text
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILBorderFitLabel.HorizontalAlign">
            <summary>
            horizontal alignment for the text
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorBar.RegisterRangeSource(ILNumerics.Drawing.ILClippingData)">
            <summary>
            register clipping range object as source for range and its changes
            </summary>
            <param name="clipping">clipping data object</param>
            <returns>true, if the source was registered successfully</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorBar.Update(System.Single,System.Single,ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            update range for color bar, supply color provider
            </summary>
            <param name="minValue">min value</param>
            <param name="maxValue">max value</param>
            <param name="colorProvider">color provider (not implemented)</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILColorBar.Update(System.Single,System.Single)">
            <summary>
            update data range for the color bar
            </summary>
            <param name="minValue">min value</param>
            <param name="maxValue">max value</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILColorBar.Colormap">
            <summary>
            Colormap used to translate colors indices
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILColorBar.TickLabelsPadding">
            <summary>
            padding (in pixels) between the tick labels 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILColorBar.Precision">
            <summary>
            Number of digits to be displayed for values 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILColorBar.MinValue">
            <summary>
            get / set minimum value for the values range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILColorBar.MaxValue">
            <summary>
            get / set maximum value for the values range
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILPanel">
            <summary>
            Basic abstract base class for GL dependent display.
            </summary>
            <remarks>This control is the main plot control of ILNumerics.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILPanel.m_plotBoxScreenRectF">
            <summary>
            pixel size of the current PlotCubeScreenRectangle
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Dispose">
            <summary>
            Dispose this panel, frees all devices, graph- and axis collection
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Dispose(System.Boolean)">
            <summary>
            dispose this panel
            </summary>
            <param name="disposing">manual disposing</param>
            <remarks>derived classed (ILDXPanel,ILOGLPanel) free their resources here</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Refresh">
            <summary>
            causes the panel to redraw
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.GetDeviceContext">
            <summary>
            Get current rendering device (implementation dependent)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Invalidate">
            <summary>
            Causes a reconfiguration of all axes and graphs on the next paint event
            </summary>
            <remarks>Call this method after any changes to vertex relevant data. It causes all drawable objects to clear their caches and recalculate all vertex data.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.ResetView">
            <summary>
            update viewing limits to show all data, rotate the scene to default (-> DefaultView)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.ResetView(System.Boolean)">
            <summary>
            update viewing limits to show all data, optionally reset the scene rotation
            </summary>
            <param name="resetRotation">true: rotate the scene to the default (-> DefaultView)</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            Move &amp; shrink/expand current view cube along a given line
            </summary>
            <param name="nearLineEnd"></param>
            <param name="farLineEnd"></param>
            <param name="offset"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            move the center of the viewing cube and expand / shrink the volume by offset
            </summary>
            <param name="center">new center</param>
            <param name="offset">offset multiplicator, 1f means: no change</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Zoom(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Zoome the scene to new limits
            </summary>
            <param name="luCorner">'upper left' (first) corner of the new viewing cube</param>
            <param name="rbCorner">'bottom right' (opposed) corner of the viewing cube</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Transform two coordinates for a line from world to screen coordinates
            </summary>
            <param name="start">1st coordinate (world)</param>
            <param name="end">2nd coordinate (world)</param>
            <param name="start2D">[output] 1st coordinate (screen pixels)</param>
            <param name="end2D">[output] 2nd coordinate (screen pixels)</param>
            <remarks>This function is provided by the concrete derived class, using the
            current rendering framework.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Screen2World2D(System.Int32,System.Int32)">
            <summary>
            Transform from a point on screen into world coordinates [depricated]
            </summary>
            <param name="x">screen x</param>
            <param name="y">screen y: GL viewport coord! -> (0,0) is lower left corner!</param>
            <returns>world coordinate point</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Screen2World(System.Int32,System.Int32,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            gives the line in world coords, a specific point on screen lays on
            </summary>
            <param name="x">screen x</param>
            <param name="y">screen y: GL viewport coord! -> (0,0) is lower left corner</param>
            <param name="farClip">far end point of the resulting line in world coords</param>
            <param name="nearClip">near end point of the resulting line in world coords</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Transform world coordinate to screen coordinate under current transformation
            </summary>
            <param name="worldPoint">world coordinate</param>
            <returns>screen location</returns>
            <remarks>the actual transform is carried out in the derived specialized class,
            where the current transformation matrices are known</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,System.Double[])">
            <summary>
            Transform world coordinate to screen coordinate, provide (custom) modelview matrix
            </summary>
            <param name="worldPoint"></param>
            <param name="modelview">(custom) model view matrix. The parameter must match the format required by the deriving concrete ILPanel class. ILOGLPanel: double[16]</param>
            <returns>screen location</returns>
            <remarks>the actual transform is carried out in the derived specialized class,
            where the current transformation matrices are known</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Draws content of this subfigure into predefined bitmap
            </summary>
            <param name="bitmap">predefined bitmap to draw content into. The size must have been initialized according to 'bounds'.</param>
            <param name="bounds">Rectangle specifying the region to be copied.</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.drawSelectionRect(System.Drawing.Point)">
            <summary>
            draws the selection rectangle with GDI functions
            </summary>
            <param name="endPoint">end point</param>
            <remarks>The start point is stored in the member m_mouseStart.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Configure">
            <summary>
            [internal] Configure this panel, to make it ready for output, set "m_ready = true" at end!
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.iRenderingState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw the scene: all axes, graphs, background etc. (device dependant)
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Initialize">
            <summary>
            initialize all device specific classes, first called after the panel has been created
            </summary>
            <remarks>derived types should init all devices here</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.GetTransformedSize(System.Single@,System.Single@,System.Single@)">
            <summary>
            Get size of projected view cube - after (!) rotation but before projection -> world space
            includes the bounding box, tightly enclosing the current view limits setting 
            No labels, No ticks included!! Just the data cube with roatation!
            </summary>
            <param name="x">out, screen size for X</param>
            <param name="y">out, screen size for Y</param>
            <param name="z">out, screen size for Z</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.updatePlotCubeScreenRect(System.Single,System.Single,System.Drawing.Size)">
            <summary>
            calculate the real pixels of the plot cube rectangle for drawing into
            </summary>
            <param name="xSize"></param>
            <param name="ySize"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Create">
            <summary>
            create OpenGL panel 
            </summary>
            <returns>OpenGL panel</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.Create(ILNumerics.Drawing.GraphicDeviceType)">
            <summary>
            create graphic device specific panel 
            </summary>
            <param name="type">specify GL type. Supported are: OpenGL (recommended) or Direct3D (alpha state)</param>
            <returns>GL specific panel</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPanel.GetCreationFactory">
            <summary>
            Create GL dependend graph factory 
            </summary>
            <returns>ILGraphFactory,will be used for creating all graphs</returns>
            <remarks>derived types may return GL dependend factory</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.AspectRatio">
            <summary>
            Determines how the projected data plots are mapped to PlotCubeScreenRectF
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.PlotBoxScreenRect">
            <summary>
            the normalizes projected size (range 0..1) of plot cube on 2D client area, set: sets PlotCubeScreenMode -> Manual
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.PlotBoxScreenSizeMode">
            <summary>
            options for determining the size of the plot cube on the 2D screen client area, default: optimal
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Lights">
            <summary>
            Access collection of lights for configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Legend">
            <summary>
            Legend for panel's graphs
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.TextureManager">
            <summary>
            Get texture manager instance, storing all textures used in the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Colormap">
            <summary>
            Colormap used to translate color indices into true colors
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.BackgroundFilled">
            <summary>
            Determines if background of the rendering cube will be filled with the CubeBackgroundColor property value
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.DrawInactive">
            <summary>
            true: the control will always be drawn, even if it does not own the focus
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.BackColorCube">
            <summary>
            Get/set the background color for the inner cube drawing 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Limits">
            <summary>
            View settings, get access to the clipping limits for all axises 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.GraphicDeviceType">
            <summary>
            Get the type of device currently used for rendering
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.SelectionRectangle">
            <summary>
            Get/set properties for selection rectangle, drawn when zooming with the mouse
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.BackColor">
            <summary>
            color of the figure background
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Projection">
            <summary>
            type of projection: orthographic (default) or perspective
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Camera">
            <summary>
            Get or set viewport properties (distance &amp; angles)
            </summary>
            <remarks>Changing </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.InteractiveMode">
            <summary>
            Get the current mode for mouse interaction or set's it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Graphs">
            <summary>
            Gives all graphs as value collection (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.Axes">
            <summary>
            Get axes collection - holds all 3 axes
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.ClipViewData">
            <summary>
            (experimental) content for graphs will be clipped outside the unit cube
            </summary>
            <remarks>For 2D plots, not clipping the vertex data may lead to hiding 
            the labels drawn next to axes. For 3D plots Clipping may cause unexpected behavior. 
            <para>Therefore Clipping will be activated for 2D plots by default and 
            deactivated for 3D plots by default.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.TextRendererManager">
            <summary>
            Manager providing collection of available IILTextRenderer types
            </summary>
            <remarks>IILTextRenderer are used to draw labels for axis of this panel (device specific).
            <para>Text renderer objects must be instantiated through the ILTextRendererManager instance's
            CreateInstance() method.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.DefaultView">
            <summary>
            Get or set default camera position for reset of the scene
            </summary>
            <remarks>The default position is used when the scene is reset. That
            reset is usually triggered by double clicking the panel with the mouse.
            <para>setting this value to null will make the panel ignore any double
            clicks, which enables the user to manually react to double click via the 
            common DoubleClick event of the panel and reset the camera position from
            outside the component.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.AutoZoomContent">
            <summary>
            Options for the view cube adapting data limit changes 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.ZoomMode">
            <summary>
            choose the ramp for zooming
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILPanel.ZoomOffset">
            <summary>
            How much the view cube will be shrinked/expanded on zooming operations (percent)
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.DataLimitsChanged">
            <summary>
            fired, if the data limits of any graphs changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.ViewLimitsChanged">
            <summary>
            fired, if the clipping rectangle for viewing graphs changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.ColormapChanged">
            <summary>
            fires, if the current colormap has changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.GraphicsDeviceReset">
            <summary>
            fired, if the internal graphics device reset (Direct3D devices only)
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILPanel.GraphicsDeviceCreated">
            <summary>
            fired, if the internal graphics device has been (re)created
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILSubfigure">
            <summary>
            Plot control, provides ILPanel, colorbar and title
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILSubfigure.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Draws content of this subfigure into predefined bitmap
            </summary>
            <param name="bitmap">predefined bitmap to draw content into. The size must have been initialized according to 'bounds'.</param>
            <param name="bounds">Rectangle specifying the region to be copied.</param>
        </member>
        <member name="P:ILNumerics.Drawing.ILSubfigure.Panel">
            <summary>
            Gives access to the panel of the figure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSubfigure.ColorBar">
            <summary>
            Gives access to the colorbar of the figure
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILSubfigure.Title">
            <summary>
            Gives the title control
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILFilledGraph">
            <summary>
            Class representing abstract implementation of filled graphs
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILGraph">
            <summary>
            graph for drawings into ILPanel
            </summary>
            <remarks>Use the ILGraphCollection returned from ILPanel.Graphs and its Add... functions to create new graphs.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Configure">
            <summary>
            configures all parameters + cache, called before drawing
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Invalidate">
            <summary>
            invalidate and recalculate this graphs data, this must be called after changes to relevant graph properties
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the graph into the panel
            </summary>
            <param name="p">extended drawing properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Dispose">
            <summary>
            clear ressources of the graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILGraph.Is3DGraph">
            <summary>
            determine general type of graph (2D/3D) 
            </summary>
            <returns>true for 3D graphs (e.g. surf, scene graph) and false for 2D graphs (plot2D)</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Label">
            <summary>
             the label of the graph (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Limits">
            <summary>
            data limits of the graphs current data (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Type">
            <summary>
            The type of graph (Plot2D, Surf, ImageSC, ...)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILGraph.Panel">
            <summary>
            The hosting panel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.Drawing.ILClippingData)">
            <summary>
            construct new filled graph
            </summary>
            <param name="panel">panel hosting the graph</param>
            <param name="X">X coords, if null, range 0..[cols of Z] will be created</param>
            <param name="Y">Y coords, if null, range 0..[rows of Z] will be created</param>
            <param name="Z">Z coords (heights)</param>
            <param name="C">Colors for Z</param>
            <param name="clippingContainer">gloabal limits of panel</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.CreateIndices">
            <summary>
            Create indices for filled graphs
            </summary>
            <remarks>Indices will be ordered to assemble individual triangles.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.checkVertexIndicesLength(System.Int32,System.Int32)">
            <summary>
            checks the length of index vector and allocate more memory if needed
            </summary>
            <param name="vertStrCount">Number of stripes to be drawn</param>
            <param name="vertStrLen">Number of indices for each stripe</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.checkGridIndicesLength(System.Int32,System.Int32)">
            <summary>
            checks the length of grid index vector and allocate more if needed
            </summary>
            <param name="gridStrCount">Number of stripes to be drawn</param>
            <param name="gridStrLen">Number of indices for each stripe</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.Dispose">
            <summary>
            Dispose off this filled graph (grid-)indices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILFilledGraph.Configure">
            <summary>
            checks &amp; if neccessary triggers recreation of all vertices and indices
            </summary>
            <remarks>This function is called by the enclosing panel, e.g. when rotation
            occours, which makes a reconfiguration neccessary. It internally calls CreateVertices() 
            and CreateIndices().</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Wireframe">
            <summary>
            Wireframe line properties
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Opacity">
            <summary>
            Get / set the transparency for the graph (percent)
            </summary>
            <remarks>1.0f (opaque) ... 0.0f (transparent)</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Filled">
            <summary>
            Determine, if the tiles (rectangle areas between data points) 
            constructing the surface will be filled or invisible
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILFilledGraph.Data">
            <summary>
             get a reference to the internal data array
            </summary>
            <remarks>modifications to the array returned will 
            <b>not</b> alter the data the graph is based on.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILImageSCGraph">
            <summary>
            class rendering plain color-coded area graphs
            </summary>
            <remarks>This class derives from ILFilledGraph and adds a ZPosition property.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILLegendRenderer.DrawToLegend(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            Draws a small example of the visual output 
            </summary>
            <param name="p">Extended render properties</param>
            <param name="sampleArea">Area to draw the line + marker into</param>
            <param name="labelArea">Area to draw corresponding label into</param>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILLegendRenderer.LabelSize">
            <summary>
            Size of text label
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILPanelConfigurator.ConfigurePanel(ILNumerics.Drawing.ILPanel)">
            <summary>
            Implemented by custom graph objects, configures the hosting panel according to requirements of specific plot type
            </summary>
            <param name="panel">the panel to be configured</param>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILImageSCGraph.ZPosition">
            <summary>
            Z position for ImageSC graph (default: -Inf)
            </summary>
            <remarks>The position of the ImageSC plane is specified by a Z coordinate.
            The coordinate can set to the following values: 
            <list type="bullet">
            <item>any single precision value, will position the plane on that specific value</item>
            <item><i>negative infinity</i>, will position the plane on the bottom of the viewing cube</item>
            <item><i>positive infinity</i>, position the plane on top of the unit cube.</item></list>
            </remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILPlot2DGraph">
            <summary>
            2D line &amp; point graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Invalidate">
            <summary>
            Invalidate the graph after vertex data have been changed.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.DrawToLegend(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
            draws a small example of the visual output 
            </summary>
            <param name="p">render properties</param>
            <param name="sampleArea">area to draw the line + marker into</param>
            <param name="labelArea">area to draw corresponding label into</param>
            <remarks>derived classes implement this for current device contexts</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILArray{System.Single},ILNumerics.Drawing.ILClippingData)">
            <summary>
            [internal] constructor - do not use this! Use ILPanel.Graphs.Add...() instead!
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="sourceArray">data array</param>
            <param name="clippingContainer">hosting panels clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.Drawing.ILClippingData)">
            <summary>
            [internal] constructor - do not use this! Use ILPanel.Graphs.Add...() instead!
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="XData">x data array</param>
            <param name="YData">y data array</param>
            <param name="clippingContainer">hosting panels clipping data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.m_marker_Changed(System.Object,System.EventArgs)">
            <summary>
            called, if a property for markers have changed
            </summary>
            <param name="sender">this graph instance</param>
            <param name="e">(no args)</param>
            <remarks>derived classes should override this function in order to 
            (re-)configure vertex ressources etc.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILPlot2DGraph.m_properties_Changed(System.Object,System.EventArgs)">
            <summary>
            called, if a property for lines have changed
            </summary>
            <param name="sender">this graph instance</param>
            <param name="e">(no args)</param>
            <remarks>derived classes should override this function in order to 
            (re-)configure vertex ressources etc.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.AutoLimitsUpdateCount">
            <summary>
            number of subsequent updates ('Queue') before limits get recalculated. Default: 0 (recalculate on every update)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Line">
            <summary>
            Get properties of lines
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Marker">
            <summary>
            Get properties of markers
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.Vertices">
            <summary>
            access to internal vertex array
            </summary>
            <remarks><para>after altering vertex data, one must call 
            Invalidate() to signal those changes.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILPlot2DGraph.LabelSize">
            <summary>
            Size of label
            </summary>
            <value>size</value>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraph">
            <summary>
            The class implements a scene graph (tree), capable 
            of holding, managing and drawing all kinds of shapes.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.ILClippingData)">
            <summary>
            (internal) create new scene graph 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="clipping">clipping data object, usually member of the panel</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Is3DGraph">
            <summary>
            Determines if this graph renders in 3D, may overridden in derived class
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) draws the whole scene graph
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.Configure">
            <summary>
            (internal use) configures and prepares the scene graph for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            add new node to root node
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Shapes.ILShape)">
            <summary>
            add a shape to the root node
            </summary>
            <param name="shape"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.AddNode(ILNumerics.Drawing.Graphs.ILSceneGraphNode,ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode)">
            <summary>
            add new node as child of another node
            </summary>
            <param name="node"></param>
            <param name="parent"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraph.GetAllShapes">
            <summary>
            collect all shapes contained in any scene graph nodes
            </summary>
            <returns></returns>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraph.NodeAdded">
            <summary>
            fires, once somewhere in the graph a node was added
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraph.Root">
            <summary>
            root node of the scene graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode">
            <summary>
            scene graph inner node, collection of children
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphNode">
            <summary>
            abstract base class for all scene graph nodes
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.EventingSuspend">
            <summary>
            stop firing events from this node
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.EventingResume">
            <summary>
            resume firing events from this node
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Invalidate">
            <summary>
            invalidate geometry cache for this and all nodes up to root
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw all children contained in this node
            </summary>
            <param name="props">extended rendering properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.GetEnumerator">
            <summary>
            Create &amp; returns a typed enumerator
            </summary>
            <returns>enumerator of all scene graph nodes below this node</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphNode.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Create and return untyped enumerator
            </summary>
            <returns>IEnumerator of all scene graph nodes below this node</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraphNode.SizeChanged">
            <summary>
            fires when the size of the cube tigthly enclosing the shape has changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Invalidated">
            <summary>
            fires when the (size)cache of the node was invalidated
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Visible">
            <summary>
            Get/set visiblility for the scene graph branch 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Parent">
            <summary>
            reference to the scene graph node this node is a child of
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.PositionMin">
            <summary>
            the minimum coordinate of a cube tightly enclosing the node (and all childs) 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.PositionMax">
            <summary>
            the maximum coordinate of a cube tightly enclosing the node (and all childs) 
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphNode.Center">
            <summary>
            current geometric center according of scene graph branch
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Add(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            add a single node to the end of child collection
            </summary>
            <param name="item">node to add </param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Clear">
            <summary>
            wipe all nodes from the collection 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Contains(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            Determine, if this collection contains a specific node item
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Remove(ILNumerics.Drawing.Graphs.ILSceneGraphNode)">
            <summary>
            remove a single child node from the collection
            </summary>
            <param name="item">node to be removed</param>
            <returns>true</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Count">
            <summary>
            Number of children contained in this node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.IsReadOnly">
            <summary>
            determine if this collection is readonly, (returns 'false')
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphInnerNode.Computation.GetSortedIndices(ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            compute distance to camera and return sorted indices for rendering
            </summary>
            <param name="centers">current primitive centers</param>
            <param name="position">current camera position</param>
            <returns>sorted indices of primitives in descending order</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphRoot">
            <summary>
            the root node of every scene graph (internal use only) 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf">
            <summary>
            a scene graph node, holding a single shape
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create a new shaped leaf
            </summary>
            <param name="panel"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Invalidate">
            <summary>
            invalidate this and all nodes up to root
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Invalidate(System.Boolean)">
            <summary>
            invalidate this node and all nodes up to root
            </summary>
            <param name="invalidateShape">true: invalidate the shape also</param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Configure">
            <summary>
            recompute the size spanned by this node, may fires Changed() event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draw this shape contained in this node (internal use)  
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.ComputeNodeLimits">
            <summary>
            compute limits of the cube tightly enclosing the branch below this node
            </summary>
            <returns></returns>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Shape">
            <summary>
            Get / set the shape of the scene graph node
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.PositionMin">
            <summary>
            the minimum position of contained shape 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.PositionMax">
            <summary>
            the maximum position of contained shape 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSceneGraphShapedLeaf.Center">
            <summary>
            the computed center of contained shape 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Graphs.ILSurfaceGraph">
            <summary>
            Surface graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSurfaceGraph.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.ILArray{System.Single},ILNumerics.Drawing.ILClippingData)">
            <summary>
            construct new surface graph, provide all 3 coordinates
            </summary>
            <param name="panel">panel this graph is to be hosted in</param>
            <param name="X">X coordinates</param>
            <param name="Y">Y coordinates</param>
            <param name="Z">Z coordinates</param>
            <param name="C">Color values</param>
            <param name="clippingContainer"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Graphs.ILSurfaceGraph.CreateIndices">
            <summary>
            create indices for ILSurfaceGraph triangles 
            </summary>
            <remarks>If possible, the indices will assemble triangle strips. If not -
            the base implementation will be used to create individual triangles.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Graphs.ILSurfaceGraph.Shading">
            <summary>
            determine, how the color for surface tiles will be drawn
            </summary>
            <remarks>Interpolated will interpolate the color for the 
            tiles between all corner data points. Flat will draw the area of the 
            tile in a single color. The color than reflects the average value of 
            all corner data points.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILCreationFactory">
            <summary>
            interface for a painter factory, capable of creating device dependend axes and graphs 
            </summary>
            <remarks>The interface is implemented by (device dependent) panel implementations. 
            It is used to create the ILPanel's object hirarchy on startup. </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateAxis(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,System.Object[])">
            <summary>
            create an axis 
            </summary>
            <param name="name">axis name</param>
            <param name="clippingView">clipping of the host</param>
            <param name="parameters">additional parameters</param>
            <returns>newly created axis object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateGraph(ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.GraphType,ILNumerics.ILArray{System.Single}[])">
            <summary>
            Create a new specific ILGraph object (device dependent)
            </summary>
            <param name="data">numeric data for the new graph</param>
            <param name="graphType">type of graph</param>
            <param name="additionalParams">additional parameter</param>
            <returns>newly created graph instance</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateSceneGraph">
            <summary>
            create a new device dependant scene graph
            </summary>
            <returns>scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILCreationFactory.CreateVertexRenderer(System.Type,ILNumerics.Drawing.Shapes.ILShape)">
            <summary>
            create vertex renderer for rendering arbitrary vertices. 
            </summary>
            <param name="vertexType">underlying vertex type (value type)</param>
            <returns>vertex renderer</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILTextInterpreter">
            <summary>
            interface for classes capable of transforming text 
            expressions into visual output representation
            </summary>
            <seealso cref="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter"/>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextInterpreter.Transform(System.String,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.Interfaces.IILTextRenderer)">
            <summary>
            transform text element (text) into bitmap for rendering
            </summary>
            <param name="expression">item text expression, defines the visual output content</param>
            <param name="font">font used for rendering the text</param>
            <param name="color">initial color, unless overridden, used for items in expression</param>
            <param name="renderer">IILTextRenderer implementation, used for caching the element(s)</param>
            <returns>renderer queue, contains item keys and the size of transformed item expression</returns>
            <remarks>The implementation should use the general caching capabilities 
            of the renderer class. Therefore the item's elements must be cached subsequently
            into the renderer before drawing. The render queue returned may be 
            used for rendering in the same renderer than.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILTextRenderer">
            <summary>
            interface for all classes capable of renderung (device 
            dependend) texts into plot panels 
            </summary>
            <remarks>class definitions should also implement the ILRendererAttribute. See <see cref="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer"/> for an example.</remarks>
            <seealso cref="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer"/>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Begin(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            begins drawing, to be called before Draw()!
            </summary>
            <param name="p">extended render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Begin(ILNumerics.Drawing.ILRenderProperties,System.Double[]@)">
            <summary>
            begins drawing and queries current model view matrix also
            </summary>
            <param name="p">extended render properties</param>
            <param name="modelview">current modelviewmatrix</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            Draw the text (screen coords)
            </summary>
            <param name="renderQueue">contains items to be drawn</param>
            <param name="position">position relative to surface, starting point for drawing</param>
            <param name="orientation">orientation for item</param>
            <param name="color">initial or default color</param>
            <remarks>
            	<para>Before calling Draw(), the TextRenderer must have been initialized with Begin(g)!</para>
            	<para>use this function if drawing in screen coords, the size for render
            output will be taken from the Size member of the render queue (pixels).</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">on attempt to draw any text without previous initialization</exception>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Drawing.Color)">
            <summary>
            Draws the text in world coords 
            </summary>
            <param name="renderQueue">contains items to be drawn</param>
            <param name="x1">x1-position</param>
            <param name="y1">y1-position</param>
            <param name="z1">z1-position</param>
            <param name="x2">x2-position</param>
            <param name="y2">y2-position</param>
            <param name="z2">z2-position</param>
            <param name="color">base color for items not containing individual colors</param>
            <remarks>
            <para>Before calling Draw(), the TextRenderer must have been initialized with Begin(g)!</para>
            <para>Use this function to draw the render queue in world coords. The position parameters mark the upper left 
            and lower right corner of the quads to contain the render queue content.</para>
            </remarks>
            <exception cref="T:System.InvalidOperationException">on attempt to draw any text without previous initialization</exception>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.End(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            finalizes the drawing (must prepare it again before drawing!)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Cache single item into the renderer cache. 
            </summary>
            <param name="key">key used to uniquely identify the item in cache</param>
            <param name="bmp">item bitmap data</param>
            <param name="rect">section in bmp to be transfered into the cache</param>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.ExistsKey(System.String)">
            <summary>
            test if an item for a specific key is already cached
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Interfaces.IILTextRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            test if the key exists and return the size of corresponding item on success
            </summary>
            <param name="key">key identifying the item</param>
            <param name="size">if the key was found: the size of the corresponding item</param>
            <returns>true, if the key exist, false otherwise</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.Name">
            <summary>
            The name of the TextRenderer instance (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.NameLong">
            <summary>
            A more descriptive name to be displayed into GUI's (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.DeviceType">
            <summary>
            Get the graphics device type this TextRenderer instance 
            is capable to use for drawing 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.DrawAfterBufferSwapped">
            <summary>
            Determine, if the text is to be drawn after the rendering 
            backbuffer has been swapped and presented to the screen. (implementation dependent)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.Cached">
            <summary>
            Determine, if this renderer chaches the output (implementation dependent) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.CoordSystem">
            <summary>
            Determine the coord system this renderer is specialized to draw in
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILTextRenderer.ColorOverride">
            <summary>
            if set to a color (not Color.Empty), that color will be used for all renderings. 
            The color contained in the rendering queue is ignored than.
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Interfaces.IILTextRenderer.CacheCleared">
            <summary>
            for cached renderers, fires if the internal cache was cleared
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Interfaces.IILVertexDefinition">
            <summary>
            definition of vertex data &amp; properties
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresAlpha">
            <summary>
            determine, if the vertex is able to store individual alpha values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresColor">
            <summary>
            determine, if the vertex is able to store individual color values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.StoresNormals">
            <summary>
            determine, if the vertex is able to store normal data 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Alpha">
            <summary>
            Get/set the alpha value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Color">
            <summary>
            Set the color for the vertex, alpha value is not modified!
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Position">
            <summary>
            get/set position (X,Y,Z values) for the vertex 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.Normal">
            <summary>
            Get/set the normal vector for the value (see also: AutoCalculateNormals) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.XPosition">
            <summary>
            get/set the X coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.YPosition">
            <summary>
            get/set the Y coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.ZPosition">
            <summary>
            get/set the Z coordinate value for the vertex
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Interfaces.IILVertexDefinition.VertexSize">
            <summary>
            size of single vertex in bytes
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILHashCreator">
            <summary>
            Helper class used to create hashes for renderable items (currently text only)
            </summary>
            <remarks>This class should be used to retrieve an (unique) key for any 
            renderable items used in ILNumerics.Drawing renderer classes. This way on can 
            ensure not to create hash conflicts between different cached items.
             </remarks>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.Drawing.Labeling.ILHashCreator.Hash(System.Drawing.Font,System.String)" ignoriert -->
        <member name="M:ILNumerics.Drawing.Labeling.ILHashCreator.Hash(System.Drawing.Bitmap)">
            <summary>
            create unique hash for bitmaps
            </summary>
            <param name="bitmap">bitmap</param>
            <returns>unique key identifying the bitmap</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILLabel">
            <summary>
            general label, mainly used for ILAxis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabel.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create a label for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILLabel.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Visible">
            <summary>
            get/set visibility for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Position">
            <summary>
            get/ set the position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Alignment">
            <summary>
            Alignment along the axis value range. Possible values: lower, center, upper
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILLabel.Padding">
            <summary>
            Get/ set the padding used to seperate the label from the elements around it
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRendererAttribute">
            <summary>
            attribute used to identify IILTextRenderer types within assemblies 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.GraphicDeviceType">
            <summary>
            the type of graphic device, the renderer is able to handle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.Name">
            <summary>
            short name describing the renderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.NameLong">
            <summary>
            long name describing the renderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.IsDefault">
            <summary>
            determine, if this renderer should be used as default 
            renderer for the graphic device and the coord system
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRendererAttribute.Coords">
            <summary>
            Detemine the coord system the renderer is based on
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererAttribute.#ctor(ILNumerics.Drawing.GraphicDeviceType,System.String,System.String)">
            <summary>
            Constructor for a new attribute describing non-default renderer
            </summary>
            <param name="type">graphic device type </param>
            <param name="Name">short name</param>
            <param name="NameLong">long name</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererAttribute.#ctor(ILNumerics.Drawing.GraphicDeviceType,System.String,System.String,System.Boolean,ILNumerics.Drawing.CoordSystem)">
            <summary>
            Constructor creating a new renderer attribute
            </summary>
            <param name="type">graphic device type </param>
            <param name="Name">short name</param>
            <param name="NameLong">long name</param>
            <param name="Default">'default' flag</param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRenderQueue">
            <summary>
            the class collects renderable items which define 
            the graphical output for a render expression
            </summary>
            <remarks>ILRenderQueues are semi-immutable. Instances - once created - can only be cleared and 
            re-created, but not altered. Therefore, they keep the size of the output cached over their livetime.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueue.#ctor(System.String,System.Collections.Generic.List{ILNumerics.Drawing.Labeling.ILRenderQueueItem},System.Drawing.Size)">
            <summary>
             constructor, creates a new render queue with content
            </summary>
            <param name="expression">expression, which led to this queue</param>
            <param name="queue">prepared queue</param>
            <param name="size">size of content after rendering</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRenderQueue.Size">
            <summary>
            overall size of content of this render queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRenderQueue.Expression">
            <summary>
            Expression which led to this queue
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRenderQueueItem">
            <summary>
            Single item with rendering instructions, used in ILRenderQueues
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Key">
            <summary>
            unique key, identifies the item in the render cache
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Offset">
            <summary>
            rendering offset for the item (used for sub-/superscripts etc.)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILRenderQueueItem.Color">
            <summary>
            individual color for the item 
            </summary>
            <remarks>If this property is set to Color.Empty, the item will 
            be drawn with the color assigned to hosting element.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueueItem.#ctor(System.String,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            construct a new ILRenderQueueItem
            </summary>
            <param name="key">unique key</param>
            <param name="xOffset">x coordinate for offset</param>
            <param name="yOffset">y coordinate for offset</param>
            <param name="color">individual color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRenderQueueItem.#ctor(System.String,System.Drawing.Point,System.Drawing.Color)">
            <summary>
            construct a new ILRenderQueueItem
            </summary>
            <param name="key">unique key</param>
            <param name="offset">offset</param>
            <param name="color">individual color</param>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILShapeLabel">
            <summary>
            a label used for labeling shapes (screen coords, defined via world coords)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            (internal use)
            </summary>
            <param name="p">render properties</param>
            <param name="center">center position for the label</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.drawFringed(ILNumerics.Drawing.Interfaces.IILTextRenderer,System.Object,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            draws a fringe around the render output in fringe color
            </summary>
            <param name="m_renderer"></param>
            <param name="m_rendererQueue"></param>
            <param name="dest"></param>
            <param name="textOrientation"></param>
            <param name="m_color"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILShapeLabel.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            (internal use)
            </summary>
            <param name="p">render properties</param>
            <param name="min">minimum coord for label area</param>
            <param name="max">maximum coord for label area</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILShapeLabel.FringeColor">
            <summary>
            get/set the color used for drawing a fringe around glyphs, empty: no fringe
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleInterpreter">
            <summary>
            Transforms characters into bitmaps (1:1)
            </summary>
            <remarks>this is the base class for most IILTextInterpreter implementations</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.#ctor">
            <summary>
            create a new instance of this text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.TransformItem(System.String,System.Drawing.Font,System.Drawing.RectangleF@)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="size">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.transformItem(System.String,System.Drawing.Font,System.Drawing.RectangleF@)">
            <summary>
            Render a string onto a bitmap and measure exact size
            </summary>
            <param name="item">item to be rendered</param>
            <param name="font">font used for rendering</param>
            <param name="size">[output] size of the rendered item</param>
            <returns>bitmap containing the item</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String,System.Drawing.Font,System.Drawing.Color,ILNumerics.Drawing.Interfaces.IILTextRenderer)">
            <summary>
            Transforms an expression into render queue definition
            </summary>
            <param name="expression">expression to be transformed</param>
            <param name="font">font may used for transformation</param>
            <param name="color">standard color used for transformation</param>
            <param name="renderer">IILTextRenderer instance used for caching (and later rendering)</param>
            <returns>render queue, later used to render the visual representation of the expression</returns>
            <remarks>the expression may contain markups. See the online help at http://ilnumerics.net
            for a detailed descriptioin of known symbols and their syntax.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String,System.Drawing.Font)">
            <summary>
            Render text expression into bitmap
            </summary>
            <param name="expression">text expression</param>
            <param name="font">font used for rendering</param>
            <returns>Bitmap with rendered expression</returns>
            <remarks>The size of the bitmap returned will tightly fit around the rendered content.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleInterpreter.Transform(System.String)">
            <summary>
            Render text expression into bitmap
            </summary>
            <param name="expression">text expression</param>
            <returns>Bitmap with rendered expression</returns>
            <remarks>The size of the bitmap returned will tightly fit around the rendered content. 
            <para>A generic sans serif font of size 10em will be used. </para></remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter">
            <summary>
            Simple, (partial) tex symbol interpreter 
            </summary>
            <remarks>this is the default interpreter for all ILLabelingElements</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.#ctor">
            <summary>
            create a new instance of a simple text interpreter
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.matchSymbol(System.String,System.Int32@)">
            <summary>
            extract TextSymbol from text 
            </summary>
            <param name="text">text to extract symbol from</param>
            <param name="pos">current text character position</param>
            <returns>one of TextSymbol enumeration values</returns>
            <remarks>if one symbol was found, its enum representation is 
            returned and pos is increased by the corresponding number of 
            characters. If no matching symbol was found, pos is not altered 
            and TextSymbols.nothing will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TranslateSymbol(ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TextSymbols)">
            <summary>
             translates TextSymbol enum value to unicode character
            </summary>
            <param name="symbol">enum representation</param>
            <returns>unicode character</returns>
            <remarks>refers to: http://www.decodeunicode.org/ (e.g.)</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords">
            <summary>
            available keywords, interpretable by this IILInterpreter
            </summary>
            <remarks><para>The static instance ILSimpleTexInterpreter.Keywords can be 
            used to alter the keywords used to switch to different font styles etc.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Fontname">
            <summary>
            placeholder for font name control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Fontsize">
            <summary>
            placeholder for font size control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Italic">
            <summary>
            placeholder for italic font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Bold">
            <summary>
            placeholder for bold font control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Color">
            <summary>
            placeholder for font color control sequence
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.ILKeywords.Reset">
            <summary>
            placeholder for text control sequence 'reset to initial value' 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILSimpleTexInterpreter.TextSymbols">
            <summary>
            all available TextSymbols (like \\Alpha etc.) this IILTextInterpreter understands
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILRendererManager">
            <summary>
            Provides access to all (device dependent) ILRenderer available 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create manager instance, device dependent
            </summary>
            <param name="panel">the hosting panel, will give access to this manager instance</param>
            <remarks>While creating ILTextRendereManager instances, the executing assembly will be queried for 
            available classes matching the device. Corresponding types are than provided by calling the GetRenderer() method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.#ctor(ILNumerics.Drawing.ILPanel,System.Reflection.Assembly[])">
            <summary>
            create manager instance, device dependent
            </summary>
            <param name="panel">The hosting panel, giving access to his manager instance</param>
            <param name="assemblies">assemblies to query for matching ILRenderer types</param>
            <remarks>While creating ILRendererManager instances, the given assemblies will be queried for 
            available classes matching the device. Corresponding types are than provided by calling the 
            GetRenderer() method.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.CreateInstance(System.String,System.Reflection.Assembly)">
            <summary>
            Create a new ILRenderer instance, matching the current graphics device
            </summary>
            <param name="typeName">full class name of the new text renderer</param>
            <param name="assembly">assembly hosting the textrenderer, null for executing assembly</param>
            <returns>newly created ILRenderer instance from assembly</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.GetDefault(ILNumerics.Drawing.CoordSystem)">
            <summary>
            Create the default instance of IILTextRenderer for 
            the current graphics device and a coord system
            </summary>
            <param name="coords">coord system, the renderer is 
            specialized and the default renderer for</param>
            <returns>default IILTextRenderer object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILRendererManager.queryAddRenderer(System.Type)">
            <summary>
            iterate over types attribute, select IILTextRenderer attribute, 
            register for later reference, add/overwrite default renderers
            </summary>
            <param name="t">IILTextRenderer type</param>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILRendererManager.RendererNames">
            <summary>
            Get a collection of all IILTextRenderer types and corresponding displayNames available
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureData">
            <summary>
            class encapsulating texture item definitions
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.TextureRectangle">
            <summary>
            the item's rectangle area in the texture sheet (texture coordinates) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.Width">
            <summary>
            Width of the (rendered) item
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureData.Height">
            <summary>
            Height of the (rendered) item
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureManager">
            <summary>
             manages multiple texture sheets for storage and rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Clear">
            <summary>
            Clear all texture sheets and free their memory (cache) from GL. 
            </summary>
            <remarks> This will also fire the TextureCacheCleared event.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Reset">
            <summary>
            Reset any caching may beeing active for this texture manager. Call this once to begin rendering.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <returns>texture item data</returns>
            <remarks>If the key has been found in one of the texture sheets, the
            corresponding texture sheet will be set as current</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String,System.Boolean)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <param name="makeCurrent">if true: sets the corresponding texture sheet 
            as 'current' for subsequent rendering</param>
            <returns>texture item data</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.GetTextureItem(System.String,System.Boolean,System.Int32@)">
            <summary>
            retrieve rendering information for texture item
            </summary>
            <param name="key">key used to identify the texture item</param>
            <param name="makeCurrent">if true: sets the corresponding texture sheet 
            as 'current' for subsequent rendering</param>
            <param name="textureID">returns the texture sheet key of the item, 
            used to identify the texture in the graphic system</param>
            <returns>texture item data</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.StoreTextureItem(System.String,System.Drawing.Bitmap)">
            <summary>
            Store item into texture cache, use full bitmap
            </summary>
            <param name="key">key used to identify the texture in cache</param>
            <param name="item">bitmap holding the texture content</param>
            <returns>true if the texture was successfully stored, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.StoreTextureItem(System.String,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            Store item into texture cache, use full bitmap
            </summary>
            <param name="key">key used to identify the texture in cache</param>
            <param name="item">bitmap holding the texture content</param>
            <param name="rect">rectangle defining the area in item used for content</param>
            <returns>true if the texture was successfully stored, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureManager.Exists(System.String)">
            <summary>
            test, if a texture item for the given key exists 
            in any texture storage sheets
            </summary>
            <param name="key">unique key to be tested for</param>
            <returns>true, if a corresponding texture item exists, otherwise false</returns>
        </member>
        <member name="E:ILNumerics.Drawing.Labeling.ILTextureManager.TextureCacheCleared">
            <summary>
            Fires, when the managed texture sheets are cleared. Registrars must rebuild needed items afterwards
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DeviceType">
            <summary>
            All texture sheets must conform to this graphics device
            </summary>
            <remarks>the graphics device type must be the same as 
            the one used by the panel!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DefaultHeight">
            <summary>
            Default height for new texture sheets
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureManager.DefaultWidth">
            <summary>
            Default width for new texture sheets
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureStorage">
            <summary>
            The class provides texture storage for a single class of texures (e.g. one font)
            </summary>
            <remarks>The texture items are stored in a single texture sheet 
            and organized via a simple binary tree.</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.ILTextureStorage.m_disposed">
            <summary>
             cache, which texture has been bound at last
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.#ctor(System.Int32,System.Int32)">
            <summary>
            construct new storage
            </summary>
            <param name="height">absolute height (permanent)</param>
            <param name="width">absolute width (permanent)</param>
            <remarks>Suggested size parameter will be increased to the next power of two.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Get(System.String)">
            <summary>
            fetch texture item from storage
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.TryGetTextureItem(System.String,ILNumerics.Drawing.Labeling.ILTextureData@)">
            <summary>
            try to fetch item by key
            </summary>
            <param name="key">unique key</param>
            <param name="item">[output] item found</param>
            <returns>true: item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Exists(System.String)">
            <summary>
            test, if a key exists in the texture storage
            </summary>
            <param name="key">unique key to be tested for</param>
            <returns>true if a texture item associated with that key exists, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.String,System.Drawing.Bitmap,System.Drawing.Rectangle)">
            <summary>
            store bitmap into texture sheet
            </summary>
            <param name="key">unique key for item</param>
            <param name="data">item bitmap data</param>
            <param name="rect">rectangle used in data bitmap</param>
            <returns>true on success</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            store bitmap into texture sheet
            </summary>
            <param name="key">unique key for item</param>
            <param name="data">item bitmap data</param>
            <param name="bmpRect">used rectangle in data bitmap</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="data">new item bitmap data</param>
            <param name="location">area in bitmap data to be stored</param>
            <param name="rect">rectangle specifying area to store the data into,
            texture coords: range from 0...1.0</param>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.MakeCurrent">
            <summary>
            select the texture storage as current in the GL
            </summary>
            <remarks>Calling this function before an storage / render operation is 
            obligatory in specific rendering machines (e.g. OpenGL). For GL's, where 
            it is not neccessary, the implementation must ignore any calls to this function.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Dispose">
            <summary>
            Dispose off any texture storage's ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Dispose(System.Boolean)">
            <summary>
            Dispose off manually
            </summary>
            <param name="manual"></param>
            <remarks>The true disposing is done in the concrete implementation.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILTextureStorage.Finalize">
            <summary>
            Finalizer, disposing ressources
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.Height">
            <summary>
            overall height of the internal texture sheet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.Width">
            <summary>
            current width of the internal texture sheet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILTextureStorage.TextureID">
            <summary>
            Key used to identify the texure in the graphic system 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILTextureStorage.Node">
            <summary>
            class representing a binary tree, used to manage the items on the texture sheet
            </summary>
            <remarks>This code is a slightly modified version of the OpenTK.Utilities framework
            TextPrinter/TextureStorage classes. See http://opentk.com for details.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.ILWorldLabel">
            <summary>
            general label, drawn in world coords
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILWorldLabel.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create a label for rendering
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.ILWorldLabel.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draws the whole rendering queue
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.PositionMin">
            <summary>
            get/ set the minimum position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.PositionMax">
            <summary>
            get/ set the maximium position for the label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.Alignment">
            <summary>
            Alignment along the axis value range. Possible values: lower, center, upper
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Labeling.ILWorldLabel.Padding">
            <summary>
            Get/ set the padding used to seperate the label from the elements around it
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Lighting.ILMaterial.#ctor">
            <summary>
            construct new material object, initialize default values
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Shininess">
            <summary>
            shape/intensity for specular reflection, range: 1...128
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Specular">
            <summary>
            color for specular reflection
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Lighting.ILMaterial.Emission">
            <summary>
            color for emissive reflection
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Marker.ILMarker">
            <summary>
            Properties for marker (e.g. used for line plots)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILMarker.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create a new marker property instance
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Marker.ILMarker.Changed">
            <summary>
            Fires when the properties have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Visible">
            <summary>
            Switch on or off the visibility of all markers 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Color">
            <summary>
            Marker color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Shape">
            <summary>
            Shape of markers, compatible with string, markerStyle or bitmap arguments
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILMarker.Size">
            <summary>
            Size of markers in pixels (default: 10)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Marker.ILMarkerShapeProxy">
            <summary>
            Class used to enable flexible settings for marker shapes in ILMarker
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILStyledMarkerShape.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.MarkerStyle)">
            <summary>
            create new styled marker
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILStyledMarkerShape.BitmapFromStyle(ILNumerics.Drawing.MarkerStyle)">
            <summary>
            convert marker style into bitmap
            </summary>
            <param name="marker">marker with style property</param>
            <returns>bitmap according to style</returns>
            <remarks>the bitmap will be loaded from ILNumerics.Drawing ressources. For marker style 'bitmap'
            the bitmap referenced in the marker will be returned.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILStyledMarkerShape.Style">
            <summary>
            The style of markers 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Marker.ILTexMarkerShape.Draw(ILNumerics.Drawing.ILRenderProperties,ILNumerics.Drawing.Marker.ILMarker,ILNumerics.Drawing.Shapes.C4bV3f[],System.Int32,System.Int32)">
            <summary>
            draw all markers (graph / legend)
            </summary>
            <param name="marker">the marker object (for properties)</param>
            <param name="vertices">coords, interleaved</param>
            <param name="vertcount">number of coords, special: -1 for legend rendering</param>
            <remarks>This function is reused for both: drawing in world coords (graph) and drawing in
            screen coords (legend). Latter case requires vertcount to be -1, vertices must contain
            at least 2 float values than!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.Interpreter">
            <summary>
            Interpreter instance usedt to convert expression into visual output
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.MaxLabelsDrawn">
            <summary>
            maximum number of labels to be drawn
            </summary>
            <remarks>If the graph contains more datapoints, only <i>MaxLabelsDrawn</i> markers 
            will be shown. This is for performance reasons only. Default is 50.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.ValueFormat">
            <summary>
            Format string used to convert value numbers into string 
            </summary>
            <remarks>Default: 'f'</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Marker.ILTexMarkerShape.Expression">
            <summary>
            Expression defining the marker tex shape
            </summary>
            <remarks>The expression may uses markups interpretable by the current interpreter. This is - by default - an simple Tex interpreter. 
            In addition to all partial tex commands, one may uses placeholders '\\index', '\\xvalue' and/or '\\yvalue'. Those placeholders will be 
            replaces for every marker individually with its real values at runtime.
            <para>This property is readonly. In order to change the expression, assign the new expression string to the Shape property of the 
            containing ILMarker class.</para></remarks>
        </member>
        <member name="T:ILNumerics.Drawing.AutoZoomOptions">
            <summary>
            Options for adapting ILPanel view limits 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.Never">
            <summary>
            never adapt automatically, the view limits are handled by the user
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.OnStartup">
            <summary>
            Only adapt view limits once at startup, later changes of the data limits will not affect the view limits
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AutoZoomOptions.OnDataChanges">
            <summary>
            View limits will automatically adapt changes of data limits. (Default)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AspectRatioMode">
            <summary>
            modes for projecting the rendering output to the available client area
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.StretchToFill">
            <summary>
            plots fill available rendering area of the PlotCubeScreenRectF rectangle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AspectRatioMode.MaintainRatios">
            <summary>
            plots will be shrinked to fit inside PlotCubeScreeRectF but maintain data aspect ratio
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ZoomModes">
            <summary>
            defines the movement from current to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.Jump">
            <summary>
            No ramp, jump to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollSoft">
            <summary>
            morph softly to new zoom setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollHard">
            <summary>
            morph faster to new setting
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ZoomModes.RollOverride">
            <summary>
            morph to new setting by 'going over the limit'
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Colormaps">
            <summary>
            predefined colormaps
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TextOrientation">
            <summary>
            Orientation for labels and other purposes
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.VerticalAlignment">
            <summary>
            Alignment for 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickLabelRenderingHint">
            <summary>
            Suggest, how label positions for axis ticks are to be choosen
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Filled">
            <summary>
            tick labels will optimally fill the whole axis length
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple1">
            <summary>
            multiples of 10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple2">
            <summary>
            multiples of 2*10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Multiple5">
            <summary>
            multiples of 5*10^n will be prefered for label steps
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelRenderingHint.Auto">
            <summary>
            Try to find the optimal division for tick label steps [default]
            </summary>
            <remarks>This method is the most computational intensive one.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.AxisNames">
            <summary>
            Names for all 3 axes 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.UnlabeledTick">
            <summary>
            simple single unlabled tick
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.UnlabeledTick.Position">
            <summary>
            Position of tick
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.AxisType">
            <summary>
            Axis ticks spacing type: linear, logarithmic
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisType.Linear">
            <summary>
            linear axis tick spacing
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.AxisType.Logarithmic">
            <summary>
            logarithmic axis tick spacing
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickDisplay">
            <summary>
            On which sides ticks will be displayed
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDisplay.LabelSide">
            <summary>
            ticks for axis will be displayed on label side only
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDisplay.BothSides">
            <summary>
            ticks for axis will be displayed on label - and the opposite site 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickDirection">
            <summary>
            how ticks are displayed (inside/outside)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDirection.Inside">
            <summary>
            Ticks will lay inside the rendering cube
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickDirection.Outside">
            <summary>
            Ticks will lay outside the rendering cube
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxisLabelOrientation">
            <summary>
            orientation for axis labels (not implemented)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickMode">
            <summary>
            TickModes - automatic or manual axis tick positioning
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Auto">
            <summary>
            find tick positions automatically 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickMode.Manual">
            <summary>
            manually create ticks 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.PlotBoxScreenSizeMode">
            <summary>
            options for the sizing of the projection of the plot cube onto the 2D screen client area of the control
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Maximum">
            <summary>
            the projection of the plot cube drawing area fills the whole controls space (labels may be hidden) 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Optimal">
            <summary>
            the size of plot cube projection rectangle is automatically determined, taking labels size into account
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.StrictOptimal">
            <summary>
            more pixel exact positioning, strictly only the place really needed for labels is used (slower)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.PlotBoxScreenSizeMode.Manual">
            <summary>
            No automatic resizing for the cube projection size, values from PlotCubeScreenRect are taken
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderReason">
            <summary>
            possible states/reasons/sources for rendering the scene
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderReason.PaintEvent">
            <summary>
            normal source, the scene is to be rendered the common way
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderReason.RecalcLabels">
            <summary>
            the rendering was re-initialized because the matrices need to be recalculated for laying out labels correctly 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LabelAlign">
            <summary>
            Alignments for labels 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Lower">
            <summary>
            align the label near the lower range limit
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Center">
            <summary>
            align the label in the center 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LabelAlign.Upper">
            <summary>
            align the label near the upper range limit
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.TickLabelAlign">
            <summary>
            Possible alignments for tick labels
            </summary>
            <remarks>member of this enum can get bitwise combined. Default is: Top,Left</remarks>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.left">
            <summary>
            align the label to the left side
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.center">
            <summary>
            align the labels to the center
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.right">
            <summary>
            align the label to the right side
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.top">
            <summary>
            align the label to top
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.vertCenter">
            <summary>
            align the label to center vertically 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.TickLabelAlign.bottom">
            <summary>
            align the label to bottom
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Projection">
            <summary>
            projection types
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Perspective">
            <summary>
            3D graphs will be distorted for opotimized 3D impression
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Projection.Orthographic">
            <summary>
            graphs will not be distorted. objects in the front will get the same size as objects in the back
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.MarkerStyle">
            <summary>
            valid marker styles (partially supported)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Dot">
            <summary>
            draw markers as dots
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Circle">
            <summary>
            draw markers as circle
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Diamond">
            <summary>
            draw markers as diamonds
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Square">
            <summary>
            draw markers as square
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleUp">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleDown">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleLeft">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.TriangleRight">
            <summary>
            draw markers as up pointing triangles
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Plus">
            <summary>
            draw markers as plus
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.Cross">
            <summary>
            draw markers as cross
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.MarkerStyle.None">
            <summary>
            do not draw markers
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CameraQuadrant">
            <summary>
            Possible positions of the camera
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ShadingStyles">
            <summary>
            Shading styles for surface graphs
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ShadingStyles.Interpolate">
            <summary>
            color will be interpolated between all corners 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ShadingStyles.Flat">
            <summary>
            same color for whole tile area
            </summary>
            <remarks>The resulting color will 
            reflect the average over all corner values for a rectangle</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.LineStyle">
            <summary>
            line style
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Solid">
            <summary>
            solid line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Dashed">
            <summary>
            dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.PointDash">
            <summary>
            point dashed line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.Dotted">
            <summary>
            dotted line
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.UserPattern">
            <summary>
            use user stipple pattern 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.LineStyle.None">
            <summary>
            no line at all
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.InteractiveModes">
            <summary>
            modes of mouse interaction with ILPanel
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILPoint3Df">
            <summary>
            single precision 3D point structure
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.X">
            <summary>
            X coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.Y">
            <summary>
            Y coordinate
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Df.Z">
            <summary>
            Z coordinate
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            create point in single precision
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coord</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.#ctor(System.Double,System.Double,System.Double)">
            <summary>
            create new ILPoint3Df by double values (for convenience, internally casted to float)
            </summary>
            <param name="x">X coord</param>
            <param name="y">Y coord</param>
            <param name="z">Z coors</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.ToString">
            <summary>
            convert this point to string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.cross(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product between a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.crossN(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            normalized cross product
            </summary>
            <param name="a">vector 1</param>
            <param name="b">vector 2</param>
            <returns>normalized cross product: a x b</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.Spin(ILNumerics.Drawing.ILPoint3Df,System.Single)">
            <summary>
            rotate the vector, keep length
            </summary>
            <param name="normal">axis as rotation normal</param>
            <param name="angleDeg">angle to move (radian)</param>
            <returns>rotated version of this vector, does not change original vector</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.Equals(System.Object)">
            <summary>
            Compares obj's coordinate values to those of this class instance
            </summary>
            <param name="obj">ILPoint3Df to compare</param>
            <returns>true, if X,Y and Z coordinates are equal</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILPoint3Df.GetHashCode">
            <summary>
            get a hash code for this ILPoint3Df object
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="P:ILNumerics.Drawing.ILPoint3Df.Item(System.Int32)">
            <summary>
            Access to coords by index
            </summary>
            <param name="index">index number: 0=x, 1=y, 2=z</param>
            <returns>float value of coord specified</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ILPoint3Dd">
            <summary>
            double precision 3D point definition
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.X">
            <summary>
            X coord
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.Y">
            <summary>
            Y coord
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILPoint3Dd.Z">
            <summary>
            Z coord
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphicDeviceType">
            <summary>
            supported graphics devices
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.Direct3D">
            <summary>
            DirectX based 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.OpenGL">
            <summary>
            OpenGL based (not supported yet)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.GDI">
            <summary>
            Windows native graphics device (not implemented)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.GraphicDeviceType.Unknown">
            <summary>
            unknown graphics device (not used, errror)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphType">
            <summary>
            valid types for plotting graphs
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.CoordSystem">
            <summary>
            Coordinate systems for TextRenderer
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CoordSystem.Screen">
            <summary>
            the location is expected to be specified into screen coords
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.CoordSystem.World3D">
            <summary>
            the location is expected to be specified into world (3D) coords
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.RenderItemType">
            <summary>
            possible types of renderable items 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Character">
            <summary>
            the item defines a character 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.RenderItemType.Bitmap">
            <summary>
            the item defines a bitmap
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.GraphCollectionChangeReason">
            <summary>
            possible reason for an ILGraphCollectionChangedEvent to occur
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Labeling.LabeledTick">
            <summary>
            simple single labeled tick
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.LabeledTick.Queue">
            <summary>
            tick label
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Labeling.LabeledTick.Position">
            <summary>
            tick position
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Labeling.LabeledTick.#ctor(System.Single,ILNumerics.Drawing.Labeling.ILRenderQueue)">
            <summary>
            create single labeled tick
            </summary>
            <param name="position">position</param>
            <param name="queue">render queue used to render the item</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickProvider">
            <summary>
            tick provider function delegate definition
            </summary>
            <param name="min">minimum axis limit</param>
            <param name="max">maximum axis limit</param>
            <param name="maxCount">maximum number of ticks to create</param>
            <returns>list of tick position to be drawn</returns>
            <remarks>User defined tick providers must fulfill this delegates signature. 
            </remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILClippingDataChangedEvent">
            <summary>
            occours if the clipping data for an subfigure have changed
            </summary>
            <param name="sender">object which changed the data</param>
            <param name="e">arguments containing the new clipping data</param>
        </member>
        <member name="T:ILNumerics.Drawing.MeasureTextDelegate">
            <summary>
            delegate used to measure text, device dependent
            </summary>
            <param name="text">text to be measured</param>
            <param name="font">Font used for rendering</param>
            <returns>Size in screen coords</returns>
        </member>
        <member name="T:ILNumerics.Drawing.ClippingChangedEventArgs">
            <summary>
            arguments on ClippinChangedEvents
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ClippingChangedEventArgs.#ctor(ILNumerics.Drawing.ILClippingData)">
            <summary>
            creates a new ClippingChangedEventArgs object
            </summary>
            <param name="clippingData"></param>
        </member>
        <member name="F:ILNumerics.Drawing.ClippingChangedEventArgs.ClippingData">
            <summary>
            the current (new) clipping data
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceResetEvent">
            <summary>
            occours if a graphics device has been reset by the underlying graphics framework
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphicsDeviceCreatedEvent">
            <summary>
            occours if a graphics device has been (re)created by an output panel
            </summary>
            <param name="sender">objects who hosts the graphics device</param>
            <param name="eventArgs"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphChangedEventArgs">
            <summary>
            arguments to communicate changes on graphs 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILGraphChangedEventArgs.Source">
            <summary>
            string description of the changed parameter
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphChangedEvent">
            <summary>
            fires, if properties of a graph were /have changed
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs">
            <summary>
            arguments for ILGraphCollectionChanged events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs.Configurator">
            <summary>
            description of element changed (in some cases)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILGraphCollectionChangedEventArgs.#ctor(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.GraphCollectionChangeReason,ILNumerics.Drawing.Interfaces.IILPanelConfigurator)">
            <summary>
            arguments for GraphCollectionChanged events
            </summary>
            <param name="graph">the graph who was changed, for ILPlot: the scene graph</param>
            <param name="reason">reason</param>
            <param name="configurator"> instance of IILPanelConfigurator or null</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILGraphCollectionChangedEvent">
            <summary>
            occurs on changes to the graph collection: add, delete
            </summary>
            <param name="sender">graph collection</param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILLabeledTickAddingArgs">
            <summary>
            Event handler handling LabeledTickAdding events 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.LabeledTickAddingHandler">
            <summary>
            Delegate definition for function handling LabeledTickAdding events
            </summary>
            <param name="sender">the sender of the event (e.g. ILTickCollection)</param>
            <param name="args">arguments </param>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxisChangedEventArgs">
            <summary>
            Event arguments for axis changed events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILAxisChangedEventArgs.AxisName">
            <summary>
            Name of changed axis (X-,Y-,ZAxis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxisChangedEventArgs.#ctor(ILNumerics.Drawing.AxisNames)">
            <summary>
            construct a new instance 
            </summary>
            <param name="name"></param>
        </member>
        <member name="T:ILNumerics.Drawing.AxisChangedEventHandler">
            <summary>
            delegate for functions handling AxisChanged events
            </summary>
            <param name="sender"></param>
            <param name="args"></param>
        </member>
        <member name="T:ILNumerics.Drawing.ILSceneGraphNodeEventArgs">
            <summary>
            event argument for SceneGraphNodeAdded events
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILSceneGraphNodeEventArgs.Node">
            <summary>
            Node which was added to the scene graph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.SceneGraphNodeHandler">
            <summary>
            used for events fired once a SceneGraphNode was added
            </summary>
            <param name="sender">the object</param>
            <param name="args">the arguments</param>
        </member>
        <member name="T:ILNumerics.Drawing.ILAxis">
            <summary>
            Axis object for ILPanel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.OnChange">
            <summary>
            fires a changed event
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.m_clipping_Changed(System.Object,ILNumerics.Drawing.ClippingChangedEventArgs)">
            <summary>
            occures if the registered clipping data have changed
            </summary>
            <param name="sender">ILClipping data</param>
            <param name="e">clipping changed event args</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.#ctor(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.ILPanel)">
            <summary>
            construct ILAxis object. This contructor is not to be called directly.
            </summary>
            <param name="name">type of the axis: XAxis,YAxis,ZAxis</param>
            <param name="clippingView">Clipping data to be registered into the axis.</param>
            <param name="layoutData">additional layout data, does currently only contain the camera [depricated]</param>
            <param name="panel">panel hosting the scene</param>
            <remarks>ILAxis objects are created GL-device dependend by use of a device dependend ILPanel instance's
            member ILPanel.CreateAxis(). This acts like a factory pattern. The specific axis derivate will be
            created by the derived ILPanel object (ILDXPanel or ILOGLPanel).</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            this function does the drawing of the axis lines 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw background only, false: draw foreground only</param>
            <remarks>This function is called in the general rendering algorithm. I.e. <b>before</b> the surface buffers has been swapped.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawLabel(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) do the drawing of axis' label 
            </summary>
            <param name="p">render properties</param>
            <remarks>When this function is called, depends on the DrawAfterBufferSwaped setting 
            of the current TextRenderer.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.iDrawTickLabels(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internal use) draw tick labels
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.drawGrid">
            <summary>
            Do all rendering for the grid of the axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState1(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw this axis in the back (behind the graphs)
            </summary>
            <param name="p">render properties</param>
            <remarks>This method is used internally. There should be no need to call it directly.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Do rendering of foreground (before the graphs)
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.RenderState3(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            do rendering after the buffers have been swapped
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Configure(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            update axis (recalculate number &amp; position of labels in auto mode, recreate vertices)
            </summary>
            <param name="p">render properties</param>
            <remarks>This method is used internally. There should be no need to call it directly.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.PrepareMeshes(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            recreate vertices
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.PrepareLabels(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            recreate labels
            </summary>
            <param name="p">render properties</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.GetMaxTickCount(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            number of ticks optimally fitting on screen
            </summary>
            <param name="p">render properties</param>
            <returns>optimal number of ticks for this axis</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.countPrimitves">
            <summary>
            determine number of primitives (lines) to be drawn for this axis
            </summary>
            <returns>number of primitives</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Invalidate">
            <summary>
            Invalidate this axis, causes recreation on next render
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILAxis.Dispose">
            <summary>
            (internal use) dispose off this axis' elements
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Panel">
            <summary>
            Panel hosting the axis (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.LabeledTickProvider">
            <summary>
            Used to retrieve/specify the delegate computing nice labels for axis
            </summary>
            <remarks>One can replace the default tick provider by a user 
            defined labeled tick computation function. Therefore simply set this property to
            your own ILLabeledTickProvider function.
            </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.FarLines">
            <summary>
            get properties for far axis lines (opposite label side) or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.NearLines">
            <summary>
            get properties for near axis lines (opposite label side) or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Label">
            <summary>
            label to be displayed next to this axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Visible">
            <summary>
            Switch visibility on/ off
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.AxisType">
            <summary>
            axis type
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.LabeledTicks">
            <summary>
            Gives access to the collection of labeled ticks
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.UnlabeledTicks">
            <summary>
            access to the collection of unlabeled ticks (not used)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Index">
            <summary>
            access to a specific axis by number 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Grid">
            <summary>
            access grid lines properties 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILAxis.Limits">
            <summary>
            access axis limits 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILCamera">
            <summary>
            This class represents the camera's positioning and aiming direction.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.OnChange">
            <summary>
            Fires a Changed event
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.Offset">
            <summary>
            Offset angle for 2nd cached triangular phi value (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosPhiShift">
            <summary>
            cachced triangular phi value with offset (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinPhiShift">
            <summary>
            cachced triangular phi value with offset (needed for surface plots)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosPhi">
            <summary>
            cached value for cosine of phi - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinPhi">
            <summary>
            cached value for sine of phi - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.CosRho">
            <summary>
            cached value for cosine of rho - this is readonly and for performance only.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILCamera.SinRho">
            <summary>
            cached value for sine of rho - this is readonly and for performance only.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.#ctor">
            <summary>
            Create a viewport: view at scene from top, no rotation
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingSuspend">
            <summary>
            suspend the firing of events until EventingResume() was called
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingResume">
            <summary>
            Resume firing 'Change' events after it has been suspended
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.EventingResume(System.Boolean)">
            <summary>
            Resume firing 'Change' events, optionally skip pending events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.Set(System.Single,System.Single,System.Single)">
            <summary>
            Set both angles and distance at once  
            </summary>
            <param name="phi">Rotation, radians</param>
            <param name="rho">Pitch, radians</param>
            <param name="distance">Distance from scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.SetDeg(System.Single,System.Single,System.Single)">
            <summary>
            Set complete camera position (angles and distance) at once
            </summary>
            <param name="phi">Rotation (degrees)</param>
            <param name="rho">Pitch (degrees)</param>
            <param name="distance">Distance from scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.ToString">
            <summary>
            Convert camera position to string
            </summary>
            <returns>string display with distance,roatation and pitch</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILCamera.updatePosition">
            <summary>
            update internal cartesian (absolut) coordinates of position relative 
            to lookAt point. To be called after any polar coordinates were changed.
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.ILCamera.Changed">
            <summary>
            fires, if the position of the camera has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LookAt">
            <summary>
            point, the camera is aiming at (world coords)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Distance">
            <summary>
            distance from the scene (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_phiDebugDisp">
            <summary>
            debugger helper: display phi in degrees (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.m_rhoDebugDisp">
            <summary>
            debugger helper: display rho in degrees
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Phi">
            <summary>
            rotation of the scene (seen from above) [radians, readlony, rel. to lookat]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Rho">
            <summary>
            pitch of the scene [radians], setting moves camera around lookat point
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Quadrant">
            <summary>
            Quadrant the camera is currently watching the scene from
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromTop">
            <summary>
            Determine, if camera is placed in an upper quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromLeft">
            <summary>
            Determine, if camera is located in an left quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.LooksFromFront">
            <summary>
            Determine, if camera is located in an front quadrant of the scene
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Is2DView">
            <summary>
            true, when looking from top on the un-rotated scene (common for 2D plots)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Position">
            <summary>
            get/set camera position, absolute cartesian coordinates
            </summary>
            <remarks>Keep in mind, the angle for phi points towards negative Y axis! The cartesian property 
            <paramref name="Position"/> handles the camera position in absolute world coordinates, while the 
            polar coordinates (Rho, Phi, Distance) supress the camera position by means of coordinates 
            relative to the LookAt point (i.e. usually the center of the viewing cube)!</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILCamera.Top">
            <summary>
            orientation of the camera, normalized, readonly
            </summary>
            <remarks>This vector is readonly always points 'upwards'.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILClippingData">
            <summary>
            Class holding and managing limits for a 3 dimensional cube
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.OnChange">
            <summary>
            called if the limits have changed
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingSuspend">
            <summary>
            suspend the firing of events until EventingResume has been called
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingResume">
            <summary>
            Resume previously suspended eventing. Start sending events again.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EventingStart">
            <summary>
            enable eventing without sending pending events
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILClippingData)">
            <summary>
            update ranges for this object with union of both ranges. 
            </summary>
            <param name="clipData">clipping ranges to create union with</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILPoint3Df,System.Int32)">
            <summary>
            update ranges for this object with point coords for specific axes
            </summary>
            <param name="point">point with coords to update ranges with</param>
            <param name="updateBitFlags">bitflag combination to specify axis to be recognized: 1,2,4 -> x,y,z</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Update(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            update clipping data for this object with union of this and rectangle specified
            </summary>
            <param name="luCorner">left upper corner</param>
            <param name="rbCorner">right lower corner</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Set(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Set clipping limits to volume inside the box specified 
            </summary>
            <param name="lunCorner">left-upper-near corner of the volume box</param>
            <param name="rbfCorner">right-bottom-far corner of the volume box</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Reset">
            <summary>
            reset this clipping range to initial (all empty)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.CopyFrom(ILNumerics.Drawing.ILClippingData)">
            <summary>
            copy this from other clipping data
            </summary>
            <param name="m_clippingData"></param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.ScaleToUnitCube">
            <summary>
            stretch clipping region to unit cube [0 1][0 1][0 1] 
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.CenterToUnitCube">
            <summary>
            offset centering scaled unit cube to zero: [-0.5 0.5][-0.5 0.5][-0.5 0.5]
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Clone">
            <summary>
            creates clone of this clipping data
            </summary>
            <returns>clone</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Map(System.Single,System.Single,System.Single)">
            <summary>
            Map coordinat from unit cube space [-0.5..0.5] into the space limited by this clipping data
            </summary>
            <param name="x">x coordinate (unit cube space: -0.5 ... 0.5)</param>
            <param name="y">y coordinate (unit cube space: -0.5 ... 0.5)</param>
            <param name="z">z coordinate (unit cube space: -0.5 ... 0.5)</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.GetZoomParameter(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Single,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            Expand/shrink all those edges, not touched by the given line
            </summary>
            <param name="nearLineEnd">near line point</param>
            <param name="farLineEnd">far line point</param>
            <param name="offset">multiplicator, shrink-/expand value</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.EnsureValidSize">
            <summary>
            Ensure that this clipping data has valid length for all dimensions  [deprecated]
            </summary>
            <remarks>If the length of the clipping cube is infinity for any dimension, 
            that dimension is set to a range of -0.5...0.5.
            <para>This function is to be called by custom graphs which create their 
            size <b>relative</b> to the size of the clipping container. Those 
            graphs will need a valid container size and may call this function in the 
            constructor.</para></remarks>
            <returns>true if the length in any dimension had to be corrected (set to 1.0), false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.op_Equality(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILClippingData)">
            <summary>
            Equalty operator overload, true if both cubes span the same region in 3D space 
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>true if both cubes span the same 3D space, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.op_Inequality(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILClippingData)">
            <summary>
            unequalty operator
            </summary>
            <param name="limit1">cube 1</param>
            <param name="limit2">cube 2</param>
            <returns>false if both cubes span the same 3D space, true otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.GetHashCode">
            <summary>
            Returns hash code for this ILClippingData
            </summary>
            <returns>hash code</returns>
        </member>
        <member name="M:ILNumerics.Drawing.ILClippingData.Equals(System.Object)">
            <summary>
            Compares to cube objects
            </summary>
            <param name="obj"></param>
            <returns>true if obj references this class instance, false otherwise</returns>
        </member>
        <member name="E:ILNumerics.Drawing.ILClippingData.Changed">
            <summary>
            fires if the data range have changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.SphereRadius">
            <summary>
            the radius of a sphere tightly enclosing the box determined by this clipping data limits (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.XMin">
            <summary>
            minimum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.YMin">
            <summary>
            minimum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.ZMin">
            <summary>
            minimum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.XMax">
            <summary>
            maximum value for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.YMax">
            <summary>
            maximum value for y axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.ZMax">
            <summary>
            maximum value for z axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.Min">
            <summary>
            minimum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.Max">
            <summary>
            maximum (coordinate)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.CenterF">
            <summary>
            get center of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.WidthF">
            <summary>
            get width (x-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.HeightF">
            <summary>
            get height (y-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.DepthF">
            <summary>
            get depth (z-direction) of this clipping range
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.IsDirty">
            <summary>
            marks the limits as altered, without having fired a changed event yet
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILClippingData.AllowZeroVolume">
            <summary>
            true: this clipping data always ensures a non-zero volume
            </summary>
            <remarks>'NonZeroVolumne' means, non of Depth,Width nor Heigth are allowed to be zero. If some edge of the cube is set to zero, the class expands this edge by 1 in each direction.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Misc.ILColorEnumerator">
            <summary>
            enumerate colors 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
            create new color enumeration based on a specific colormap
            </summary>
            <param name="basemap"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.#ctor">
            <summary>
            create new color enumerator based on Colormap.Lines
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorEnumerator.NextColor">
            <summary>
            return next color and increase internal pointer
            </summary>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor">
            <summary>
            construct new colormap, based on HLS model
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor(ILNumerics.Drawing.Colormaps)">
            <summary>
             create specific colormap
            </summary>
            <param name="map"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.#ctor(ILNumerics.ILInArray{System.Single})">
            <summary>
            create colormap based on predefined colors
            </summary>
            <param name="colors"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.Map(ILNumerics.ILDenseArray{System.Single})">
            <summary>
            map all elements in A into final colors
            </summary>
            <param name="A">array with elements to map</param>
            <returns>colors as ILArray, the i-th row represents the color for the i-th element of A as RGB tripel.</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.Map(System.Double,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            convert index value to color, interpolating
            </summary>
            <param name="value">index, position into color table, range 0...(Length-1). Values outer limits will be truncated.</param>
            <param name="r">out value: red component</param>
            <param name="g">out value: green component</param>
            <param name="b">out value: blue component</param>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Length">
            <summary>
            number of colors in the colormap
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Type">
            <summary>
            The colormap type this colormap is based on (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILColormap.Data">
            <summary>
            retrieve / set internal data for color indices
            </summary>
            <remarks>colors will be a matrix of exactly 3 columns. Each element will range between 0.0 ... 1.0. 
            If in set access the matrix provided contains elements outside the range, the matrix will be normalized to fit into 0.0 ... 1.0.
            <para>The array returned will be a reference of the internal data only. It cannot be used to alter internal color table! In order to alter the color table, one can query the table, alter it outside and store it back than.</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.MapCreator.CreateMap(ILNumerics.Drawing.Colormaps)">
            <summary>
            create colorpam of length 128
            </summary>
            <param name="map">map specification</param>
            <returns>colormap (matrix with size [len,3])</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColormap.MapCreator.CreateMap(ILNumerics.Drawing.Colormaps,System.Int32)">
            <summary>
            create colormap
            </summary>
            <param name="map">map specification</param>
            <param name="len">len of colormap</param>
            <returns>colormap (matrix with size [len,3])</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Misc.ILColorProvider">
            <summary>
            Color helper - change RGB to/ from HLS model
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorProvider.H2RGB(System.Single)">
            <summary>
            convert hue value to RGB value, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorProvider.H2RGB(System.Single,System.Single@,System.Single@,System.Single@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorProvider.H2RGB(System.Single,System.Single[],System.Int32@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <param name="offset">offset into vertex array</param>
            <param name="va">vertex array, target for the color</param>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILColorProvider.H2RGB(System.Single,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            convert hue value to seperate RGB values, based on predefined values  
            </summary>
            <param name="hue">hue: in range 0...MAXHUEVALUE</param>
            <returns>int value as RGB color, A=255</returns>
            <remarks>the internal values (rgb / luminance,saturation) will not be altered. 
            rgb returned as seperate float values, normalized to 0.0f...1.0f</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILDrawingException">
            <summary>
            Drawing exception
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawingException.#ctor(System.String)">
            <summary>
            create new drawing exception
            </summary>
            <param name="message">message</param>
        </member>
        <member name="M:ILNumerics.Drawing.ILDrawingException.#ctor(System.String,System.Exception)">
            <summary>
            create new drawing exception
            </summary>
            <param name="message">message</param>
            <param name="innerException">inner (nested) exception</param>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILGraphComparer.Compare(ILNumerics.Drawing.Graphs.ILGraph,ILNumerics.Drawing.Graphs.ILGraph)">
            <summary>
            sort graphs regarding their Z order 
            </summary>
            <param name="x">first graph</param>
            <param name="y">second graph</param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            construct new legend object
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.Create(ILNumerics.Drawing.ILPanel)">
            <summary>
            Create new instance of ILLegend, depending on graphics device type
            </summary>
            <param name="panel">panel hosting this legend</param>
            <returns>newly created ILLegend object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Misc.ILLegend.Draw(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle)">
            <summary>
            Draw the legend onto a predefined bitmap or into GL context
            </summary>
            <param name="p">render properties</param>
            <param name="area">rectangle area defines region to draw legend contents into.</param>
            <remarks>This function does only render to a predefined bitmap, which must be given in p. Rendering to 
            (dvice dependent) graphic contexts is done in derived implementations.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Visible">
            <summary>
            get / set visibility for legend
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Opacity">
            <summary>
            Get/ set opacity for filled area, values: 0...1.0
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.BackgroundColor">
            <summary>
            Get / set background color
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Location">
            <summary>
            get/ set location of legend box (upper/left corner, fraction of ClientSize [(0,0)...(1f,1F)]), empty for auto mode
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Size">
            <summary>
            get/ set size of legend box, empty for auto mode
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Misc.ILLegend.Border">
            <summary>
            set properties of legend's border 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.ILLineProperties">
            <summary>
            properties for line graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLineProperties.#ctor">
            <summary>
            create default properties for graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILLineProperties.#ctor(ILNumerics.Drawing.ILLineProperties)">
            <summary>
            create a new instance of this class based on another instance
            </summary>
            <param name="props">properties to be copied</param>
        </member>
        <member name="E:ILNumerics.Drawing.ILLineProperties.Changed">
            <summary>
            fires if the properties were changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Width">
            <summary>
            line width (default: 1)
            </summary>
            <remarks>if antialiasing is active, it will be disabled 
            as long as the width is less than 2 and automatically 
            reenabled if the width gets larger than 1 again.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Style">
            <summary>
            line style (default: solid)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Pattern">
            <summary>
            user defined line stipple pattern for line style 'UserPattern'
            </summary>
            <remarks>the pattern is defined by corresponding bits 
            set in the short value. It may be stretched via the 
            LinePatternScale parameter. Default: 15</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.PatternScale">
            <summary>
            scaling for line stipple patterns (default: 2.0f)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Color">
            <summary>
            Line color (default: DarkOliveGreen)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Visible">
            <summary>
            get / set if lines are visible (default: true)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.ILLineProperties.Antialiasing">
            <summary>
            draw lines with smooth antialiasing (if possible and supported)
            </summary>
            <remarks>If the object supports antialiased lines, edges will be drawn 
            smoothly. This sometimes comes with the drawback of the lines beeing 
            more thick. Not all objects support antialiasing. Default value is 'false'.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.ILRenderProperties">
            <summary>
            extended drawing properties
            </summary>
            <remarks>the class collects flags for special
            rendering states (vector exports, picking).
            </remarks>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Camera">
            <summary>
            current camera 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Clipping">
            <summary>
            current clipping (view limits) data
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Graphics">
            <summary>
            if not null, the rendering should be done offscreen via this graphics object
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Canceled">
            <summary>
            if set to true while rendering, the render process will be cancelled 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.Reason">
            <summary>
            inform content object of the reason for rendering, see the <see cref="T:ILNumerics.Drawing.RenderReason">enumeration</see> for possible values.
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MinX">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MaxValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MaxX">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MinValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MinY">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MaxValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.MaxY">
            <summary>
            measures the absolute used up region while rendering, initiallized to int.MinValue
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.ILRenderProperties.PassCount">
            <summary>
            Some rendering settings require multiple rendering passes. Those are counted here.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.ILRenderProperties.Reset">
            <summary>
            Resets this instance.
            </summary>
            <returns>Instance reset to default values.</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLAxis">
            <summary>
            OpenGL implementation for ILAxis 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph">
            <summary>
            OpenGL implementation for ILImageSCGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draws the graph into existing context
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Dispose">
            <summary>
            Dispose off this graph's vertices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.Invalidate">
            <summary>
            Ensures the recalculation of vertices if neccessary
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLImageSCGraph.VertexC4V2">
            <summary>
            Vertex definition: 4Color (uint), 2 Vertex (float)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLLegend.Draw(ILNumerics.Drawing.ILRenderProperties,System.Drawing.Rectangle)">
            <summary>
            draw legend into opengl context
            </summary>
            <param name="p">rendering properties</param>
            <param name="area">area to draw the content into, if g is null, this will be ignored also</param>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLLineRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLLinesRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel">
            <summary>
            OpenGL implementation for ILPanel
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.GetDeviceContext">
            <summary>
            Gets an interface to the underlying GraphicsContext used by this GLControl.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.OnHandleCreated(System.EventArgs)">
            <summary>
            will get called after the handle has been created
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.OnHandleDestroyed(System.EventArgs)">
            <summary>
            gets called, after the handle has been destroyed
            </summary>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.Dispose(System.Boolean)">
            <summary>
            Dispose off the panels resources
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.UpdateMatrices(System.Single,System.Single,System.Single)">
            <summary>
            set up viewport, projection and modelview matrices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.iRenderingState2(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Render the OpenGL scene
            </summary>
            <param name="g"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.iRenderingState3(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            swap buffers and finalize rendering
            </summary>
            <param name="p"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.drawSelectionRect(System.Drawing.Point)">
            <summary>
            draws the selection rectangle va OpenGL (rather than GDI in base class)
            </summary>
            <param name="endPoint"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.SwapBuffers">
            <summary>
            Swaps the front and back buffers, presenting the rendered scene to the screen.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.MakeCurrent">
            <summary>
            Makes the underlying this GLControl current in the calling thread.
            All OpenGL commands issued are hereafter interpreted by this GLControl.
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateGraph(ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.GraphType,ILNumerics.ILArray{System.Single}[])">
            <summary>
            Create specific graph (device dependent)
            </summary>
            <param name="data">numeric data to be visualized, any numeric type is accepted</param>
            <param name="type">type of graph to be created</param>
            <param name="additionalParams">user defined parameter, depend on concrete device type</param>
            <returns>Concrete ILGraph object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateAxis(ILNumerics.Drawing.AxisNames,ILNumerics.Drawing.ILClippingData,System.Object[])">
            <summary>
            Create Axis (device dependent)
            </summary>
            <param name="name">specfies axis name (X,Y,ZAxis)</param>
            <param name="clippingView">the global clipping view object for the axis</param>
            <param name="parameters">user defined parameters (implementation dependent)</param>
            <returns>ILAXis object</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.CreateSceneGraph">
            <summary>
            create a new device dependent scene graph for hosting shapes, internally used
            </summary>
            <returns>scene graph</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.World2Screen(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Point@,System.Drawing.Point@)">
            <summary>
            Transform 2 world coordinates into screen coords under current matrices
            </summary>
            <param name="p1_3D">world coord point 1</param>
            <param name="p2_3D">world coord point 2</param>
            <param name="p1_2D">(output) screen coord point 1</param>
            <param name="p2_2D">(output) screen coord point 2</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.Screen2World(System.Int32,System.Int32,ILNumerics.Drawing.ILPoint3Df@,ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            transform from screen space into world space using OpenGL
            </summary>
            <param name="x">screen X</param>
            <param name="y">screen Y</param>
            <returns>world coord</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel.PolyOffsetEnable">
            <summary>
            Control polygon offset ([on]/off)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPlot2DGraph">
            <summary>
            OpenGL implementation for ILPlot2DGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLPlot2DGraph.Configure">
            <summary>
            (re)create vertex buffer, line-, texture objects
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLPointsRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer">
            <summary>
            OpenGL text renderer in screen coords
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Place a new item into the texture cache 
            </summary>
            <param name="key">unique key to identify the item for later reference</param>
            <param name="bmp">bitmap containing the item data</param>
            <param name="rect">area in <paramref name="bmp"/> containing the item's data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.ExistsKey(System.String)">
            <summary>
            Test if the cache contains an item with a specific key
            </summary>
            <param name="key">key</param>
            <returns>true if the item was cached, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            try to get the size (screen pixels) of an item
            </summary>
            <param name="key">unique key identifying the item</param>
            <param name="size">[output] size of the item (if found)</param>
            <returns>true, if the item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Drawing.Point,ILNumerics.Drawing.TextOrientation,System.Drawing.Color)">
            <summary>
            Draws all items contained in a given render queue
            </summary>
            <param name="queue">render queue</param>
            <param name="location">starting point</param>
            <param name="orientation">orientation for the whole queues output</param>
            <param name="color">starting color</param>
            <remarks><para>The render queue must contain only keys for already cached items!</para>
            <para>The color parameter serves as a global color definition. It may be overridem 
            by individual color specifications of the queue items.</para>
            </remarks>
        </member>
        <member name="E:ILNumerics.Drawing.Platform.OpenGL.ILOGLRenderer.CacheCleared">
            <summary>
            (IILTextRenderer) Event firing if the texture storage has been cleared 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph">
            <summary>
            OpenGL implementation for ILSurfaceGraph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Dispose">
            <summary>
            Dispose off this graph's vertices
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            Draw the graph
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.Invalidate">
            <summary>
            Ensures the recreation of the graph if neccessary
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLSurfaceGraph.VertexC4N3V3">
            <summary>
            Vertex definition: 4Color, 3Normal, 3 Vertex - all float
            </summary>
            <remarks>CAUTION! The vertex is not usable with OpenGL via vartex arrays this way!
            We had to recognize sporadic crashs when drawing this way! Todo: ... to be investigated.</remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage">
            <summary>
            OpenGL implementation of ILTextureStorage
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.MakeCurrent">
            <summary>
            Select this storage to be current in GL
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.InitTexture">
            <summary>
            initialize texture sheet 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.Store(System.Drawing.Bitmap,System.Drawing.RectangleF,System.Drawing.RectangleF)">
            <summary>
            store item in texture sheet in GL
            </summary>
            <param name="bmp">new item bitmap data, ARGB format</param>
            <param name="bmpRectF">rectangle used in bitmap</param>
            <param name="rect">rectangle specifying area to store the data into the texture sheet, 
            integer pixels coords: range from 0...m_width|m_height (e.g. '512')</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLTextureStorage.Dispose(System.Boolean)">
            <summary>
            dispose off the texture storage's ressources
            </summary>
            <param name="manual"></param>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLVertexRendererC4bV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4bV3f (simple /-primitive shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLVertexRendererC4fN3fV3f">
            <summary>
            An OpenGL vertex renderer, capable of rendering
            vertex arrays of type C4fN3fV3f (for lit shapes).
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer">
            <summary>
            Basic OpenGL implementation for IILTextRenderer
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.Cache(System.String,System.Drawing.Bitmap,System.Drawing.RectangleF)">
            <summary>
            Place a new item into the texture cache 
            </summary>
            <param name="key">unique key to identify the item for later reference</param>
            <param name="bmp">bitmap containing the item data</param>
            <param name="rect">area in <paramref name="bmp"/> containing the item's data</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.ExistsKey(System.String)">
            <summary>
            Test if the cache contains an item with a specific key
            </summary>
            <param name="key">key</param>
            <returns>true if the item was cached, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.TryGetSize(System.String,System.Drawing.Size@)">
            <summary>
            try to get the size (screen pixels) of an item
            </summary>
            <param name="key">unique key identifying the item</param>
            <param name="size">[output] size of the item (if found)</param>
            <returns>true, if the item was found, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.Draw(ILNumerics.Drawing.Labeling.ILRenderQueue,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Drawing.Color)">
            <summary>
            Draws all items contained in a given render queue
            </summary>
            <param name="queue">render queue</param>
            <param name="x1">x1-position</param>
            <param name="y1">y1-position</param>
            <param name="z1">z1-position</param>
            <param name="x2">x2-position</param>
            <param name="y2">y2-position</param>
            <param name="z2">z2-position</param>
            <param name="color">base color for items not containing individual colors</param>
            <remarks><para>The render queue must contain only keys for already cached items!</para>
            <para>The color parameter serves as a global color definition. It may be overwritten 
            by individual color specifications of the queue items.</para>
            <para>Use this function to draw the render queue in world coords. The position parameters mark the upper left 
            and lower right corner of the quads to contain the render queue content.</para>
            </remarks>
        </member>
        <member name="E:ILNumerics.Drawing.Platform.OpenGL.ILOGLWorldRenderer.CacheCleared">
            <summary>
            fires when the texture storage has been cleared 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layout">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the x axis 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLXAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layoutData">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the axis 
            </summary>
            <param name="p">render properties</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLYAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis">
            <summary>
            OpenGL implementation of ILAxis (X axis)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.#ctor(ILNumerics.Drawing.ILClippingData,ILNumerics.Drawing.ILLayoutData,ILNumerics.Drawing.Platform.OpenGL.ILOGLPanel)">
            <summary>
            Constructor - this class should be created only from within ILNumerics assemblies! 
            </summary>
            <param name="clippingView">panels clipping view</param>
            <param name="layout">instance with layout informations</param>
            <param name="panel">the panel containing the axis</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.iDrawAxis(ILNumerics.Drawing.ILRenderProperties,System.Boolean)">
            <summary>
            draw all lines for the axis 
            </summary>
            <param name="g">graphics object (ignored)</param>
            <param name="background">true: draw lines in the back only, false: draw foreground lines</param>
        </member>
        <member name="M:ILNumerics.Drawing.Platform.OpenGL.ILOGLZAxis.drawGrid">
            <summary>
            draw all grid lines for axis
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILBarGraph2D">
            <summary>
            simple updatable bar graph implementation, fixed number of bars, simple example implementation derived from ILSceneGraph
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILPlot">
            <summary>
            (abstract) base class for all higher level plot objects
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph2D.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILInArray{System.Single})">
            <summary>
            create new 2D bar graph
            </summary>
            <param name="panel">hosting panel</param>
            <param name="data">numeric vector data, heights of bars</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph2D.Queue(System.Single)">
            <summary>
            add 'new' bar with new value and remove oldest bar
            </summary>
            <param name="value">height of new bar</param>
            <returns>discarded value</returns>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.OpacityOldest">
            <summary>
            Sets the opacity for the 'oldest' bar. May be used as 'Fading-Out' effect. (Default: 255)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.BarWidth">
            <summary>
            padding between graphs 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.Count">
            <summary>
            number of bars in the graph
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph2D.Item(System.Int32)">
            <summary>
            return reference to single bar (ILQuad) by index
            </summary>
            <param name="index">index of the bar</param>
            <returns>the bar shape as ILQuad</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILBarGraph3D">
            <summary>
            Simple 3D Bar Graph - plot
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILInArray{System.Single})">
            <summary>
            create a new 3D Bar Graph plot, provide data matrix
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="data">data matrix, at least 2x2 entries</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.SetLabels(ILNumerics.Drawing.ILPanel,System.String,System.String,System.String,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <summary>
            set axes labels and tick labels at once
            </summary>
            <param name="panel">panel hosting the plot</param>
            <param name="xlabel">label text for x axis</param>
            <param name="ylabel">label text for y axis</param>
            <param name="zlabel">label text for z axis</param>
            <param name="xtickLabels">collection of strings for columns labels (x-direction)</param>
            <param name="ytickLabels">collection of strings for row labels (x-direction)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILBarGraph3D.ConfigurePanel(ILNumerics.Drawing.ILPanel)">
            <summary>
            configure default view of panel, called when adding the plot to the panel
            </summary>
            <param name="panel">panel hosting the plot</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph3D.Opacity">
            <summary>
            get/set opacity of the bars
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILBarGraph3D.Item(System.Int32,System.Int32)">
            <summary>
            individual access to each bar (ILLitBox) 
            </summary>
            <param name="row">row index, 0 based</param>
            <param name="col">column index, 0 based</param>
            <returns>lit box shape at specified position</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitBox3D">
            <summary>
            the plot displays a simple colored lit 3D box
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            create new lit 3D box
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="min">minimum coordinates defining the box' dimensions (x,y,z)</param>
            <param name="max">minimum coordinates defining the box' dimensions (x,y,z)</param>
            <param name="fillColor">overall color for the box</param>
            <param name="topColor">color used to color the top edges of the box</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            (internally used) draws the plot 
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.m_lineProperties_Changed(System.Object,System.EventArgs)">
            <summary>
            update all quad borders with new settings
            </summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.updateColors">
            <summary>
            distribute changed color settings to all quads 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitBox3D.SetColorGradient(ILNumerics.Drawing.Shapes.ILLitQuad,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color,System.Drawing.Color)">
            <summary>
            color settings helper
            </summary>
            <param name="quad">quad index</param>
            <param name="col0">color 1</param>
            <param name="col1">color 2</param>
            <param name="col2">color 3</param>
            <param name="col3">color 4</param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Opacity">
            <summary>
            get the opacity for the box or set it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.GradientColor">
            <summary>
            the color used at one corner for each quad to generate a simple gradient effect 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Edges">
            <summary>
            properties of the edge lines 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.FillColor">
            <summary>
            overall fill color (bottom and lower area of color gradient) 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.TopColor">
            <summary>
            top color (top and upper area of color gradient)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.ValueLabel">
            <summary>
            reference to the label which renders the current z-value onto the top area (world coords)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.TopLabel">
            <summary>
            label drawn in screen coords on top of the lit box
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitBox3D.Quads">
            <summary>
            get reference to the quads, the lit box is assembled out of
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitBox3D.QuadIndices">
            <summary>
            enum for all 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitSink">
            <summary>
            ILNumerics.Drawing plot demonstration, supports multiple shapes, dynamic shape management, light and transparency
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.m_timer_Tick(System.Object,System.EventArgs)">
            <summary>
            timer tick event handler, called for updates of the interval timer
            </summary>
            <param name="sender">(not used) always this sink plot itself</param>
            <param name="e">(not used)</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create new lit sink plot, assign default values 
            </summary>
            <param name="panel">panel hosting the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.#ctor(ILNumerics.Drawing.ILPanel,System.Single,System.Int32)">
            <summary>
            create new lit sink
            </summary>
            <param name="max">lenght of the squared ground</param>
            <param name="panel">panel hosting the scene</param>
            <param name="resolution">horizontal and vertical resolution</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.Configure">
            <summary>
            called once before rendering the frame, (re)configures the shapes after changes have been made to them
            </summary>
            <remarks><para>ILPlot plots can (not must) override this method. It is called, right before the scene is 
            rendered on screen. Since the containing shapes are independently configured, here (in ILPlot) we
            do only need to (re)configure those content of the plot, which must be recreated after changes have been 
            applied. In ILLitSink, e.g., changes to the sphere and the ground (ILLitSurface) are directly distributed 
            to the related shapes respectively. This happens, when calling any ILShape.Update() overload or after 
            ILShape.Invalidate() has been called. Those shapes will than reconfigure itself and must not be handled here. </para> 
            <para>In contrast to that, the (moving) grid lines of the sink plot are constantly created and removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.ConfigurePanel(ILNumerics.Drawing.ILPanel)">
            <summary>
            configure the panel according to default settings of this plot
            </summary>
            <param name="panel">panel hosting the scene</param>
            <remarks>In order to force a custom configuration of the panel, 
            the plot implements the IILPanelConfigurator interface. For every plot 
            implementing this interface, the panel will be configured by this 
            function once the plot was added to the scene/ to the panel graphs collection.
            If the plot does not implement this interface, the panel settings will 
            not be altered.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Interval">
            <summary>
            get/ set the interval for updates of the moving grid lines [ms]
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Opacity">
            <summary>
            Overall opacity for the ground 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Colormap">
            <summary>
            colormap used for coloring the ground
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Sphere">
            <summary>
            get reference to the lit sphere 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.Ground">
            <summary>
            get reference to ILLitSurface (i.e. the ground)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSink.LinesPositionOffset">
            <summary>
            offset for the grid lines (for moving effect) 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.Computation.CreateMesh(System.Single,System.Single,System.Single,System.Single,System.Int32)">
            <summary>
            create data needed to create the ground (ILLitSurface)
            </summary>
            <param name="Min">minimum (x and y)</param>
            <param name="Max">maximum (x and y)</param>
            <param name="cut">minimum sinkhole level</param>
            <param name="zNiveau">overall zero level</param>
            <param name="resol">horizontal and vertical resolution</param>
            <param name="result">cell vector with X, Y and Z array</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSink.Computation.CreateLines(System.Single,System.Single,System.Single,System.Single,System.Int32,System.Single,System.Single)">
            <summary>
            create data needed to create grid lines 
            </summary>
            <param name="Min">minimum (x and y)</param>
            <param name="Max">maximum (x and y)</param>
            <param name="cut">minimum sinkhole level</param>
            <param name="zNiveau">overall zero level</param>
            <param name="resol">horizontal and vertical resolution</param>
            <param name="gridSpacing">spacing between adjacent grid lines</param>
            <param name="gridOffset">starting offset for the grid lines at edges</param>
            <param name="result">list of X,Y and Z arrays</param>
            <remarks>Only the X grid is created. Since we only have squared sink ground, the 
            same data can be used for the y grid. </remarks>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILLitSurface">
            <summary>
            surface plot supporting light and transparency
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            create new lit surface, provide data heights (Z values)
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="Z">data matrix, at least 2 rows, 2 columns</param>
            <param name="colormap">colormap used for auto coloring the surface</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.Misc.ILColormap)">
            <summary>
            create new lit surface, provide data for X,Y and Z coordinates
            </summary>
            <param name="panel">the panel hosting the scene</param>
            <param name="X">X coordinates matrix, same size as Z or null</param>
            <param name="Y">Y coordinates matrix, same size as Z or null</param>
            <param name="Z">Z data matrix, at least 2 rows, 2 columns</param>
            <param name="colormap">colormap used for auto coloring the surface</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILLitSurface.Configure">
            <summary>
            (re)configure the plot, causes a recreation of all quads due to changed parameters
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Opacity">
            <summary>
            Overall opacity for the surface 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Colormap">
            <summary>
            colormap used for coloring the surface 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Label">
            <summary>
            reference to the label for the surface
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.XValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.YValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.ZValues">
            <summary>
            get a reference to the data values or sets it, used for updates to the plot
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILLitSurface.Quads">
            <summary>
            get reference to IILLitQuads lit composite shape used for rendering the surface
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Plots.ILVectorField2D">
            <summary>
            visualizes 2D vector fields
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Plots.ILVectorField2D.m_colormap">
            <summary>
            Colormap used to map values to colors
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.ILInArray{System.Single},ILNumerics.Drawing.Misc.ILColormap,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{System.String})">
            <summary>
            create new vector field (2D) plot 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="data">3d data array: :;:;0 - X coords of vectors, :;:;1 - Y coords</param>
            <param name="colormap">Colormap used for coloring, on null: Colormaps.ILNumerics is used as default</param>
            <param name="XLabels">labels for X axis, on null: auto labeling</param>
            <param name="YLabels">labels for Y axis, on null: auto labeling</param>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.Configure">
            <summary>
            (internal use) reconfigures the plot after changes
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.ConfigurePanel(ILNumerics.Drawing.ILPanel)">
            <summary>
            configure the panel, called after the plot was added to the scene
            </summary>
            <param name="panel"></param>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.Data">
            <summary>
            gets reference to data of all vectors or sets it (restricted to same size)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.Colormap">
            <summary>
            get the colormap used for coloring the arrows or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.ArrowHeadAngle">
            <summary>
            opening angle for the arrow heads, default: 5 deg
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.ArrowScale">
            <summary>
            Scaling of arrow length, 1.0: full size; default: 0.9
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.LinesShape">
            <summary>
            enables access to the lines composite shape used for rendering
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.XLabels">
            <summary>
            collection of label texts for x axis
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Plots.ILVectorField2D.YLabels">
            <summary>
            collection of label texts for y axis
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Plots.ILVectorField2D.Computation.CreateTestData(System.Int32,System.Int32,System.Single)">
            <summary>
            create data for a simple vector field for demonstration purposes
            </summary>
            <param name="numRows">number of rows</param>
            <param name="numCols">number of colums</param>
            <param name="offs">offset, linearly varing values lets the field 'roll'</param>
            <returns>three dimensional data array</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Resources.Images">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Images.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Images.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Resources.Markers">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Markers.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Resources.Markers.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILBorderedShape`1">
            <summary>
            Base class for all simple shapes, rendering a primitive 
            with a border, which is independantly configurable. 
            </summary>
            <typeparam name="VertexType">inner vertex element type (struct)</typeparam>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILShape`1">
            <summary>
            abstract generic shape, specific vertex type
            </summary>
            <typeparam name="VertexType">the internal vertex type, IILVertexDefinition</typeparam>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILShape">
            <summary>
            abstract base class for all shapes 
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create new shape (protected) 
            </summary>
            <param name="panel">panel hosting the scene</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Dispose">
            <summary>
            may be overwritten in derived classes to clean up ressources
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.GetVertex(System.Int32)">
            <summary>
            Query single vertex via IILVertexDefinition interface 
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <returns>vertex definition</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetColor(System.Int32,System.Drawing.Color)">
            <summary>
            set color for single vertex (color only, no alpha!)
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="color">new color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetPosition(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set position if single vertex 
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="position">new position </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetNormal(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set normal vector for single vertex
            </summary>
            <param name="id">index of vertex in vertex array</param>
            <param name="normal">new normal vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.SetVertex(System.Int32,ILNumerics.Drawing.Interfaces.IILVertexDefinition)">
            <summary>
            alter single vertex via IILVertexDefinition interface
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="vertex">new vertex definition</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Translate(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            translate all vertices of the shape
            </summary>
            <param name="offset">offset, all vertices will be moved by that amount</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Draw(ILNumerics.Drawing.ILRenderProperties)">
            <summary>
            draw this shape (internal use) 
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Configure">
            <summary>
            configure this shape (internal use)
            </summary>
            <remarks>Configure is called once for each rendering frame. If the shape 
            is invalidated, this causes IntConfigure to be called on the shape.</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape.Invalidate">
            <summary>
            Invalidates this shape, needed after altering any vertex data
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Shapes.ILShape.Changed">
            <summary>
            fires, when any properties of the shape have changed
            </summary>
        </member>
        <member name="E:ILNumerics.Drawing.Shapes.ILShape.SizeChanged">
            <summary>
            fires when the size of the shape has changed
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Visible">
            <summary>
            Gets visibility of the shape or sets it
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.SceneGraphNode">
            <summary>
            returns the scene graph node holding this shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.PositionMin">
            <summary>
            Get minimum coordinate of the cube enclosing the shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.PositionMax">
            <summary>
            Get maximum coordinate of the cube enclosing the shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Center">
            <summary>
            Get weight center of vertices 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Shading">
            <summary>
            Get/set method of area filling 
            </summary>
            <remarks><para>Two methods are available: 'Interpolate' and 'Flat'. For 'Interpolate' mode,
            the color and alpha values stored in individual vertices are used for rendering. 
            In 'Flat' mode, only the single properties 'FillColor' and 'Opacity' determine 
            the color and transparency of the whole shape. Even if vertices store individual
            color values, those are ignored in that case.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.FillColor">
            <summary>
            fill color for shape areas in flat shading mode
            </summary>
            <remarks>Setting this value will not alter the alpha value 
            (opacity). The alpha of the new value will be ignored.</remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.VertexDefinition">
            <summary>
            definition of internal vertex type (readonly)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Opacity">
            <summary>
            opacity for areas of the shape in flat shading mode 
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.Label">
            <summary>
            Shape label
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount">
            <summary>
            number of vertices a shape (or all components of a shape) of this type is made out of
            </summary>
            <remarks>For triangle shapes and related (lit triangles, triangles etc.) this is 3, for quads it is 4 and so on...</remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.GetVertex(System.Int32)">
            <summary>
            Query single vertex via IILVertexDefinition interface 
            </summary>
            <param name="i">index of vertex in vertex array</param>
            <returns>vertex definition</returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetVertex(System.Int32,ILNumerics.Drawing.Interfaces.IILVertexDefinition)">
            <summary>
            alter single vertex via IILVertexDefinition interface
            </summary>
            <param name="vertexIdx">index of vertex in vertex array</param>
            <param name="vertex">new vertex definition</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetColor(System.Int32,System.Drawing.Color)">
            <summary>
            set color for single vertex (color only, no alpha!)
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="color">new color</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetPosition(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set position of single vertex 
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="position">new position </param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.SetNormal(System.Int32,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            set normal vector of single vertex
            </summary>
            <param name="vertexID">index of vertex in vertex array</param>
            <param name="normal">new normal vector</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILShape`1.Translate(ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            translate all vertices of the shape
            </summary>
            <param name="offset">offset, all vertices will be moved by that amount</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.Vertices">
            <summary>
            access to internal vertex array
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape">
            <summary>
            number of vertices per shape
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.CustomCenter">
            <summary>
            get or manually define the center of the shape
            </summary>
            <remarks>Once an individual (custom) center was assigned to the CustomCenter
            property, that point is returned and used on subsequent queries for Center. 
            <para>In order to clear the custom center, set the CustomCenter property to ILPoint3Df.Emtpy.</para>
            <para>The center is important to position the shape in the scene - according to 
            other shapes. This defines the order in which the shapes are rendered, which 
            is neccessary for transparency to appear correctly. In general one should
            not alter the center. This will compute the center of a shape accordingly to its 
            real vertices weight average. However, for certain special shapes it might 
            be helpful to override the center to manually determine the rendering order in the scene.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILShape`1.VertexDefinition">
            <summary>
            internal vertex definition (readonly)
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILBorderedShape`1.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create new bordered shape
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of vertices, this bordered shape will be made out of</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILBorderedShape`1.Update(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single})">
            <summary>
            update vertices of the shape
            </summary>
            <param name="X">X positions vector</param>
            <param name="Y">Y positions vector</param>
            <param name="Z">Z positions vector</param>
            <remarks><para> The positions of the vertices are altered only. Other attributes are not altered. X, Y and Z must be 
            vectors, scalars or <c>null</c>.</para>
            <para>If any of <paramref name="X"/>,<paramref name="Y"/> or <paramref name="Z"/> is a vector, its elements are transfered to the corresponding position part (X,Y or Z) 
            of the corresponding vertices. If any vector is longer than the current <see cref="!:VertexCount"/>, the number of vertices currently managed by this shape is expanded. If any of 
            the vectors is smaller than <see cref="!:VertexCount"/>, trailing vertices are not touched.</para>
            <para>If any of <paramref name="X"/>,<paramref name="Y"/> or <paramref name="Z"/> is a scalar, its value is applied to <b>all</b> corresponding positioning parts of all vertices.</para>
            <para>If any of <paramref name="X"/>,<paramref name="Y"/> or <paramref name="Z"/> is <c>null</c>, the corresponding part of the vertices are not altered.</para></remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILBorderedShape`1.Border">
            <summary>
            get reference to the properties of the shapes border 
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_renderIndices">
            <summary>
            actual indices used for rendering (sorted for translucent shapes)
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_shapeIndices">
            <summary>
            cache indices defining each shapes corners
            </summary>
        </member>
        <member name="F:ILNumerics.Drawing.Shapes.ILCompositeShape`1.m_oldCameraPosition">
            <summary>
            cache camera position of last sorting
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.#ctor(ILNumerics.Drawing.ILPanel,System.Int32,System.Int32)">
            <summary>
            create composite shape
            </summary>
            <param name="panel">scene hosting the scene</param>
            <param name="numVertices">number of overall vertices for the shape</param>
            <param name="verticesPerShape">Number of vertices per shape</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Update(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Int32},ILNumerics.ILInArray{System.Int32})">
            <summary>
            update vertices of this shape
            </summary>
            <param name="inX">x coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="inY">y coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="inZ">z coordinates, vector of length <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/></param>
            <param name="mapping">Mapping of shapes, composes shapes out of vertices. Matrix having
            <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> rows.
            Every element in a column specifies the index of a vertex according to its position in X,Y,Z.
            The <see cref="P:ILNumerics.Drawing.Shapes.ILShape`1.VerticesPerShape"/> elements in a column therefore
            compose a single shape. Vertices may get used arbitrary times (or not at all). All elements must be
            positive integer values in range 0...[<see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/>-1].</param>
            <param name="colors">matrix with <see cref="P:ILNumerics.Drawing.Shapes.ILShape.VertexCount"/> 
            rows, 3 columns for (R,G,B) or 4 columns for 
            (A,R,G,B) for every vertex specified by X,Y,Z. Elements must range from 0..255. If colors 
            has 3 columns only, alpha values of 255 are used as default.</param>
            <remarks>All vertices of the shape are updated with the data specified in X,Y and Z. Neither the colors or any
            other data of vertices are changed, if they are not provided. The shape is invalidated for reconfiguration at next redraw. </remarks>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILCompositeShape`1.Indices">
            <summary>
            Indices used to render primitives from vertices 
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLine">
            <summary>
            A simple single line
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.#ctor(ILNumerics.Drawing.ILPanel)">
            <summary>
            create new simple line with 2 ends
            </summary>
            <param name="panel"></param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLine.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create new line, determine number of vertices
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of vertices for the line</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Properties">
            <summary>
            [deprecated] line properties, use individual properties of ILLine instead
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.OldestVertexID">
            <summary>
            the oldest vertex to be removed on the next Queue() call
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Antialiasing">
            <summary>
            determines, if the line is to be drawn antialiased (on width > 1 only)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Pattern">
            <summary>
            stipple pattern for the line, if Style is set to custom pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.PatternScale">
            <summary>
            scaling for the stipple pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Style">
            <summary>
            line style, default: solid
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.Width">
            <summary>
            line width (pixels)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLine.FillColor">
            <summary>
            inner color of the line
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLines.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            Create new lines composite shapes, prepare memory for vertices only
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="numVertices">number of overall vertices in the shape</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Properties">
            <summary>
            all properties for the lines (in shading mode 'flat')
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Antialiasing">
            <summary>
            determines, if the line is to be drawn antialiased (on width > 1 only)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Pattern">
            <summary>
            stipple pattern for the line, if Style is set to custom pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.PatternScale">
            <summary>
            scaling for the stipple pattern
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Style">
            <summary>
            line style, default: solid
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.Width">
            <summary>
            line width (pixels)
            </summary>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILLines.FillColor">
            <summary>
            color for the lines (in shading mode 'flat')
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitBorderedShape`1">
            <summary>
            Base class for all simple, bordered shapes to be used within ILNumerics.Drawing scene graphs
            </summary>
            <typeparam name="VertexType"></typeparam>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.#ctor(ILNumerics.Drawing.ILPanel,System.Int32,System.Int32)">
            <summary>
            create light composite shape
            </summary>
            <param name="panel">scene hosting the scene</param>
            <param name="numVertices">number of overall vertices for the shape</param>
            <param name="verticesPerShape">Number of vertices per shape</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.Computation.CreateShapeIndicesIndex(ILNumerics.ILInArray{System.Int32})">
            <summary>
            Creates the index of the shape indices.
            </summary>
            <param name="shapeIndices">The shape indices.</param>
            <returns>index of shape indices</returns>
            <remarks>The index of shape indices is used for fast facette lookup while (auto) creating
            the normal vectors for the vertices. Therefore, the index of every vertex used in the shape
            serves as index for a list of those facettes, where that vertex occures.
            <para>TODO: may be replaced by a custom data structure in order to decrease memory requirements?</para></remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitCompositeShape`1.Computation.CalculateNormals(`0[],ILNumerics.ILInArray{System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Collections.Generic.List{System.Int32}})">
            <summary>
            Calculates the normals.
            </summary>
            <param name="vertices">vertex array of the shape</param>
            <param name="shapeIndices">The shape mapping indices.</param>
            <param name="shapeIndicesIndex">Index of the shape indices.</param>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitPolygon">
            <summary>
            A simple lit polygon, rendering arbitrary number of corners, bordered, supports light
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitPolygon.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create a new polygon
            </summary>
            <param name="panel">panel to create the polygon for</param>
            <param name="numVertices">number of vertices for the polygon</param>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitQuad">
            <summary>
            A single simple bordered quad supporting light
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitQuads">
            <summary>
            a litable shape, assembled out of an arbitrary number of quads
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitQuads.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create composite shape, consisting out of lit quads 
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices needed for all lit quads</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.ILPoint3Df,System.Single,System.Drawing.Color)">
            <summary>
            create new lit sphere, resolution of 3 
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="center">center position</param>
            <param name="radius">radius of the sphere</param>
            <param name="color">color of the sphere</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.#ctor(ILNumerics.Drawing.ILPanel,ILNumerics.Drawing.ILPoint3Df,System.Single,System.Drawing.Color,System.Int32)">
            <summary>
            create new lit sphere for a scene graph
            </summary>
            <param name="panel">panel hosting the scene</param>
            <param name="center">center position</param>
            <param name="radius">radius of the sphere</param>
            <param name="color">color of the sphere</param>
            <param name="detail">number of triangularization iterations, typical: 0..4</param>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.Triangularize(ILNumerics.ILInArray{System.Single},ILNumerics.ILInArray{System.Int32},System.Int32,ILNumerics.ILOutArray{System.Single},ILNumerics.ILOutArray{System.Int32})">
            <summary>
            increase the number of triangles by doubling existing triangles
            </summary>
            <param name="vertices">vertices</param>
            <param name="triangles">triangle index definitions</param>
            <param name="iterations">number of iterations. On each iteration, 4 triangles will replace every single triangle!</param>
            <param name="outVertices">The out vertices.</param>
            <param name="outTriangles">The out triangles.</param>
            <remarks><para>Incoming triangles are expected not to be degenerated. This means:
            Every edge is used only twice at most. No triangle shares more than 2
            corners with some other triangle. </para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.CreateVertices(ILNumerics.Drawing.ILPoint3Df,System.Single,System.Int32,System.Int32,ILNumerics.ILOutArray{System.Int32})">
            <summary>
            create vertex data [unevenly distributed, depricated]
            </summary>
            <param name="center"></param>
            <param name="radius"></param>
            <param name="horRes"></param>
            <param name="vertRes"></param>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitSphere.Computation.CreateVerticesTri(System.Int32,ILNumerics.ILOutArray{System.Int32})">
            <summary>
            create vertices by triangularization, starting from icosahedron and subseq. creating finer grained details
            </summary>
            <param name="detail">number of iterations for triangularization</param>
            <param name="indices">out param: return triangles</param>
            <returns>vertex data</returns>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILLitTriangle">
            <summary>
            A single simple bordered triangle supporting light
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILLitTriangles.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create lit triangles
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertex data must be defined afterwards.</param>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILPoints">
            <summary>
            points rendering shape, to be used in scene graphs
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILPoints.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create new points 
            </summary>
            <param name="panel">panel hosting the scene graph</param>
            <param name="numPoints">number of points to create</param>
        </member>
        <member name="P:ILNumerics.Drawing.Shapes.ILPoints.Width">
            <summary>
            size (of all points)
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILPolygon">
            <summary>
            A simple polygon, rendering arbitrary number of corners, bordered
            </summary>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILQuad">
            <summary>
            A single simple bordered quad
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILQuads.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create quads, for delayed vertex definition
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertices must be filled 
            with data manually afterwards.</param>
        </member>
        <member name="T:ILNumerics.Drawing.Shapes.ILTriangle">
            <summary>
            A simple bordered triangle
            </summary>
        </member>
        <member name="M:ILNumerics.Drawing.Shapes.ILTriangles.#ctor(ILNumerics.Drawing.ILPanel,System.Int32)">
            <summary>
            create triangles, for delayed vertex definition
            </summary>
            <param name="panel">hosting panel</param>
            <param name="numVertices">number of vertices to create. Vertices must be filled 
            with data manually afterwards.</param>
        </member>
        <member name="T:ILNumerics.MachineParameterSingle">
            <summary>
            Extensive numerical machine parameter infos - single precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterSingle.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.MachineParameterDouble">
            <summary>
            Extensive numerical machine parameter infos - double precision
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ibeta">
            <summary>
            Radix
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.it">
            <summary>
            Number of base digits(bits) in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.irnd">
            <summary>
            Rounding and underflow information.  
            </summary>
            <remarks><list type="bullet"><listheader>Rounding properties</listheader>
            <item>2,5: IEEE rounding conform </item>
            <item>1,4: not IEEE conform rounding </item>
            <item>0,3: truncating - no rounding </item></list>
            <list type="bullet"><listheader>Under-/ Overflow. numbers below xmin will be interpreted as... </listheader>
            <item>0,1,2: zero</item>
            <item>3,4,5: xmin (IEEE conform)</item></list></remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.ngrd">
            <summary>
            Number of guard digits in the product of 2 mantissas
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.machep">
            <summary>
            Exponent of the smalles number ibeta^machep &gt; 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.negep">
            <summary>
            Exponent of smallest number ibeta^negep wich may be substracted from 1.0, giving a result not equal to 1.0
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.iexp">
            <summary>
            Number of exponent bits 
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.minexp">
            <summary>
            Smallest power of ibeta without leading zeros in the mantissa
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.maxexp">
            <summary>
            Smallest power of ibeta where overflow occours
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.eps">
            <summary>
            Distance between the smallest number &gt; 1.0, distinguishable from 1.0 and 1.0
            </summary>
            <remarks>This number is computed by ibeta <sup>machep</sup>.</remarks>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.epsneg">
            <summary>
            Alternative eps. ibeta <sup>negep</sup>
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmin">
            <summary>
            Smallest floating point number
            </summary>
        </member>
        <member name="F:ILNumerics.MachineParameterDouble.xmax">
            <summary>
            Largest floating point number
            </summary>
        </member>
        <member name="T:ILNumerics.Toolboxes">
            <summary>
            All toolboxes currently available in ILNumerics 
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.MachineLearning">
            <summary>
             Machine Learning Toolbox
            </summary>
        </member>
        <member name="F:ILNumerics.Toolboxes.Statistics">
            <summary>
            Statistics Toolbox
            </summary>
        </member>
        <member name="T:ILNumerics.LogicalConversionMode">
            <summary>
            Modes for implicit conversions from logical arrays to System.Boolean 
            </summary>
            <remarks>
            <seealso cref="P:ILNumerics.Settings.LogicalArrayToBoolConversion"/></remarks>
        </member>
        <member name="F:ILNumerics.LogicalConversionMode.NonScalarThrowsException">
            <summary>
            Throw an exception on the attempt to convert a non scaler value to logical/boolean.
            </summary>
        </member>
        <member name="F:ILNumerics.LogicalConversionMode.ImplicitAllAll">
            <summary>
            Convert non scalar values to logical/boolean by applying the allall() function (i.e. it is true when all elements are non zero).
            </summary>
        </member>
        <member name="T:ILNumerics.NumericType">
            <summary>
            Enumerate all numeric type names used by ILNumerics
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Double">
            <summary>
            double element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Single">
            <summary>
            float element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Complex">
            <summary>
            complex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.FComplex">
            <summary>
            fcomplex element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Byte">
            <summary>
            byte element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int32">
            <summary>
            Int32 element type.
            </summary>
        </member>
        <member name="F:ILNumerics.NumericType.Int64">
            <summary>
            Int64 element type.
            </summary>
        </member>
        <member name="T:ILNumerics.ILArrayStreamSerializationFlags">
            <summary>
            Defines the way ILArrays are serialized to stream.
            </summary>
            <seealso cref="M:ILNumerics.ILDenseArray`1.ToStream(System.IO.Stream,System.String,ILNumerics.ILArrayStreamSerializationFlags)"/>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Serial">
            <summary>
            Print values 'vectorized': one value after each other. The true dimension configuration 
            of the array will be lost in the result. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Formatted">
            <summary>
            Print values 'matrixwise'. The real dimensions configuration for the array are kept 
            in the result. The array will be printed by pages, consisting out of the 1st and 2nd 
            leading dimnsion. A dimension tag will prefix each page. The format can be used as 
            fancier output version for human reading as well as human readable serialization 
            format. ILArray's are capable of constructing from streams containing this type of 
            output. 
            </summary>
        </member>
        <member name="F:ILNumerics.ILArrayStreamSerializationFlags.Matlab">
            <summary>
            Export whole array instance to matlab 5.0 format
            </summary>
        </member>
        <member name="T:ILNumerics.MatrixProperties">
            <summary>
            Possible properties for matrices 
            </summary>
            <remarks><para>These properties may be returned by function overloads receiving a MatrixProperties 
            parameter by reference. </para>
            <para><![CDATA[This enum is a bitflag'ed enum! You may query for any combination via the bitwise operators | and &. ]]></para></remarks>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hermitian">
            <summary>
            Hermitian matrix 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.PositivDefinite">
            <summary>
            Positive definite
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.UpperTriangular">
            <summary>
            Upper triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.LowerTriangular">
            <summary>
            Lower triangular matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Square">
            <summary>
            Square matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Diagonal">
            <summary>
            Diagonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Singular">
            <summary>
            The matrix is singular 
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Hessenberg">
            <summary>
            Hessenberg matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Householder">
            <summary>
            Householder matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unitary">
            <summary>
            Unitary matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthogonal">
            <summary>
            Orthogonal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Orthonormal">
            <summary>
            Orthonormal matrix
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.RankDeficient">
            <summary>
            The matrix has deficient rank
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.None">
            <summary>
            The matrix has no special properties
            </summary>
        </member>
        <member name="F:ILNumerics.MatrixProperties.Unknown">
            <summary>
            No specific properties known (default)
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILCacheManager">
            <summary>
            Manages local array caches, singleton instance is accessed via: ILNumerics.ILArrayCache&lt;T;gt;.Manager
            </summary>
        </member>
        <member name="M:ILNumerics.Misc.ILCacheManager.GetCache">
            <summary>
            Create a new ILArrayCache and add to managed caches
            </summary>
            <returns>The new cache</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILCacheManager.FreeAllCaches">
            <summary>
            Dispose all managed caches
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILCacheManager.Manager">
            <summary>
            Singleton instance of a cache manager, used to retrieve local array caches 
            </summary>
        </member>
        <member name="T:ILNumerics.complex">
            <summary>
            Floating point complex value data type of double precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex double 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point system.double brings (abs, log, sqrt, tan etc.),
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to complex value into system 
            value types.</remarks>
        </member>
        <member name="F:ILNumerics.complex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.complex.i">
            <summary>
            Imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.complex.#ctor(System.Double,System.Double)">
            <summary>
            Constructor creating a new complex value
            </summary>
            <param name="real">Real part</param>
            <param name="imag">Imaginary part</param>
        </member>
        <member name="M:ILNumerics.complex.Equals(System.Object)">
            <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.complex.Equals(ILNumerics.complex)">
            <summary>
            Check if a complex number equals this complex number
            </summary>
            <param name="other">other complex number</param>
            <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.GetHashCode">
            <summary>
            Hash code of this comples
            </summary>
            <returns>Hash code of this complex</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Double)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Double)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Double)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Double)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Double)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Double)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Double)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Double)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Double)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int64)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int64)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int64)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int64)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int64)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int64)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int64)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int64)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Int32)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Int32)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Int32)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Int32)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Int32)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Int32)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Int32)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Int32)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Single)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Single)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Single)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Single)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Single)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Single)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Single)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Single)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Single)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(ILNumerics.complex,System.Byte)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(ILNumerics.complex,System.Byte)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(ILNumerics.complex,System.Byte)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(ILNumerics.complex,System.Byte)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(ILNumerics.complex,System.Byte)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(ILNumerics.complex,System.Byte)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(ILNumerics.complex,System.Byte)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(ILNumerics.complex,System.Byte)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Double,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Double,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Double,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Double,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Double,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Double,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Double,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Double,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Double,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int64,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int64,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int64,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int64,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int64,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int64,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int64,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Int32,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Int32,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Int32,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Int32,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Int32,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Int32,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Int32,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Single,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Single,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Single,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Single,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Single,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Single,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Single,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Single,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Single,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Addition(System.Byte,ILNumerics.complex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Subtraction(System.Byte,ILNumerics.complex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Multiply(System.Byte,ILNumerics.complex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Division(System.Byte,ILNumerics.complex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Equality(System.Byte,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Inequality(System.Byte,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThan(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThan(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_GreaterThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_LessThanOrEqual(System.Byte,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_UnaryNegation(ILNumerics.complex)">
            <summary>
            Unary minus operator
            </summary>
            <param name="A">Complex input</param>
            <returns>Complex number similar to A, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Double)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Single)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as the a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(ILNumerics.fcomplex)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number being a copy of the real and imaginary parts of a.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Byte)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int32)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Implicit(System.Int64)~ILNumerics.complex">
            <summary>
            Cast value to complex number
            </summary>
            <param name="a">Value to cast</param>
            <returns>Complex number with the real part having the same value as a and the imaginary part is 0.</returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Double">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Double number with the real part of a </returns>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Single">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast from double to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~ILNumerics.fcomplex">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>float complex number with the real and imaginary parts being a copy of a </returns>
            <remarks>The real and imaginary parts are the result of a cast to float.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Byte">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Number with the real part of a </returns>
            <remarks>The return value is the result of a cast to byte.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int32">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>Number with the real part of a </returns>
            <remarks>The return value is the result of a cast to Int32.</remarks>
        </member>
        <member name="M:ILNumerics.complex.op_Explicit(ILNumerics.complex)~System.Int64">
            <summary>
            Cast value from complex number
            </summary>
            <param name="a">Complex value to cast</param>
            <returns>number with the real part of a </returns>
            <remarks>the return value is the result of a cast to Int64.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Abs(ILNumerics.complex)">
            <summary>
            Absolute value of input
            </summary>
            <param name="input">Input value</param>
            <returns>The absolute value of the input</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle(ILNumerics.complex)">
            <summary>
            Phase angle of complex number
            </summary>
            <param name="input">Input value</param>
            <returns>The phase angle of the input</returns>
            <remarks>For the result the Atan2 function of the <see cref="T:System.Math"/> class is used.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Atan(ILNumerics.complex)">
            <summary>
            Arcus tangens of complex input
            </summary>
            <param name="input">Complex input</param>
            <returns>Arcus tangens of complex input</returns>
            <remarks></remarks>
        </member>
        <member name="M:ILNumerics.complex.Acos(ILNumerics.complex)">
            <summary>
            Arcus cosinus of complex input
            </summary>
            <param name="input">Complex input</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos(System.Double)">
            <summary>
            Arcus cosinus of input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus cosinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(System.Double)">
            <summary>
            Arcus sinus of complex input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin(ILNumerics.complex)">
            <summary>
            Arcus sinus of input
            </summary>
            <param name="input">Input value</param>
            <returns>Arcus sinus of  input</returns>
        </member>
        <member name="M:ILNumerics.complex.Ceiling(ILNumerics.complex)">
            <summary>
            Round towards positive infinity
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the next integer value greater then input</returns>
            <remarks>ILMath.Ceiling operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Floor(ILNumerics.complex)">
            <summary>
            Round towards negative infinity
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the next integer value lower then input</returns>
            <remarks>ILMath.Floor operates in both: real and imaginary parts seperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Round(ILNumerics.complex)">
            <summary>
            Rounds towards nearest integer
            </summary>
            <param name="input">Input value</param>
            <returns>Result is the nearest integer value for input</returns>
            <remarks>ILMath.Round operates in both: real and imaginary parts deperately</remarks>
        </member>
        <member name="M:ILNumerics.complex.Sign(ILNumerics.complex)">
            <summary>
            Signum function
            </summary>
            <param name="input">Complex input </param>
            <returns>Sesult as input / Abs(input)</returns>
            <remarks>Sign(input) with input being complex returns the projection onto
            the unit circle. If input is 0+0i the result will be 0+0i.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Truncate(ILNumerics.complex)">
            <summary>
            Truncate a floating point complex value
            </summary>
            <param name="input">Input value</param>
            <returns>Integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Cos(ILNumerics.complex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">Input value</param>
            <returns>Cosine of input</returns>
            <remarks><para>The cosine is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Cosh(ILNumerics.complex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">Input</param>
            <returns>Cosine hyperbolicus of input</returns>
            <remarks><para>The cosine is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sin(ILNumerics.complex)">
            <summary>
            Sinus
            </summary>
            <param name="input">Input value</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Sinh(ILNumerics.complex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">Input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Exp(ILNumerics.complex)">
            <summary>
            Complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>Result of exp(exponent)</returns>
            <remarks>For complex exponents, exp(exponent) is computed by
            <para>complex.FromPol(Math.Exp(exponent.real), exponent.imag)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,System.Double)">
            <summary>
            Complex power for real exponent
            </summary>
            <param name="input">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Result of input power exponent</returns>
            <remarks>The computation will be carried out by 
            <para>exp(log(input) * exponent)</para></remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double,System.Double)">
            <summary>
            Complex power - real basis, real exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Complex number.</returns>
            <remarks>The result will be a complex number. For negative basis 
            the basis will be converted to a complex number and the power 
            will be computed in the complex plane.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex,ILNumerics.complex)">
            <summary>
            Complex power - complex exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>Complex number exp(log(basis) * exponent).</returns>
            <remarks>The result will be the complex number exp(log(basis) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(System.Double)">
            <summary>
            Square root
            </summary>
            <param name="input">Input value</param>
            <returns>The square root of input</returns>
            <remarks>If input is smaller than 0.0, the computation will be done in the complex plane. </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt(ILNumerics.complex)">
            <summary>
            Square root
            </summary>
            <param name="input">Input value</param>
            <returns>The square root of input</returns>
            <remarks>Numerical recipes in C: Appendix C </remarks>
        </member>
        <member name="M:ILNumerics.complex.Tan(ILNumerics.complex)">
            <summary>
            Tangens
            </summary>
            <param name="input">Input value</param>
            <returns>Tangens of input</returns>
            <remarks>The tangens is 
            <para>sin(input) / cos(input)</para>
            if cos(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Tanh(ILNumerics.complex)">
            <summary>
            Tangens hyperbolicus
            </summary>
            <param name="input">Input value</param>
            <returns>Tangens hyperbolicus</returns>
            <remarks>The tangens hyperbolicus is 
            <para>sinh(input) / cosh(input)</para>
            if cosh(input) == 0.0+0.0i, INF will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(ILNumerics.complex)">
            <summary>
            Complex logarithm 
            </summary>
            <param name="input">Input value</param>
            <returns>Complex logarithm of input</returns>
            <remarks>The real part of the logarithm is computed by 
            <para>log (abs (input))</para>
            <para>The imaginary part holds the phase of input.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.Log(System.Double)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(System.Double)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.complex.Log2(System.Double)">
            <summary>
            Logarithm of base 2 of real input 
            </summary>
            <param name="input">Input value - may be negative</param>
            <returns>Complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.complex.Log10(ILNumerics.complex)">
            <summary>
            Logarithm of base 10
            </summary>
            <param name="input">Input value</param>
            <returns>Logarithm of base 10</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.Log2(ILNumerics.complex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">Input value</param>
            <returns>Logarithm of base 2.</returns>
            <seealso cref="M:ILNumerics.complex.Log(ILNumerics.complex)"/>
        </member>
        <member name="M:ILNumerics.complex.FromPol(System.Double,System.Double)">
            <summary>
            Convert polar notation into cartesian notation
            </summary>
            <param name="magnitude">Magnitude</param>
            <param name="angle">Phase</param>
            <returns>Complex value having magnitude and phase</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString">
            <summary>
            Convert to string
            </summary>
            <returns>String displaying the comlex number (full precision)</returns>
        </member>
        <member name="M:ILNumerics.complex.ToString(System.Int32)">
            <summary>
            Print formated output of this number, determine number of digits
            </summary>
            <param name="digits">Number of digits</param>
            <returns>Formated output</returns>
        </member>
        <member name="M:ILNumerics.complex.Abs">
            <summary>
            Magnitude of this complex instance
            </summary>
            <returns>Magnitude</returns>
        </member>
        <member name="M:ILNumerics.complex.Angle">
            <summary>
            Phase of this complex instance
            </summary>
            <returns>Phase</returns>
        </member>
        <member name="M:ILNumerics.complex.Acos">
            <summary>
            Arcus cosinus of this complex instance
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Asin">
            <summary>
            Arcus sinus of this complex instance
            </summary>
            <returns>arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.complex.Exp">
            <summary>
            Exponential / power of base e
            </summary>
            <returns>Power of base e</returns>
        </member>
        <member name="M:ILNumerics.complex.Pow(System.Double)">
            <summary>
            Complex power real exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New complex number with result</returns>
            <remarks>If this instance is a and the exponent is e than 
            the result will be the complex number exp(log(a) * e). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Pow(ILNumerics.complex)">
            <summary>
            Complex power - complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>Complex number exp(log(this) * exponent).</returns>
            <remarks>If this instance is a than 
            the result will be the complex number exp(log(a) * exponent). </remarks>
        </member>
        <member name="M:ILNumerics.complex.Sqrt">
            <summary>
            Square root of this complex value
            </summary>
            <returns>Square root of this complex value</returns>
        </member>
        <member name="M:ILNumerics.complex.Log">
            <summary>
            Logarithm of base e
            </summary>
            <returns>Logarithm of base e</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.complex.IsNaN(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.complex.IsInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsPositiveInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are pos.nfinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsNegativeInfinity(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.complex.IsFinite(ILNumerics.complex)">
            <summary>
            Test if any of real or imaginary parts are finite
            </summary>
            <param name="input">Complex number to test</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.complex.iszero">
            <summary>
            Test if both of real or imaginary parts are 0
            </summary>
            <returns>true if real and imag part is 0</returns>
        </member>
        <member name="P:ILNumerics.complex.conj">
            <summary>
            Complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.complex.INF">
            <summary>
            Positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.complex.Zero">
            <summary>
            New complex, real and imaginary parts are zero
            </summary>
        </member>
        <member name="P:ILNumerics.complex.NaN">
            <summary>
            Complex quantity, marked as being "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.ILExtensionMethods">
            <summary>
            Extension methods for ILNumerics types
            </summary>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary> 
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILInArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILOutArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <member name="M:ILNumerics.ILExtensionMethods.ToMSComplex(ILNumerics.ILRetArray{ILNumerics.complex},System.Numerics.Complex[])">
            <summary>
            Convert this complex ILNumerics array to a system array of type System.Numerics.Complex[]
            </summary>
            <param name="A">this ILNumerics array</param>
            <param name="Storage">[option] if given, this system array will be used as storage for the conversion. Defaul: null (a new System.Array is returned)</param>
            <returns>System.Array with the elements of A</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the storage given does not have sufficient length for all elements of the ILNumerics array</exception>
            <remarks><para>The elements of the ILNumerics array will be copied to the System.Array and converted to the System.Numerics.Complex type.</para>
            <para>The System.Array returned will contain all elements of the ILNumerics arrays after conversion - in column major order.</para>
            <example>
            This example demonstrates a common scenario for interchanging System.Numerics.Complex[] with ILNumerics complex arrays. It takes the converion between System.Numerics.Complex and ILNumerics.complex 
            into account, as well as the memory management of all storage involved. 
            <code>
            ILArray&lt;complex&gt; A = sqrtc(B); 
            // interfacing an external library as System.Numerics.Complex[]
            // We dont provide a System.Array as target for the conversion,
            // so it will be fetched from the ILNumerics memory management. 
            System.Numerics.Complex[] A_MSComplex = A.ToMSComplex(); 
            // .. do some work here with A_MSComplex
            // ...
            // The results get converted back to ILNumerics array 
            ILArray&lt;complex&gt; Result = A_MSComplex.ToILArray(A.S, true); 
            </code>
            <para>For the conversion of the System.Numerics.Complex[] array back to an ILNumerics array, we use the same size (<c>A.S</c>) as before. Here, any size 
            would work, as long as it fits into the number of elements of the source System.Array.</para>
            <para>Note that the calls to <c>A.ToMSComplex()</c> and <c>A_MSComplex.ToILArray(A.S, true)</c> will fetch and return all System.Arrays involved into/from the 
            ILINumerics memory pool. So if called frequently, no pressure on the GC is produced, what qualifies this scheme for high performance scenarios.</para> 
            </example>
            </remarks>
            <seealso cref="M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)"/>
        </member>
        <!-- Ung端ltiger XML-Kommentar wurde f端r den Member "M:ILNumerics.ILExtensionMethods.ToILArray(System.Numerics.Complex[],ILNumerics.ILSize,System.Boolean)" ignoriert -->
        <member name="T:ILNumerics.fcomplex">
            <summary>
            Floating point complex value data type of float (single) precision
            </summary>
            <remarks>This class extends the system value types for real numbers to complex float 
            values. Besides the publicly available members 'real' and 'imag' it provides all the 
            basis functionality the floating point System.double brings (abs, log, sqrt, tan etc.) for 
            float precision complex,
            as well as it overrides the basic unary and binary operators for all common system value 
            types including rarely used types (e.g. UInt16). This includes the basic numerical operations 
            like '+','-','/','*' and the relational operators: '==','>','>=' etc. Also there are some 
            explicit and some implicit casting operators from / to fcomplex values into system 
            value types. </remarks>
        </member>
        <member name="F:ILNumerics.fcomplex.real">
            <summary>
            Real part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.imag">
            <summary>
            Imaginary part of this complex number
            </summary>
        </member>
        <member name="F:ILNumerics.fcomplex.i">
            <summary>
            Imaginary unit 
            </summary>
        </member>
        <member name="M:ILNumerics.fcomplex.#ctor(System.Single,System.Single)">
            <summary>
            Construct new float complex number
            </summary>
            <param name="real">Real part</param>
            <param name="imag">Imaginary part</param>
        </member>
        <member name="M:ILNumerics.fcomplex.Equals(System.Object)">
            <summary>
            Are obj's real and imaginary part identical to the real and imaginary parts of this fcomplex
            </summary>
            <param name="obj">fcomplex object to determine the equality for</param>
            <returns>true if obj is of fcomplex type and its real and imag part has the same 
            values as the real and imaginary part of this array.</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Equals(ILNumerics.fcomplex)">
            <summary>
            Check if a fcomplex number equals this fcomplex number
            </summary>
            <param name="other">other complex number</param>
            <returns>true if both, real and imaginary parts of both complex number are (binary) equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.GetHashCode">
            <summary>
            Give HashCode of this fcomplex number
            </summary>
            <returns>HashCode of this fcomplex number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.complex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Subtract two complex values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Multiply two complex values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
            <remarks><para>Unless the operator must handle special inputs (Inf or 0 values), 
            the algorithm described in [1] is used for division. This is considered to be 
            more robust against floating point overflow than the naive approach of simple 
            cartesian division.</para>
            <para>References: [1]: Smith, R.L., Algorithm 116: Complex division. Commun.ACM 5,8 (1962),435 <br />
            [2]: Stewart, G.W., A note on complex division, ACM trans.on math software, Vol.11, N.3 (1985)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true, if real and imaginary part are identical</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int64)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Int32)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Single)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Single)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Single)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Single)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Single)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Single)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Byte)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(ILNumerics.fcomplex,System.Double)">
            <summary>
            Add two complex numbers
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(ILNumerics.fcomplex,System.Double)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(ILNumerics.fcomplex,System.Double)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(ILNumerics.fcomplex,System.Double)">
            <summary>
            Divide two numbers
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(ILNumerics.fcomplex,System.Double)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Freater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(ILNumerics.fcomplex,System.Double)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int64,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Int32,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Single,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Single,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Single,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Single,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Single,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Single,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Addition(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Add two complex values
            </summary>
            <param name="A">First summand</param>
            <param name="B">Second summand</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Subtraction(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Subtract two values
            </summary>
            <param name="A">Minuend</param>
            <param name="B">Subtrahend</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Multiply(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Multiply two values
            </summary>
            <param name="A">First factor</param>
            <param name="B">Second factor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Division(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Divide two values
            </summary>
            <param name="A">Divident</param>
            <param name="B">Divisor</param>
            <returns>Result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Equality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Equality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>Result</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Inequality(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Unequality comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real and imaginary parts of A and B are not equal, false otherwise</returns>
            <remarks>Real inputs are converted to a complex number and the result is compared to the complex input.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThan(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_GreaterThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Greater than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is greater than real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_LessThanOrEqual(System.Byte,ILNumerics.fcomplex)">
            <summary>
            Lower than or equal to comparison for complex numbers
            </summary>
            <param name="A">Left side</param>
            <param name="B">Right side</param>
            <returns>true if real part of A is lower then real part of B, false otherwise</returns>
            <remarks>Only the real parts are compared!</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.op_UnaryNegation(ILNumerics.fcomplex)">
            <summary>
            Unary minus operator
            </summary>
            <param name="in1">fcomplex input</param>
            <returns>fcomplex number similar to in1, having real and imag part negated</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs(ILNumerics.fcomplex)">
            <summary>
            Magnitude value of float complex number
            </summary>
            <param name="input">fcomplex number</param>
            <returns>Magnitude of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle(ILNumerics.fcomplex)">
            <summary>
            Angle of complex number
            </summary>
            <param name="input">fcomplex number to compute angle of</param>
            <returns>Angle of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)">
            <summary>
            Arcus cosinus for float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus cosinus of input</returns>
            <remarks>The arcus cosinus of a complex number is computed by
            <para>Log(Sqrt(input^2 - 1) + input) * i </para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos(System.Single)">
            <summary>
            Arcus cosinus of real number
            </summary>
            <param name="input">float input</param>
            <returns>Arcus cosinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Acos(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(System.Single)">
            <summary>
            Arcus sinus of real number
            </summary>
            <param name="input">float input</param>
            <returns>Arcus sinus of input</returns>
            <remarks>For input &gt; 1.0, <see cref="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)"/> will be used. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin(ILNumerics.fcomplex)">
            <summary>
            Arcus sinus for complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus sinus of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp(ILNumerics.fcomplex)">
            <summary>
            Power of base e for float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Result of Exp(input)</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,System.Double)">
            <summary>
            fcomplex power real exponent
            </summary>
            <param name="input">Basis </param>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double,System.Double)">
            <summary>
            Complex power - real basis, real exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>fcomplex number.</returns>
            <remarks>The result will be a fcomplex number. For negative basis 
            the basis will be converted to a fcomplex number and the power 
            will be computed in the fcomplex plane.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex,ILNumerics.fcomplex)">
            <summary>
            Power: complex base, complex exponent
            </summary>
            <param name="basis">Basis</param>
            <param name="exponent">Exponent</param>
            <returns>result of basis^exponent</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(System.Single)">
            <summary>
            Square root of real input
            </summary>
            <param name="input">float input</param>
            <returns>Square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt(ILNumerics.fcomplex)">
            <summary>
            Square root of complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Square root of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tan(ILNumerics.fcomplex)">
            <summary>
            Tangens of float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Tanh(ILNumerics.fcomplex)">
            <summary>
            Tangens hyperbolicus of float complex input
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Tangens hyperbolicus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(ILNumerics.fcomplex)">
            <summary>
            Logarithm of complex input
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(ILNumerics.fcomplex)">
            <summary>
            Logarithm to base 10
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(ILNumerics.fcomplex)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Logarithm of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log(System.Single)">
            <summary>
            Logarithm of real input 
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log10(System.Single)">
            <summary>
            Logarithm of base 10 of real input 
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm of base 10</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log2(System.Single)">
            <summary>
            Logarithm of base 2
            </summary>
            <param name="input">float input - may be negative</param>
            <returns>Complex logarithm of base 2</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.FromPol(System.Single,System.Single)">
            <summary>
            Convert from polar to cartesian form
            </summary>
            <param name="magnitude">Magnitude</param>
            <param name="angle">Angle</param>
            <returns>fcomplex number with magnitude <c>magnitude</c> 
            and phase <c>angle</c></returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString">
            <summary>
            Convert this float complex number to string 
            </summary>
            <returns>String representation of this float complex number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.ToString(System.Int32)">
            <summary>
            Print formated output of this number, determine number of digits
            </summary>
            <param name="digits">Number of digits</param>
            <returns>Formatted output</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Abs">
            <summary>
            Magnitude of this float complex number
            </summary>
            <returns>Magnitude</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Angle">
            <summary>
            Phase angle of this float complex number
            </summary>
            <returns>Phase angle </returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Acos">
            <summary>
            Arcus cosinus of this float complex number
            </summary>
            <returns>Arcus cosinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Asin">
            <summary>
            Arcus sinus of this float complex number
            </summary>
            <returns>Arcus sinus</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Atan(ILNumerics.fcomplex)">
            <summary>
            Arcus tangens of float complex number
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Arcus tangens of input</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Ceiling(ILNumerics.fcomplex)">
            <summary>
            Round towards next greater integer
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Rounded float complex number</returns>
            <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards positive infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Floor(ILNumerics.fcomplex)">
            <summary>
            Round towards next lower integer
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Rounded float complex number</returns>
            <remarks>Real and imaginary parts are independently rounded 
            towards the next integer value towards negative infinity.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Round(ILNumerics.fcomplex)">
            <summary>
            Round mercantilistic
            </summary>
            <param name="input">fcomplex number</param>
            <returns>Rounded number</returns>
            <remarks>Real and imaginaty parts are rounded independently. </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sign(ILNumerics.fcomplex)">
            <summary>
            Signum function
            </summary>
            <param name="input">fcomplex input</param>
            <returns> Signum of input</returns>
            <remarks>
            For numbers a = 0.0 + 0.0i, sign(a)'s real and imag parts are 0.0. 
            For all other numbers sign(a) is the projection onto the unit circle.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Truncate(ILNumerics.fcomplex)">
            <summary>
            Truncate a floating point complex value
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Integer part of input</returns>
            <remarks>Operates on real and imaginary parts seperately.</remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cos(ILNumerics.fcomplex)">
            <summary>
            Cosinus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Cosinus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>0.5 * [exp(i input) + exp(-i input)]</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Cosh(ILNumerics.fcomplex)">
            <summary>
            Cosinus hyperbolicus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Cosinus hyperbolicus of input</returns>
            <remarks><para>The cosinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) + Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sin(ILNumerics.fcomplex)">
            <summary>
            Sinus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Sinus of input</returns>
            <remarks><para>The sinus is computed by the trigonometric euler equation: </para>
            <para>(Exp(i * input) - Exp(-1.0 * i * input)) / (2.0 * i)</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Sinh(ILNumerics.fcomplex)">
            <summary>
            Sinus hyperbolicus
            </summary>
            <param name="input">fcomplex input</param>
            <returns>Sinus hyperbolicus of input</returns>
            <remarks><para>The sinus hyperbolicus is computed by the trigonometric euler equation: </para>
            <para>(Exp(input) - Exp(-1.0 * input)) / 2.0</para></remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.Exp">
            <summary>
            Exponential / power of base e
            </summary>
            <returns>Power of base e</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(System.Double)">
            <summary>
            Power of fcomplex number, real exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Pow(ILNumerics.fcomplex)">
            <summary>
            Power of fcomplex number, complex exponent
            </summary>
            <param name="exponent">Exponent</param>
            <returns>New fcomplex number with result</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Sqrt">
            <summary>
            Square root of fcomplex number
            </summary>
            <returns>Square root</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.Log">
            <summary>
            Logarithm of fcomplex number
            </summary>
            <returns>Natural logarithm</returns>
            <remarks>The logarithm of a complex number A is defined as follows: <br />
            <list type="none"><item>real part: log(abs(A))</item>
            <item>imag part: Atan2(imag(A),real(A))</item></list>
            </remarks>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNaN(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are NAN's
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is not a number</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsPositiveInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are pos. infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is positive infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsNegativeInfinity(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are neg. infinite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real or imag part is negative infinite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.IsFinite(ILNumerics.fcomplex)">
            <summary>
            Test if any of real or imaginary parts are finite
            </summary>
            <param name="input">fcomplex input</param>
            <returns>true if any of real and imag part is finite</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Double)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">double</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Single)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">float</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Byte)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">byte</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Char)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">char</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int16)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int16</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int32)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int32</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.Int64)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">Int64</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt16)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt16</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt32)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt32</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Implicit(System.UInt64)~ILNumerics.fcomplex">
            <summary>
            Implicit cast real number into complex number
            </summary>
            <param name="a">UInt64</param>
            <returns>fcomplex number with real part equals a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Double">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Single">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Byte">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Char">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int16">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int32">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">complex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.Int64">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt16">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt32">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.op_Explicit(ILNumerics.fcomplex)~System.UInt64">
            <summary>
            Explicit cast complex number into real number
            </summary>
            <param name="a">fcomplex number</param>
            <returns>Real number with real part of a</returns>
        </member>
        <member name="M:ILNumerics.fcomplex.iszero">
            <summary>
            Test if real and imag part are zero
            </summary>
            <returns>true if real and imag parts are zero, false else</returns>
        </member>
        <member name="P:ILNumerics.fcomplex.conj">
            <summary>
            Complex conjugate 
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.INF">
            <summary>
            Positive infinity for real and imag part of complex value
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.Zero">
            <summary>
            New fcomplex, real and imaginary parts are zero
            </summary>
        </member>
        <member name="P:ILNumerics.fcomplex.NaN">
            <summary>
            fcomplex quantity, marked as being "not a number"
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILArrayDebuggerProxy`1">
            <summary>
            This class is for internal use only. Do not instantiate from this class!
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:ILNumerics.Exceptions.ILException">
            <summary>
            Generic exception, base class for all exceptions thrown by ILNumerics
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMathException">
            <summary>
            Base class for mathematical exceptions. Needed e.g. in interpreter for proper error
            messages
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMathException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILDimensionMismatchException">
            <summary>
            One of the most common exceptions: The matrix sizes do not match
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILDimensionMismatchException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentException">
            <summary>
            Something was wrong with the arguments supplied
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentNumberException">
            <summary>
            A function was called with the wrong number of arguments
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentNumberException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentSizeException">
            <summary>
            A function argument has the wrong size
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentSizeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILArgumentTypeException">
            <summary>
            A function was called with a wrong argument type
            </summary>
            <remarks>This exception might be thrown if the size or inner 
            type of a argument is invalid. (e.g. matrix expected, but 3D array found)
            </remarks>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILArgumentTypeException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILMemoryException">
            <summary>
            A request could not be completed due to not enough memory available
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILMemoryException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILCastException">
            <summary>
            Thrown on illegal casting attempts
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String)">
            <summary>
            Costructor
            </summary>
            <param name="message">Addditional message to be included into the exception</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILCastException.#ctor(System.String,System.Exception)">
            <summary>
            Costructor
            </summary>
            <param name="message">Additional message to be included into the exception</param>
            <param name="innerException">On cascaded exception handling, the exception catched before</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILOutputException">
            <summary>
            ILOutputException, thrown if an I/O attempt fails
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILOutputException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidOperationException">
            <summary>
            Exception thrown if an operation could not completed
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidOperationException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor
            </summary>
            <param name="message">Additional message to be included</param>
            <param name="innerException">Inner Exception</param>
        </member>
        <member name="T:ILNumerics.Exceptions.ILInvalidLicenseException">
            <summary>
            No valid license could be found
            </summary>
        </member>
        <member name="M:ILNumerics.Exceptions.ILInvalidLicenseException.#ctor(System.String,System.Exception)">
            <summary>
            Create a new ILInvalidLicenseException 
            </summary>
            <param name="message">Additional message to be included</param>
        </member>
        <member name="T:ILNumerics.ILMatFile">
            <summary>
            Matlab .mat file wrapper class
            </summary>
            <remarks>This class reads and writes Matlab .mat files version 6! ! 
            All numeric array types are supported. The reading and writing of 
            Matlab cell arrays is not supported yet.</remarks>
        </member>
        <member name="F:ILNumerics.ILMatFile.ReservedKeywords">
            <summary>
            List of keywords which Matlab disallows for variable names
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.sizeOf(ILNumerics.ILMatFile.MatFileType)">
            <summary>
            size of single elements stored in Matlab's *.mat files
            </summary>
            <param name="type">one of Matlab's inner element types</param>
            <returns>size in bytes </returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.read_miMATRIX(System.IO.BinaryReader)">
            <summary>
            read ONE array (arbitrary dimensions/type) from MAT file 
            </summary>
            <param name="br">binary reader initialized and pointing to the beginning of the subarray element.</param>
            <returns>ILBaseArray of size and type originally stored into the mat file.</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.readElementGeneric(System.IO.BinaryReader,ILNumerics.ILMatFile.MatFileType,System.Array@,System.Int32@,System.Int32)">
            <summary>
            read array of supported matlab data types 
            </summary>
            <param name="br">binary reader, opened and correctly positioned</param>
            <param name="storageType">actual storage type</param>
            <param name="realData">output: on return, the array read</param>
            <param name="len">input: number of bytes to read, on return: number of elements in array</param>
            <param name="paddBytes">padding border, the stream will be read to the next border of length 'paddBytes'.</param>
        </member>
        <member name="M:ILNumerics.ILMatFile.createNameSubelement(System.String,System.Int32@,System.Byte[]@)">
            <summary>
            create name subelement for Matfile storage - padded to 8 byte border
            </summary>
            <param name="arrName">name property</param>
            <param name="type">will be 'miINT8' on return</param>
            <param name="data">return data array </param>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementClass(ILNumerics.ILBaseArray)">
            <summary>
            get mat file array class type corresponding to this arra element type
            </summary>
            <param name="arr">arra with generic system type or complex/fcomplex</param>
            <returns>mat file array class type code (int value)</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.getElementLength(ILNumerics.ILBaseArray)">
            <summary>
            get storage length of inner array elements 
            </summary>
            <param name="arr">base array in question</param>
            <returns>storage length in bytes</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.typeToString(ILNumerics.ILMatFile.MatFileType)">
            <summary>
            Convert MatFileType enumeration member to string representation
            </summary>
            <param name="type">MatFileType enumeration member</param>
            <returns>String representing the Matlab's inner element type</returns>
            <remarks>This function is obsolete. You may directly use the enumeration's functionality instead.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.AddArray(ILNumerics.ILBaseArray,System.String)">
            <summary>
            Add array to collection of arrays in this ILMatFile container
            </summary>
            <param name="A">Array to be added to ILMatFile</param>
            <returns>String used to identify the array in the collection of arrays</returns>
            <remarks><para>The internal <c>Name</c> property of array given will be used as identification key.</para>
            <para>Note, the test if elements of A are supported by MatFile specification is done if the MatFile is to be written to stream ('write').</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILInvalidOperationException">If the internal name of A does not fullfill the restrictions given by Matlab.</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.IO.Stream)">
            <summary>
            Write this mat file into a binary stream
            </summary>
            <param name="stream">Stream to receive data. This will commonly be a FileStream object.</param>
            <remarks>
            <para>This method writes the full content of the current mat file into a binary stream. The file 
            afterwards is suitable to be read again by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including Matlab, e.g.</para>
            <example><code>
            MatFile m = new MatFile(myarrays); 
            using (Stream s = new FileStream("test.mat",FileMode.Create)) {
                m.Write(s);
            }
            </code></example></remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.Write(System.String)">
            <summary>
            Write all arrays to *.mat file
            </summary>
            <param name="filename">Filename of the file to write the mat file to</param>
            <remarks>
            <para>The method writes the full content of the matfile to the file specified. If the filename 
            points to a file which already exists, that file will be overwritten. Otherwise a new file will
            be created. </para>
            <para>The file will be suitable for reading by ILNumerics.MatFile classes or by compatible *.mat file 
            readers - including e.g. matlab</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.GetArray``1(System.String)">
            <summary>
            Retrieve array by name
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="name">Name of the array to retrieve</param>
            <returns>A clone of the array found or null, if no array with the given name exists</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.GetArray``1(ILNumerics.ILBaseArray)">
            <summary>
            Retrieve array by index
            </summary>
            <typeparam name="T">Expected type of the array</typeparam>
            <param name="index">Index of the array</param>
            <returns>A clone of the array found or null, if no array at the given index exists</returns>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(System.String)">
            <summary>
            Create MatFile object from existing mat file 
            </summary>
            <param name="file2open">Path to Matlab mat file to open</param>
            <remarks>Curently mat files up to Matlab version 6.5 are supported. Compressed mat file content is not supported yet.</remarks>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create MatFile object from ILBaseArray
            </summary>
            <param name="input">ILBaseArray of arbitrary size/type</param>
            <exception cref="T:System.ArgumentNullException">If input array was null or one of the names in the input arrays does not fullfill the restrictions made from Matlab</exception>
        </member>
        <member name="M:ILNumerics.ILMatFile.#ctor">
            <summary>
            Create an empty MatFile object
            </summary>
        </member>
        <member name="M:ILNumerics.ILMatFile.Dispose">
            <summary>
            Dispose all arrays of the matfile object
            </summary>
            <remarks>Calling dispose should be the last action for a matfile object. It is recommended to 
            utilize the matfile class in using blocks (C#) only.</remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Filelocation">
            <summary>
            Path to mat file, if this object was created from an existing mat file.
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Keys">
            <summary>
            List all key names currently stored with arrays 
            </summary>
        </member>
        <member name="P:ILNumerics.ILMatFile.Arrays">
            <summary>
            Retrieve a cell with all arrays stored in the mat file
            </summary>
            <remarks>The cell returned will be clone of the arrays stored in the mat file. Altering any cell 
            elements will leave the arrays in the matfile (class/memory object) untouched.
            <para>The cell returned will be of size [n,2], where n is the number of arrays contained. The 
            first row saved the arrays, the second row containes scalar string arrays with the name of 
            the array in the corresponding row.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.ILMatFile.Item(System.String)">
            <summary>
            Add/set arrays to the MatFile array container
            </summary>
            <param name="name">The name of the array for display in Matlab</param>
            <remarks><para>For get access the name must exist as key in the container. Use the MatFile.Keys property to get a list of all names if needed</para>
            <para>For set access, the name given must not be null or empty. It cannot be one of the <see cref="F:ILNumerics.ILMatFile.ReservedKeywords">ReservedKeywords</see>.
            If the name allready exist in the collection as name, the array currently assigned to it will be replaced. If the value is null, the current array will be removed from the list. If the name does 
            not already exist, the new array will be added and assigned to this name.</para>
            <para>Restrictions on array names: Matlab allowes variables to have names of maximum length 63. Therefore, if the 
            name given was larger than 63, it will be abbreviated. Names must start with a letter and contain only digits, (ASCII) letters or underscores '_'.</para></remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the name does not fullfill the restrictions given from Matlab</exception>
        </member>
        <member name="P:ILNumerics.ILMatFile.Count">
            <summary>
            Number of arrays in the mat file container
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile.MatFileType">
            <summary>
            Inner types for MATLAB data elements
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUNKNOWN">
            <summary>
            unknown 
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT8">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT8">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT16">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT16">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT32">
            <summary>
            int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT32">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miSINGLE">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miDOUBLE">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miINT64">
            <summary>
            Int64
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUINT64">
            <summary>
            UInt64
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miMATRIX">
            <summary>
            matrix type (general)
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miCOMPRESSED">
            <summary>
            compressed
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF8">
            <summary>
            utf8 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF16">
            <summary>
            utf16 encoded
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileType.miUTF32">
            <summary>
            utf32 encoded
            </summary>
        </member>
        <member name="T:ILNumerics.ILMatFile.MatFileArrayClass">
            <summary>
            Types for matrix chunks
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCELL_CLASS">
            <summary>
            cell
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSTRUCT_CLASS">
            <summary>
            struct
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxOBJECT_CLASS">
            <summary>
            object
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxCHAR_CLASS">
            <summary>
            char
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSPARSE_CLASS">
            <summary>
            sparse
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxDOUBLE_CLASS">
            <summary>
            double
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxSINGLE_CLASS">
            <summary>
            float
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT8_CLASS">
            <summary>
            Int8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT8_CLASS">
            <summary>
            UInt8
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT16_CLASS">
            <summary>
            Int16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT16_CLASS">
            <summary>
            UInt16
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT32_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT32_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxINT64_CLASS">
            <summary>
            Int32
            </summary>
        </member>
        <member name="F:ILNumerics.ILMatFile.MatFileArrayClass.mxUINT64_CLASS">
            <summary>
            UInt32
            </summary>
        </member>
        <member name="T:ILNumerics.ILMemoryPool">
            <summary>
            The ILNumerics Memory Pool is the heart of the ILNumerics memory management.
            </summary>
            <remarks>The pool reduces the pressure on the systems memory done by larger objects.
            <para>Arrays created in ILNumerics will try to reclaim its memory from this pool. If attempt fails, the memory is gathered from the managed heap normally.</para>
            <para>Disposed array objects register their underlying storage in the pool for later reusing. The process is triggered by a deterministic disposal 
            pattern in conjunction with <a href="http://ilnumerics.net/$Arrays.html">ILNumerics array types</a> and <a href="http://ilnumerics.net/$FunctionRules.html">ILNumerics Function Rules</a>.</para></remarks>
            <see cref="!:"/>
        </member>
        <member name="F:ILNumerics.ILMemoryPool.Pool">
            <summary>
            The only global ILMemoryPool instance 
            </summary>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64,System.Boolean,System.Boolean@)">
            <summary>
            Get new array of type T from memory pool.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="length">Size of T[]</param>
            <param name="clear">If true, set the elements in T[] to default(T)</param>
            <param name="cleared">Always true if <paramref name="clear"/> was set. Otherwise this will be true if the array was newly created instead of being recycled from the pool. False otherwise.</param>
            <remarks><para>If the pool contains an unused matching element of sufficient size this element will be returned. If <paramref name="clear"/> was false,
            the result might still contain the old data.</para>
            <para>If the pool does not contain a matching element a new one is created.</para>
            <para><b>Note:</b> The returned array may be larger than requested if it was recycled from the pool.</para></remarks>
            <returns>An array of type T of at least length <paramref name="length"/></returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.New``1(System.Int64)">
            <summary>
            Get a new array of type T from the memory pool
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="length">Required minimum length</param>
            <remarks>The returned array is only guaranteed to have at least length <paramref name="length"/>. If it is recycled from the pool it may be longer.
            There is no guarantee on the values contained in the returned array. To force these to have a default value use <see cref="!:ILMemoryPool.New&lt;T&gt;(long length, bool clear, out bool cleared)"/></remarks>
            <returns>An array of type T of at least length <paramref name="length"/>.</returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Free``1(``0[])">
            <summary>
            Return a array of type T that is not needed anymore to the pool.
            </summary>
            <typeparam name="T">Element type</typeparam>
            <param name="array">The array to add to the pool</param>
            <remarks>You may also "free" objects not retrieved from the pool, in which case they are registered in the pool.</remarks>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.MaxBytes``1">
            <summary>
            Get maximal potential size of the memory pool for objects of type T
            </summary>
            <typeparam name="T">Element type</typeparam>
            <returns>Maximal number of bytes in pool</returns>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Reset``1(System.Int64,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinPoolArrayLen">Minimum length for array object to be stored inside the pool</param>
            <param name="maxSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.ILMemoryPool.Info(System.Boolean)">
            <summary>
            Give information about pool state
            </summary>
            <param name="shortVersion">true (default): abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info</param>
            <returns>Infos about current pool state</returns>
        </member>
        <member name="T:ILNumerics.Misc.ILMemoryPoolInternal`1">
            <summary>
            Memory pool serving as temporary storage for System.Array objects
            </summary>
            <remarks>The pool reduces the pressure on the systems memory caused by larger objects.
            <para>Arrays created in ILNumerics will first try to reclaim their memory from this pool. If that 
            fails, the memory is allocated from the managed heap only.</para>
            <para>Disposed array objects register their underlying System.Array in the pool for 
            later reusing. The process is triggered by the ILNumerics memory management automatically.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Reset(System.Int64,System.Int32)">
            <summary>
            Reset &amp; reconfigure the pool 
            </summary>
            <param name="MinArrayLength">Minimum length for array object to be stored inside the pool</param>
            <param name="PoolSizeMB">Overall size the memory pool consumes at most</param>
            <remarks>Reset will dispose all objects currently hold in the pool!</remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.DisposeContent">
            <summary>
            Dispose all objects currently hold in the pool 
            </summary>
            <remarks>The pool get cleared and continues working with the same parameters after the call has finished. </remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Free(`0[])">
            <summary>
            Return or register an array object of value type in the pool that is not used anymore, i.e. free it
            </summary>
            <typeparam name="T">arbitrary element type</typeparam>
            <param name="arr">array</param>
            <remarks><para>In order to be stored in the pool, the array must meet the minimum array length and must fit into the global pool size.
            Null objects or empty arrays or array not suitable for the pool will be silently ignored.</para>
            <para>If the new array is too large to fit into the remaining pool space, the oldest objects in the pool will be released until the object can get registered.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64)">
            <summary>
            Request a System.Array instance, may not be cleared
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length"><b>minimum</b> length of array</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. 
            Otherwise a new array is created.</para>
            <para>There is no way of determining, if the array was reclaimed from pool or newly created! 
            If you must be sure, the element values are set to default(T), call the overloaded version 
            <see cref="!:ILNumerics.Misc.ILMemoryPool.New&lt;T&gt;(int, bool, out bool)"/> instead!</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage collection
            is triggered and the array is again requested from the pool. If this again fails, another attempt 
            to create the array is done. Exceptions may thrown from this last attempt are not catched and 
            therefore must be handled by the calling function.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.New(System.Int64,System.Boolean,System.Boolean@)">
            <summary>
            Request a System.Array instance and optionally clear the array
            </summary>
            <typeparam name="T">value type</typeparam>
            <param name="length">length of array</param>
            <param name="clear">if true, the elements of the array returned are set to default(T).</param>
            <param name="iscleared">out paramater determining if the array returned has been cleared</param>
            <returns>System.Array - either from the pool or a newly created array</returns>
            <remarks><para>If a suitable System.Array was found in the pool, this object is returned. Otherwise a new array is created.</para>
            <para>If the <paramref name="clear">clear </paramref> parameter was set to false, the
            <paramref name="iscleared">iscleared</paramref> parameter can be used to determine, if the object
            was returnd from the pool and may need extra clearing.</para>
            <para>If a new array could not get created due to an OutOfMemoryException, a garbage 
            collection is triggered and the array is again requested from the pool. If this again failes, 
            another attempt to create the array is done. Exceptions eventually thrown from this last 
            attempt are not catched and given back to the callee.</para></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean,System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <param name="reset">true: reset internal counter for reclaimed objects/ - bytes</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info">
            <summary>
            Give extended infos about pool state
            </summary>
            <returns>Full info about current and reclaimed pool objects</returns>
            <remarks>For short version infos use the overloaded version <see cref="!:ILNumerics.Misc.ILMemoryPool.Info(bool)"/></remarks>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Info(System.Boolean)">
            <summary>
            Give infos about pool state, optionally reset counters
            </summary>
            <param name="shortVersion">true: abbreviate infos to: current MB in Pool, reclaimed MB for livetime, reclaimed objects for livetime. False: give full info (see below)</param>
            <returns>infos about current pool state</returns>
        </member>
        <member name="M:ILNumerics.Misc.ILMemoryPoolInternal`1.Shrink(System.Int64)">
            <summary>
            shrink the pool's content to SHRINK_PERCENT of the maximum pool size or at the size, suitable to store requestLen
            </summary>
            <param name="requestLen">minimum length to make available (bytes)</param>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxRequestedLengthIncrease">
            <summary>
            factor used, to allow returned arrays to exceed the requested array length
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MinArrayLength">
            <summary>
            minimum length of array objects for recognition in the pool (default: 80k)
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.MaxBytes">
            <summary>
            maximum size of the pool configured in bytes
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.SuccessRate">
            <summary>
            percentage of allocation requests which could be successfully be completed
            </summary>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedBytesCount">
            <summary>
            Number of reclaimed bytes since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)"/></remarks>
        </member>
        <member name="P:ILNumerics.Misc.ILMemoryPoolInternal`1.ReclaimedObjectsCount">
            <summary>
            Number of reclaimed objects since the pool exists
            </summary>
            <remarks>The counter will be reset by calls to <see cref="!:ILNumerics.Misc.ILMemoryPool.Reset(int, int)"/></remarks>
        </member>
        <member name="T:ILNumerics.Misc.ILThreadPool">
            <summary>
            simple thread pool implementation - NOT THREAD SAFE !! 
            </summary>
        </member>
        <member name="T:ILNumerics.Misc.ILPerformer">
            <summary>
            Measures time spans.
            </summary>
        </member>
        <member name="T:ILNumerics.ILScope">
            <summary>
            An artificial scope class, used by the ILNumerics memory management
            </summary>
        </member>
        <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray[])">
             <summary>
             Begins an artificial scope block within a local function block
             </summary>
             <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
             <returns>A new scope</returns>
             <remarks><para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para></remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.ILScope.Enter(ILNumerics.ILBaseArray)">
             <summary>
             Begins an artificial scope block within a local function block
             </summary>
             <param name="inputArrays">Any <b>input</b> arry, given as parameter for the current function</param>
             <returns>A new scope</returns>
             <remarks><para>The <c>ILScope</c> class plays an important role for the ILNumerics memory management. When writing functions in ILNumerics, 
             <c>ILScope</c> is used, to define blocks of artificial scopes for local function blocks. ILNumerics ensures, no memory is left as garbage, once 
             such a scope block was left. Furthermore, it garantees, input arrays are kept alive during the execution of the block. By following these 
             <a href="http://ilnumerics.net/$GeneralRules.html" target="ILMain">simple rules</a>, ILNumerics is able to optimize the execution of the algorithm regarding 
             execution speed and memory footprint.</para></remarks>
             <example><para>The examples demonstrates a custom function in ILNumerics. It demonstrates the use of distinct array types in the function declaration and the use of 
             artificial scopes.</para>
             <code><![CDATA[ILRetArray<double> FreqPeaks(ILInArray<double> inData, ILOutArray<double> freq = null, double sampFreq = 44.1) { 
            
                using (ILScope.Enter(inData)) {    
                         
                    ILArray<double> Data = check(inData); 
                    ILArray<double> retLength = min(ceil(Data.Length / 2.0 + 1), 5.0);   
                    ILArray<double> Window = stdWindowFunc(Data.Length);  
                    ILArray<double> magnitudes = abs(fft(Data * Window));  
                    magnitudes = magnitudes[r(0,end / 2 + 1)];  
             
                    ILArray<double> indices = empty();  
                    ILArray<double> sorted = sort(magnitudes, indices, descending:true);  
                    if (!isnull(freq)) 
                        freq.a = (sampFreq / 2.0 / magnitudes.Length * indices)[r(0,retLength-1)];  
                    return magnitudes[r(0,retLength-1)];  
                } 
            }]]></code>
             </example>
        </member>
        <member name="M:ILNumerics.ILScope.Dispose">
            <summary>
            Dispose all arrays in this scope
            </summary>
        </member>
        <member name="P:ILNumerics.ILScope.Context">
            <summary>
            The threading context - individual for each thread
            </summary>
        </member>
        <member name="M:ILNumerics.ILScopeList`1.Peek(System.Int32)">
            <summary>
            peek element at distance 'index' from END!!
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="T:ILNumerics.Settings">
            <summary>
            The class provides static setting properties to control the behaviour of ILNumerics, see <a href="http://ilnumerics.net/$Configuration.html">Configuration</a> in the online documentation
            </summary>
        </member>
        <member name="M:ILNumerics.Settings.LoadDefaults">
            <summary>
            (Re)load settings from the application configuration file
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.AllowInArrayAssignments">
            <summary>
            Performance switch, dis-/allow direct assignments to input parameters - brings more efficient 
            memory management, default: true (safer, less efficient)
            </summary>
            <remarks>
            <para>If this switch is set to 'false', you promise not to assign any values to input parameters 
            of type <c>ILInArray</c>, <c>ILInCell</c> or <c>ILInLogical</c>. This allows ILNumerics for more efficent 
            memory management, decreases the overall memory footprint of the application and enables certain 
            array operations to be automatically computed in-place. Depending on the specific algorithm
            the performance profit may range from 1% up to even about 30%.</para>
            This switch should be set for the whole application globally. It is not recommended to change the state of 
            this switch once the application runs.
            <para>Since this switch targets the full application, all functions and modules involved must also follow 
            that contract! For all builtin functions of ILNumerics, compliance with this rule is garanteed. This means, if you are 
            not using any 3rd party algorithms and are able to make sure your own functions follow that scheme as well, it is safe 
            to set this switch to <c>false</c> and profit from faster execution times.</para>
            <para>See the <a href="http://ilnumerics.net/$PerfMemoryOpt.html">Optimizing Performance</a> article in the online documentation.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.CreateRowVectorsByDefault">
            <summary>
            Control layout of vectors when not specified explicitly.
            <list type="bullet">
            <item>
            <term>true</term>
            <description>When a vector is created without exlicitely specifying its shape, create a row vector</description>
            </item>
            <item>
            <term>false (default)</term>
            <description>When a vector is created without exlicitely specifying its shape, create a column vector</description>
            </item></list>
            </summary>
            <remarks>This setting affects the way ILNumerics handles the default shape for vectors created. One example is <see cref="M:ILNumerics.ILMath.array``1(``0[])"/>, 
            where only the number of elements is given - but no size is specified. By default, ILNumerics will interpret the elements as targeting the <b>first</b> 
            dimension, ie. dimension #0. This will create a column vector. Setting this switch to 'true' will make ILNumerics to create a row vector in 
            such situations instead.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileMaxLength">
            <summary>
            Upper limit of the range of array length to gather profiler information for
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileMinLength">
            <summary>
            Lower limit of the range of array length to gather profiler information for
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MemoryPoolProfileFileName">
            <summary>
            If set to any non empty value, this setting triggers the memory pool profiler
            </summary>
            <remarks>Profiling the memory pool gives insights into those functions, which potentially 
            cause memory leaks in your application. It writes extensive stack trace information into the 
            logfile determined by this setting. It will contain the stack trace of any function, requesting 
            memory from the pool, which is never given back to the pool. Use this information in order to find and 
            correct those places - and increase stability and performance of your application. However, 
            make sure, this switch is cleared (or renamed) for production systems, since running the profiler 
            will diminish performance significantly.</remarks>
        </member>
        <member name="P:ILNumerics.Settings.MeasurePerformanceAtRuntime">
            <summary>
            Gives the current setting for the reporting of runtime performance measures to the windows performance monitor (perfmon) (readonly)
            </summary>
            <remarks>Activating this switch requires administrative rights on each system the application is run - at least for the first time! This is 
            necessary in order to register the performance counters to the system. Afterwards, the application does not require administrative rights anymore.
            <para>Measuring the performance at runtime does not produce a substantial impact on the performance of your algorithm. However, due to the need for elevated rights 
            the feature is disabled by default. In order to enable it, a configuration variable named "ILNMeasurePerformanceAtRuntime" needs to be set in your 
            application configuration file.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.MinimumQuicksortLength">
            <summary>
            Determine the minimum length for arrays to be sorted via Quicksort algorithm, smaller arrays are sorted via insertion sort
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreads">
            <summary>
            Maximum number of threads for parallel execution of internal functions in ILNumerics
            </summary>
            <remarks>
            <para>In order to maximize execution speed of numerical algorithms, the value of <c>MaxNumberThreads</c> should be equal to the number 
            of <b>real</b> processor cores on the system. For processors utilizing <a href="http://en.wikipedia.org/wiki/Hyper-threading">Hyper-threading</a> the number on virtual cores 
            may be higher. However, since those virtual cores share certain ressources for execution, parallel utiliziation can not efficently be done with them. In this cases, the number of 'cores' 
            appearing e.g. in the windows task manager is misleading and the true number of independent cores should be used for <c>MaxNumberThreads</c> instead. Consult your proccessor vendor in order to find out, how many 
            independant cores your system utilizes.</para>
            <para>Since the number of independent cores is not reliably determined by .NET, ILNumerics defaults to 2 cores on all multicore machines. Therefore, this setting should be <a href="http://ilnumerics.net/$Configuration.html">set manually</a> for 
            better processor utilization on multicore machines.</para>
            <para>If your algorithm uses custom parallel execution models, it may 
            be necessary to set this value to '1'. ILNumerics will run single threaded than - leaving you the option to configure 
            the execution on parallel threads on your own.</para>
            <para>The setting of this value also effects the corresponding value of any unmanaged optimized support library (e.g. MKL) internally used by ILNumerics.</para>
            </remarks>
        </member>
        <member name="P:ILNumerics.Settings.MaxNumberThreadsConfigured">
            <summary>
            Determine, if the current setting of <see cref="P:ILNumerics.Settings.MaxNumberThreads"/> is the result of a custom configuration
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement3Count">
            <summary>
            Threshold used to determine, if computations of O(n^3) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement2Count">
            <summary>
            Threshold used to determine, if computations of O(n^2) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MinParallelElement1Count">
            <summary>
            Threshold used to determine, if computations of O(n) built-in-functions are done in parallel on multicore machines
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.MaxSafeQuicksortRecursionDepth">
            <summary>
            Maximal recursion depth the quicksort can go. default: 100 (for array length up to 2^100)
            </summary>
        </member>
        <member name="P:ILNumerics.Settings.LogicalArrayToBoolConversion">
            <summary>
            Controls implicit conversions from logical arrays to System.Boolean
            </summary>
            <remarks>This setting specifies, how logical arrays are converted to System.Boolean. Those 
            conversions are important, in order to simplify expressions like 
            <code>if (A &gt; B) { ... }</code> on arrays A and B. 
            <para>Here, the comparison <code>A &gt; B</code> creates a logical array of the same size than A and B. The logical array contains
            the result of the elementwise 'greater than' comparison. This setting here controls, how that logical is converted
            to a System.Boolean, in order to evaluate the 'if' condition. </para>
            <para>The default is <c>LogicalConversionMode.NonScalarThrowsException</c>, which would cause an exception to be thrown in 
            the example above. Only scalar logical arrays can be used in such implicit conversions than.</para>
            <para>In order to further simplify the syntax, the <c>LogicalConversionMode.ImplicitAllAll</c> setting can be used. The above expression
            would evaluate to true, if <b>all</b> elements of B are greater than corresponding elements of A. This settings therefore 
            eases the syntax for most situations. However, since most comparison operators comply to the underlying <b>all</b> rule, 
            the '!=' (not equal to) operator does not - at least to the extend of common intuition. In an expression: 
            <code>if (A != B) { ... }</code> one would intuitively expect to execute the code block, if <b>at least one element</b> of A does not equal the corresponding element
            of B. However, due to the <b>all</b> rule, this is not the case! In fact, the code would be executed only, if <b>all</b> elements would 
            evaluate to true. I.e. if no single pair of corresponding elements in A and B are equal. In order to 
            get the intuitively expected behavior, one would override this by:
            <code>if (ILMath.any(A != B)) { ... } </code> 
            Since it may cause hard to find bugs, this setting should be used with care.</para></remarks>
        </member>
        <member name="P:ILNumerics.Settings.UseThreadAffinity">
            <summary>
            Determine, if main and worker threads should bind to constant cpus or not. The default is not to bind.
            </summary>
            <remarks>It usually is more efficient, to leave control of cpu binding to the runtime. However, if in certain situations, more control is required, this flag can 
            be used to make ILNumerics worker threads be affine to corresponding (native) threads.</remarks>
        </member>
        <member name="T:ILNumerics.ILSize">
            <summary>
            ILSize - dimensions for array objects (immutable)
            </summary>
            <remarks>The class internally manages the dimensions of ILNumerics arrays. 
            The class is immutable. Therefore, once created, it informs the user 
            about all dimension related properties, but cannot get altered.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(System.Int32[])">
            <summary>
            Create new ILSize 
            </summary>
            <param name="dims">variable length dimensions specifier</param>
            <remarks>Trailing singleton dimensions of dims will be kept.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(ILNumerics.ILBaseArray[])">
            <summary>
            Create new size descriptor from given data
            </summary>
            <param name="size">Size description</param>
        </member>
        <member name="M:ILNumerics.ILSize.#ctor(System.Boolean,System.Int32[])">
            <summary>
            Create new size descriptor
            </summary>
            <param name="trimSingletons">true: trailing singleton 
            dimensions will be trimmed, false: keep trailing singleton dimensions</param>
            <param name="size">Size description</param>
        </member>
        <member name="M:ILNumerics.ILSize.WorkingDimension">
            <summary>
            Find dimension to work on, if non was specified by user
            </summary>
            <returns>Index of first non singleton dimension (i.e. dimension that is not 1) or 0, if this array is a scalar.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.SequentialIndexDistance(System.Int32)">
            <summary>
            Storage distance of elements in dimension dim
            </summary>
            <param name="dim">0-based index of dimension to query the element distance for</param>
            <returns>Storage distance of elements between adjacent elements of dimension dim
            </returns>
            <remarks>If dimension index dim is larger than the number of 
            dimensions of this array, the number of elements will 
            be returned (trailing singleton dimensions).</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetSequentialIndexDistances(System.Int32)">
            <summary>
            Distances between adjacent elements for all dimensions
            </summary>
            <param name="minLength">minimum length of array to be 
            returned. If this is larger than the number of dimensions 
            in this size descriptor, the array will have minLength elements, 
            with elements outside this dimensions repeating the value 
            of the last dimension. The length of the array returned will 
            be equal or greater than max(minLength,NumberOfDimensions).</param>
            <remarks>This is provided for performance reasons and should be 
            used internally only. It enables developer of index access routines 
            to cache the elements distances directly inside their functions 
            without having to query the info on every index access.
            <para>Keep in mind, only the distances for the number of my 
            dimensions are returned. Higher dimensions must be set to 
            NumberOfElements if needed. This is different than querying 
            the distances by SequentialIndexDistance(int), which will assume 
            and return trailing dimensions to be 1.</para>
            <para>IMPORTANT: ALTERING THE ARRAY RETURNED IS NOT ALLOWED AND 
            MAY LEAD TO SERIOUS INSTABILITY AND UNWANTED SIDE EFFECTS!</para></remarks>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArray">
            <summary>
            Transfer my dimensions to integer array 
            </summary>
            <returns>Integer array containing a copy of all dimensions length</returns>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArray(System.Int32)">
            <summary>
            Transfer my dimensions to integer array 
            </summary>
            <param name="length">Minimum length of output array. If length 
            is larger than my dimensions, trailing ones will be added.</param>
            <returns>Integer array containing a copy of dimensions length. 
            Trailing elements outside my dims will be one.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.ToIntArrayEx(System.Int32)">
            <summary>
            return dimension vector, fixed length, for subarray operations
            </summary>
            <param name="length"></param>
            <returns>dimension vector, corresponds to reshaped or unlimited dimensions</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])">
            <summary>
            Transform indices from int[] System.Array into sequential index of underlying 1dim array 
            </summary>
            <param name="idx">int array of nrDims length, min length: 1, all indices must fit into my dimensions</param>
            <returns>Index pointing to element defined by 'idx'</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            Transform dimension position into sequential index, gather expand 
            information
            </summary>
            <param name="idx">int array of arbitrary length</param>
            <param name="MustExpand">[output] true, if the indices 
            given address an element outside of 
            this dimensions size. In this case, the output parameter 
            'Dimensions' carry the sizes 
            of new dimensions needed. False otherwise</param>
            <param name="dimensions">sizes of dimension if expansion is needed. 
            Must be predefined to length of max(idx.Length,m_nrDims) at least</param>
            <returns>Index number pointing to the value's position in 
            sequential storage.</returns>
            <remarks>no checks are made for idx to fit inside dimensions! 
            This functions is used for left side assignments. Therefore it 
            computes the destination index also if it lays outside 
            the array bounds.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.IndexFromArray(System.Int32[],System.Int32)">
            <summary>
            Unshift dimensions of indices from int[] Array 
            and translate to index for sequential storage access 
            in my dimensions </summary>
            <param name="idx">int array of the same length as 
            the number of dimensions of this storage. Indices must 
            lay within my dimensions.</param>
            <param name="unshift">Number of dimensions to unshift 
            idx before computing index</param>
            <returns>Index number pointing to the value's position 
            in sequential storage.</returns>
            <remarks>If idx contains elements (indices) larger than 
            my dimension bounds, an exception will be thrown. If unshift 
            is 0, the length of idx may be smaller than the length of 
            my dimensions. However, with unshift &gt; 0 the result 
            is undefined.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetShifted(System.Int32)">
            <summary>
            Return shifted version
            </summary>
            <param name="shift">Number of dimensions to shift. The value
            will be considered modules the number of dimensions of 
            this size descriptor.</param>
            <returns>Shifted version of this size descriptor object.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.GetReshapedSize(System.Int32)">
            <summary>
            Create dimension sizes for reshaping index adressing
            </summary>
            <param name="dimCount">Needed number of destination array dimensions</param>
            <returns>Dimension sizes, cutted trailing dimensions are multiplied to last dimension returned.</returns>
        </member>
        <member name="M:ILNumerics.ILSize.IsSameSize(ILNumerics.ILSize)">
            <summary>
            Compares the size of this dimension to another dimension object. 
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the sizes are the same, else returns false. 
            The comparison is made by recognizing singleton dimensions. Therefore 
            only non singleton dimensions are compared in the order of their 
            appearance. </returns>
            <remarks>The function returns true, if the squeezed dimensions of 
            both size descriptors match.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.IsSameShape(ILNumerics.ILSize)">
            <summary>
            Compares the shape of this dimension to another dimension object 
            </summary>
            <param name="dim2">size descriptor to compare this to.</param>
            <returns>Returns true if the shapes are the same, else returns false. </returns>
            <remarks>This function is more strict than IsSameSize. In order 
            for two dimensions to have the same shape, ALL dimensions must match - 
            even singleton dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.GetSqueezed">
            <summary>
            [deprecated] Create copy of this size descriptor having all singleton 
            dimensions removed.
            </summary>
            <returns>a squeezed copy</returns>
            <remarks>This function is deprecated. Use the ILSize.Squeeze()
            memeber instead. </remarks>
        </member>
        <member name="M:ILNumerics.ILSize.Squeeze">
            <summary>
            Create and return copy without singleton dimensions
            </summary>
            <returns>Copy of this size descriptor having all singleton dimensions removed.</returns>
            <remarks> This function does not alter this object (since ILSize is 
            immutable).
            <para>All arrays in ILNumerics have at least 2 dimensions. 
            Therefore all but the first two singleton dimensions can be removed.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.ILSize.Trim">
            <summary>
            Return size descriptor, having trailing singleton dimensions removed
            </summary>
            <returns>Copy without trailing singleton dimensions</returns>
            <remarks>This object will NOT be altered. As usual for all ILArrays, 
            the result wil have at least 2 dimensions.</remarks>
        </member>
        <member name="M:ILNumerics.ILSize.ToString">
            <summary>
            Pretty print dimensions in the format "[a,b,c]"
            </summary>
            <returns>Dimensions as String</returns>
        </member>
        <member name="M:ILNumerics.ILSize.GetHashCode">
            <summary>
            Generate hash code based on the dimension information 
            </summary>
            <returns>Hash code</returns>
        </member>
        <member name="M:ILNumerics.ILSize.Equals(System.Object)">
            <summary>
            Checks for equaltiy of this dimensions to another dimensions object
            </summary>
            <param name="obj">Dimensions object to compare this instance with</param>
            <returns>true, if both dimensions have the same <b>shape</b></returns>
            <remarks>This is equivalent to <c>IsSameShape((ILSize)obj)</c>.</remarks>
        </member>
        <member name="P:ILNumerics.ILSize.Empty00">
            <summary>
            An size descriptor of size 0x0
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Scalar1_1">
            <summary>
            An size descriptor of size 1x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Column2_1">
            <summary>
            An size descriptor of size 2x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Column3_1">
            <summary>
            An size descriptor of size 3x1
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.NumberOfDimensions">
            <summary>Get number of dimensions.</summary>
        </member>
        <member name="P:ILNumerics.ILSize.NonSingletonDimensions">
            <summary>
            Number of non singleton dimensions of the array
            </summary>
            <remarks>Non singleton dimensions are dimensions which length is larger than 1. 
            Empty dimensions (length = 0) will not be taken into account.</remarks>
        </member>
        <member name="P:ILNumerics.ILSize.NumberOfElements">
            <summary>
            Number of elements in the array
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Longest">
            <summary>
            Length of the longest dimension
            </summary>
        </member>
        <member name="P:ILNumerics.ILSize.Item(System.Int32)">
            <summary>
            Get length for dimension specified (Readonly)
            </summary>
            <param name="idx">Index of dimension</param>
            <returns>Length of dimension specified by idx</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If idx is negative</exception>
            <remarks><para>For idx corresponds to an existing dimension, 
            the length of that dimension is returned. If idx is larger than 
            the number of dimensions 1 is returned. </para>
            </remarks>
        </member>
        <member name="T:ILNumerics.Native.IILFFT">
            <summary>
            Interface for all FFT methods supported
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft 
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward n-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimensions of fft</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTBackwSym1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs backward 1-dimensional fft on hermitian sequence
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
            <remarks>This function brings increased performance if the implementation supports it. 
            If not, the method will be implemented by repeated calls of (inplace) 1D fft.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            performs n-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="nDims">number of dimension of fft</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.complex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Double},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{ILNumerics.fcomplex},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FFTForward1D(ILNumerics.ILInArray{System.Single},System.Int32)">
            <summary>
            performs 1-dimensional fft
            </summary>
            <param name="A">input array</param>
            <param name="dim">dimension to perform fft along</param>
            <returns>result, same size as A</returns>
        </member>
        <member name="M:ILNumerics.Native.IILFFT.FreePlans">
            <summary>
            Clear all currently cached plans
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.CachePlans">
            <summary>
            true, if the implementation caches plans between subsequent calls
            </summary>
        </member>
        <member name="P:ILNumerics.Native.IILFFT.SpeedyHermitian">
            <summary>
            true, if the implementation efficiently transforms from/to hermitian sequences (hermitian symmetry). 
            </summary>
            <remarks>If this property returns 'true', the implementation brings increased performance. 
            If not, the symmetry methods will bring no performance advantage over the 1D transforms. </remarks>
        </member>
        <member name="T:ILNumerics.Native.ILACMLFFT">
            <summary>
            Wrapper for FFT interface using ACML ver. 3.6
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT">
            <summary>
            Wrapper for FFT interface using FFTW3 libs
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILFFTW3FFT.fftw_iodim">
            <summary>
            This struct is used to define (n-dimensional) transform sizes
            </summary>
            <remarks>This struct is only user in C-API. It is NOT used for the Fortran interface (i.e. it's not used in here)!!! </remarks>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.n">
            <summary>
            length of dimension
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.iS">
            <summary>
            input stride
            </summary>
        </member>
        <member name="F:ILNumerics.Native.ILFFTW3FFT.fftw_iodim.oS">
            <summary>
            output stride
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLParameter">
            <summary>
            MKL configuration parameters (constant definitions)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLValues">
            <summary>
            MKL configuration values (constant definitions) 
            </summary>
        </member>
        <member name="T:ILNumerics.Native.MKLImports">
            <summary>
            import functions (pinvoke)
            </summary>
        </member>
        <member name="T:ILNumerics.Native.ILMKLFFT">
            <summary>
            Wrapper for FFT interface using MKL 10_03
            </summary>
        </member>
        <member name="T:ILNumerics.Native.IILLapack">
            <summary>
            Interface to all LAPACK/BLAS functions available
            </summary>
            <remarks>Each native module must implement this interface explicitly. Calls 
            to native functions are made virtual by calling functions of this interface.
            Therefore the user can transparently call any function regardless of the 
            plattform the assymbly (currently) runs on. The native modules implementing
            this interface take care of the details of implementation. 
            <para>Usually users of the library will not have to handle with this interface. 
            Its functions will be used from inside built in functions and are therefore wrapped 
            (mainly from inside <see cref="T:ILNumerics.ILMath">ILNumerics.ILMath</see>).</para>
            <para>Every LAPACK/BLAS function is explicitly implemented for any type supported.
            e.g. IILLapack includes four functions doing general matrix multiply: dgemm, zgemm, cgemm and sgemm - 
            for all four floating point datatypes supported from the LAPACK package.</para>
            <para>LAPACK is an open source linear algebra functions package optimized for 
            use together with highly natively optimized BLAS functions. A LAPACK guide is 
            available in the internet: <see href="http://www.netlib.org/lapack">www.netlib.org</see>.</para>
            </remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Wrapper implementiation for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="B">pointer to array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesdd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesdd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesdd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesdd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, new version, more memory needed
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="table">
             <listheader>
                 <term>jobz value</term>
                 <description>... will result in:</description>
             </listheader>
                 <item>
                     <term>A</term>
                     <description>all M columns of U and all N rows of V**T are
                                 returned in the arrays U and VT</description>
                 </item>
                 <item>  <term>S</term>
                         <description>the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</description>
                 </item>
                 <item> <term>O</term>  
                        <description>If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT,
                          otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</description>
                 </item>
                 <item> <term>N</term> 
                        <description>no columns of U or rows of V**T are computed.</description>
                 </item>
             </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> <![CDATA[< 0]]> :  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> <![CDATA[> 0]]> :  ?BGSDD did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <code>A = U * SIGMA * transpose(V)</code> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
             <summary>
             singular value decomposition, older version, less memory needed 
             </summary>
             <param name="jobz">Specifies options for computing all or part of the matrix U
             <list type="bullet"><item>= 'A':  all M columns of U and all N rows of V**T are
            returned in the arrays U and VT</item>
                 <item> = 'S':  the first min(M,N) columns of U and the first
                          min(M,N) rows of V**T are returned in the arrays U
                          and VT</item>
                 <item> = 'O':  If M >= N, the first N columns of U are overwritten
                          on the array A and all rows of V**T are returned in
                          the array VT. Otherwise, all columns of U are returned in the
                          array U and the first M rows of V**T are overwritten
                          in the array VT</item>
                 <item> = 'N':  no columns of U or rows of V**T are computed.</item>
                    </list>
             </param>
             <param name="m">The number of rows of the input matrix A.  M greater or equal to 0.</param>
             <param name="n">The number of columns of the input matrix A.  N greater or equal to 0</param>
             <param name="a">On entry, the M-by-N matrix A.
                      On exit, <list><item>
                      if JOBZ = 'O',  A is overwritten with the first N columns
                                      of U (the left singular vectors, stored
                                      columnwise) if M >= N;
                                      A is overwritten with the first M rows
                                      of V**T (the right singular vectors, stored
                                      rowwise) otherwise.</item>
                      <item>if JOBZ .ne. 'O', the contents of A are destroyed.</item></list></param>
             <param name="lda">The leading dimension of the array A.  LDA ge max(1,M).</param>
             <param name="s">array, dimension (min(M,N)). The singular values of A, sorted so that S(i) ge S(i+1)</param>
             <param name="u">array, dimension (LDU,UCOL)
                      UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
                      UCOL = min(M,N) if JOBZ = 'S'.
                      If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
                      orthogonal matrix U;
                      if JOBZ = 'S', U contains the first min(M,N) columns of U
                      (the left singular vectors, stored columnwise);
                      if JOBZ = 'O' and M &gt;= N, or JOBZ = 'N', U is not referenced.</param>
             <param name="ldu">The leading dimension of the array U.  LDU &gt;= 1; if  
             JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU &gt;= M</param>
             <param name="vt">array, dimension (LDVT,N). If JOBZ = 'A' or JOBZ = 'O' and 
             M >= N, VT contains the N-by-N orthogonal matrix V**T; if JOBZ = 'S', 
             VT contains the first min(M,N) rows of V**T 
             (the right singular vectors, stored rowwise); if JOBZ = 'O' and M &lt; N, 
             or JOBZ = 'N', VT is not referenced</param>
             <param name="ldvt">The leading dimension of the array VT.  LDVT &gt; = 1; 
             if JOBZ = 'A' or JOBZ = 'O' and M &gt; = N, LDVT &gt;= N; 
             if JOBZ = 'S', LDVT &gt; min(M,N).</param>
             <param name="info">
             <list>
                 <item> 0:  successful exit.</item>
                 <item> lower 0:  if INFO = -i, the i-th argument had an illegal value.</item>
                 <item> greater 0:  DBDSDC did not converge, updating process failed.</item>
             </list>
             </param>
             <remarks>(From the lapack manual):DGESDD computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.  If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                <br>A = U * SIGMA * transpose(V)</br> 
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.</remarks>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrf(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrf(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrf(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrf(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            cholesky factorization 
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotri(System.Char,System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotri(System.Char,System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotri(System.Char,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotri(System.Char,System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            matrix inverse via cholesky factorization (?potrf)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dpotrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.spotrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cpotrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zpotrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve equation system via cholesky factorization (?potrs)
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            LU factorization of general matrix
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetri(System.Int32,System.Double[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetri(System.Int32,System.Single[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetri(System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetri(System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],System.Int32@)">
            <summary>
            inverse of a matrix via LU factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dorgqr(System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sorgqr(System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cungqr(System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zungqr(System.Int32,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factor extraction
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqrf(System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqrf(System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqrf(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqrf(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorization
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgeqp3(System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgeqp3(System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgeqp3(System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgeqp3(System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32@)">
            <summary>
            QR factorisation with column pivoting
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sormqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            multipliation for general matrix with QR decomposition factor
            </summary>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dtrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.strtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ctrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.ztrtrs(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Int32@)">
            <summary>
            Solve triangular system of linear equations (forward-/ backward substitution)
            </summary>
            <param name="uplo">'U': A is upper triangular, 'L': A is lower triangular</param>
            <param name="transA">'N':  A * X = B  (No transpose); 'T':  A**T * X = B  (Transpose), 'T':  A**T * X = B  (Transpose)</param>
            <param name="diag">'N' arbitrary diagonal elements, 'U' unit diagonal</param>
            <param name="N">order of A</param>
            <param name="nrhs">number of right hand sides - columns of matrix B</param>
            <param name="A">square matrix A</param>
            <param name="LDA">spacing between columns for A</param>
            <param name="B">(input/output) on input: right hand side, on output: solution x </param>
            <param name="LDB">spacing between columns for B</param>
            <param name="info">(output) 0: success; &lt; 0: illigal argument, &gt; 0: A is sinular having a zero on the i-th diagonal element. No solution will be computed than. </param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.dgetrs(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Int32[],System.Double[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.sgetrs(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Int32[],System.Single[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.cgetrs(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32[],ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="M:ILNumerics.Native.IILLapack.zgetrs(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Int32[],ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            solve system of linear equations by triangular matrices
            </summary>
            <param name="trans">transpose before work?</param>
            <param name="N">number rows</param>
            <param name="NRHS">number right hand sides</param>
            <param name="A">matrix A</param>
            <param name="LDA">spacing between columns: A</param>
            <param name="IPIV">pivoting indices</param>
            <param name="B">matrix B</param>
            <param name="LDB">spacing between columns: B</param>
            <param name="info">success info</param>
        </member>
        <member name="T:ILNumerics.Native.ILACML4_1">
            <summary>
            LAPACK implementation for AMD processors
            </summary>
            <remarks>By using this module, you will have to make sure,
            you placed all runtime binaries for AMD's performance library 
            into the binary output dir accessable for ILNumerics assemblies. 
            Those modules must be donwloaded seperately, since it is not 
            permitted to distribute them among with LGPL code. However, 
            developing and redistributing of products with ACML is possible though. 
            AMD currently does not charge money for a redistributable 
            license, given that one signs a license agreement with AMD 
            individually.</remarks>
        </member>
        <member name="T:ILNumerics.Native.ILLapackGenLinux">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackGenLinux.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Native.ILLapackManaged">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackManaged.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Native.ILLapackMKL10_0">
            <summary>
            Generic LAPACK implementation, unsupported processor types
            </summary>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Double,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Double,System.Double[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Single,System.IntPtr,System.Int32,System.IntPtr,System.Int32,System.Single,System.Single[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.fcomplex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.fcomplex,ILNumerics.fcomplex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgemm(System.Char,System.Char,System.Int32,System.Int32,System.Int32,ILNumerics.complex,System.IntPtr,System.Int32,System.IntPtr,System.Int32,ILNumerics.complex,ILNumerics.complex[],System.Int32)">
            <summary>
            Implement wrapper for ATLAS GeneralMatrixMultiply
            </summary>
            <param name="TransA">Transposition state for matrix A: one of the constants in enum CBlas_Transpose</param>
            <param name="TransB">Transposition state for matrix B: one of the constants in enum CBlas_Transpose</param>
            <param name="M">Number of rows in A</param>
            <param name="N">Number of columns in B</param>
            <param name="K">Number of columns in A and number of rows in B</param>
            <param name="alpha">multiplicationi factor for A</param>
            <param name="A">pointer to double array A</param>
            <param name="lda">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix B</param>
            <param name="B">pointer to double array B</param>
            <param name="ldb">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix A</param>
            <param name="beta">multiplication faktor for matrix B</param>
            <param name="C">pointer to predefined double array C of neccessary length</param>
            <param name="ldc">distance between first elements of each column for column based orientation or 
            distance between first elements of each row for row based orientation for matrix C</param>
            <remarks>All parameters except C are readonly. Only elements of matrix C will be altered. C must be a predefined 
            continous double array of size MxN</remarks>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.dgesvd(System.Char,System.Int32,System.Int32,System.Double[],System.Int32,System.Double[],System.Double[],System.Int32,System.Double[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.sgesvd(System.Char,System.Int32,System.Int32,System.Single[],System.Int32,System.Single[],System.Single[],System.Int32,System.Single[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.zgesvd(System.Char,System.Int32,System.Int32,ILNumerics.complex[],System.Int32,System.Double[],ILNumerics.complex[],System.Int32,ILNumerics.complex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="M:ILNumerics.Native.ILLapackMKL10_0.cgesvd(System.Char,System.Int32,System.Int32,ILNumerics.fcomplex[],System.Int32,System.Single[],ILNumerics.fcomplex[],System.Int32,ILNumerics.fcomplex[],System.Int32,System.Int32@)">
            <summary>
            singular value decomposition
            </summary>
            <param name="jobz"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="a"></param>
            <param name="lda"></param>
            <param name="s"></param>
            <param name="u"></param>
            <param name="ldu"></param>
            <param name="vt"></param>
            <param name="ldvt"></param>
            <param name="info"></param>
        </member>
        <member name="T:ILNumerics.Storage.ILCellStorage">
            <summary>
            The class realizes an internal storage wrapper for cell arrays. It takes care of value semantics for reference types. 
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILDenseStorage`1">
            <summary>
            The class realizes an internal storage wrapper. It stores the internal data array
            and the dimension specifications for both: ILRetArray and ILDenseStorage (reference and solid). 
            </summary>
        </member>
        <member name="T:ILNumerics.Storage.ILStorage">
            <summary>
            Background storage object used internally.
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILStorage.m_size">
            <summary>
            size of this storage
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILStorage.Size">
            <summary>
            Size of the storage
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILStorage`1.GetValueTyped(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILStorage`1.SetValueTyped(`0,System.Int32[])">
            <summary>
            Set value of element at the specified position.
            </summary>
            <param name="value">new value</param>
            <param name="idx">position of the element to be altered</param>
        </member>
        <member name="F:ILNumerics.Storage.ILDenseStorage`1.m_data">
            <summary> 
            Internal storage object. Contains the final System.Array storage and a reference counter.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@)">
            <summary>
            Get minimum and maximum value of all elements - if these exist.
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(type).</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetLimits(`0@,`0@,System.Boolean)">
            <summary>
            Get minimum and maximum value of all elements - if existing
            </summary>
            <param name="minValue">Output: minimum value.</param>
            <param name="maxValue">Output: maximum value.</param>
            <param name="includeInfNaNs">true: recognize Inf, NaN values; false: ignore those values</param>
            <returns>True if the limits exists and could be computed, false otherwise.</returns>
            <remarks>Empty arrays will return false. The output parameter will be default(ElementType) then.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ToString">
            <summary>
            Write information about the ILDenseStorage to string.
            </summary>
            <returns>String containing general information about the current instance of 
            ILDenseStorage and the formatted elements' values.</returns>
            <remarks>If the number of elements exceeds a certain amount, the display will be abreviated.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ValuesToString(System.Int32)">
            <summary>
            print formated values to string
            </summary>
            <param name="maxLength">Maximum number of characters per line. 0: no limit</param>
            <returns>StringBuilder object filled with formated values.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(System.Object)">
            <summary>
            Check if the content of this array equals the content of obj.
            </summary>
            <param name="obj">storage containing the values with which to compare this array.</param>
            <returns>True if all elements contained in obj are equal to the 
            elements of this array, false otherwise.</returns>
            <remarks>This method compares the object references of corresponding elements. 
            The size and type of both arrays must match. Otherwise false will be returned.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Equals(ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Test if this dense storage equals another dense storage.
            </summary>
            <param name="A">storage to compare this storage with</param>
            <returns>True if all elements and dimension sizes match, false otherwise.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetHashCode">
            <summary>
            generate a hash code based on the current arrays values
            </summary>
            <returns>hash code</returns>
            <remarks>The hashcode is generated by taking the values currently stored in the array into account.
            Therefore, the function must iterate over all elements in the array - which makes it somehow a expensive 
            operation. Take this into account, if you consider using large arrays in collections like dictionaries 
            or hashtables, which make great use of hash codes.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.Storage.ILRange,ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter values specified by range.
            </summary>
            <param name="range">ILRange specifying the dimensions/indices to be altered.</param>
            <param name="values">new values</param>
            <remarks>
            The values pointed to by range will be replaced with the values 
            found in 'values'. Important: the range cannot specify indices outside of my dimensions! 
            Therefore, the storage must have been expanded in advance, if needed!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{`0})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ShiftDimensions(System.Int32)">
            <summary>
            Create referencing or solid array from this array, with shifted dimensions.
            </summary>
            <param name="shift">Number of dimensions to shift the array.</param>
            <returns>Shifted ILDenseStorage of the same type.</returns>
            <remarks><para>Shift is done 'to the left'.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(ILNumerics.ILSize)">
            <summary>
            reshape <b>this</b> storage
            </summary>
            <param name="newDimensions">new dimensions of the storage.</param>
            <remarks><para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same countable array
            is used in conjunction with a new dimension specifier. </para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Reshape(System.Int32[])">
            <summary>
            reshape <b>this</b> storage
            </summary>
            <param name="dims">new dimension length of the storage.</param>
            <remarks><para>This storage will be changed! The operation is cheap, since the 
            number of elements (and their values) do not change. The same underlying storage 
            is used in conjunction with the new dimension specifier.</para>
            </remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If the number of elements in 'newDimension'
            do not match the number of elements in this storage.</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Concat(ILNumerics.Storage.ILDenseStorage{`0},System.Int32)">
            <summary>
            concatenate this storage 
            </summary>
            <param name="A">n dimensional storage</param>
            <param name="dim">Index of dimension along which to concatenate the arrays.
            If dim is larger than the number of dimensions of one of the arrays
            its value will be used in modulus.</param>
            <returns>Array having the size of both input arrays laid beside one 
            another along the <paramref name="dim"/>'s-dimension</returns>
            <remarks>The array returned will be a copy of both arrays involved. None 
            of the input arrays will be altered.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Repmat(System.Int32[])">
            <summary>
            Replicate this storage to create a larger array.
            </summary>
            <param name="sizes">Sizes description. This may be a 
            list or an array of integer values. If the number of elements in <paramref name="sizes"/> is 
            less the number of dimensions in this array, the trailing dimensions will 
            be set to 1 (singleton dimensions). On the other hand, if the number specified 
            is larger then the number of dimensions of this array, the result 
            will have its number of dimensions extended accordingly. </param>
            <returns>array which is made out of multiple copies of this array along 
            specified dimensions, according to <paramref name="sizes"/>.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Remove(System.Int32,ILNumerics.Data.ILIntList)">
            <summary>
            Remove individual parts of a dimension from <b>this</b> storage
            </summary>
            <param name="dimension">index of the dimension, where <c>indices</c> are to be removed</param>
            <param name="indices">indices to be removed from <paramref name="dimension"/>, -1 for "wipe" (make this an empty storage)</param>
            <remarks>The function directly operates on <b>this</b> storage! After the function returns, 
            this storage may have its dimensions changed!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnSerialize(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Prepare for serialization.
            </summary>
            <param name="context">Streaming Context - provided by the formatter.</param>
            <remarks>nothing to do here</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.OnDeserialized(System.Runtime.Serialization.StreamingContext)">
            <summary>
            Post operations aftre deserializing is finished.
            </summary>
            <param name="context">Streaming context provided by the formatter.</param>
            <remarks>nothing to do here</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValue(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueTyped(System.Int32[])">
            <summary>
            Get single value from this storage.
            </summary>
            <param name="idx">Integer array holding the dimension specifier</param>
            <returns>Element at the position pointed to by idx.</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetValueSeq(System.Int32,System.Int32[]@)">
            <summary>
            Get single value from this storage by a single sequential access.
            </summary>
            <param name="idx">Integer array holding the dimension specifier 
            pointing to the value.</param>
            <param name="dims">Out value: return position mapped to dimensions.</param>
            <returns>Object in the position pointed to by idx.</returns>
            <remarks>dims is the final position into the array for the sequential index specification <c>idx</c>.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValue(System.Object,System.Int32[])">
            <summary>
            Set single value to element at the specified index.
            </summary>
            <param name="value">New value.</param>
            <param name="idx">Index of the element to be altered.</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.SetValueTyped(`0,System.Int32[])">
            <summary>
            Set value of element at the specified position.
            </summary>
            <param name="value">new value</param>
            <param name="idx">position of the element to be altered</param>
            <remarks><para>This function does support automatic expansion of the array
            if indices lay outside the dimension limits of the array. However, because 
            of ambiguity reasons this is not reliable supported for vector sized arrays.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Int32[])">
            <summary>
            [depricated] Convert index array into sequential index for storage access.
            </summary>
            <param name="idx">int array with dimension specification.</param>
            <returns>Index of requested value inside the solid storage. This 
            value can directly be used to query the corresponding value via GetArrayForRead()[return_value].
            </returns>
            <remarks><b>This function is deprecated! Use <see cref="M:ILNumerics.ILSize.IndexFromArray(System.Int32[])"/> instead!</b><br/>
            If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimension will be used. 
            If length of idx is larger than the dimensions of this storage, the behavior
            is undefined. Therefore this function should be enclosed in try, catch blocks 
            to handle this case!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.getBaseIndex(System.Boolean@,System.Int32[]@,System.Int32[])">
            <summary>
            [depricated] Convert index array into sequential index for storage access. Ommit any bound checking. 
            </summary>
            <param name="idx">int array with dimensions specification.</param>
            <param name="MustExpand">Output parameter. On return determine, if the index 
            specification points outside of the dimensions of this ILDenseStorage and the array 
            must be expanded before accessing elements on that position.</param>
            <param name="dimensions">if the array was found to be expanded, this are the 
            needed dimension sizes for the new array. The sizes are computed from the range 
            specification given.</param>
            <returns>Index of requested value inside the solid storage. This 
            value may directly be used to query the value via m_data[return_value].
            The value returned is valid for solid storages as well as for reference 
            storages.
            </returns>
            <remarks>
            <para>idx must be not null and must contain at least one element.</para>
            <para>If the length of idx is smaler than the number of dimensions 
            of this storage, the trailing dimensions will be replaced with "0". I.e 
            the first index of each non specified dimensions will be used. 
            If length of idx is larger than the dimensions of this storage, the index of 
            the expanded array will be returned.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExportValues(`0[]@)">
            <summary>
            Copy values of all elements into System.Array.
            </summary>
            <param name="result">System.Array, holding all element values of this ILDenseStorage.</param>
            <remarks>The System.Array may be predefined. If its length is sufficient, it will be used and 
            its leading elements will be overwritten when function returns. If 'result' is null or has too few elements, 
            it will be recreated from the ILNumerics memory pool.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForWrite">
            <summary>
            Get direct reference to inner System.Array storage for <b>write access</b>
            </summary>
            <returns>reference to inner System.Array</returns>
            <remarks>Altering this array can be done directly. If necessary, the array is detached before 
            returned. Watch the column order format of storages in ILNumerics! Keep in minds, the length 
            of the array may exceeds the number of elements.
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>! (You have been warned!)</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetArrayForRead">
            <summary>
            Get direct reference to inner System.Array storage for <b>read access</b>
            </summary>
            <returns>reference to inner System.Array for reading</returns>
            <remarks>This method is provided for experts only! Altering elements of this 
            array may cause the data to be invalidated or corrupted! Use this array only for reading! Note 
            the ILNumerics array storage format (column major). Keep in mind, the length 
            of the array may exceeds the number of elements! 
            <para>Accessing the inner system array directly should be left to ILNumerics experts only! 
            Unless you really know, what you are doing, you should rather use the higher order access 
            methods provided by ILArray&lt;T>! (You have been warned!)</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Clone">
            <summary>
            Create lazy,shallow copy of this array 
            </summary>
            <returns>ILDenseStorage as copy of this storage.</returns>
            <remarks>The ILDenseStorage object returned will be of the same size and type than this object.
            <para>The copy is done lazy. This means, the new storage will at first share the memory 
            with that storage. This will take almost no memory / processor time. As soon as attempts 
            are made to <b>alter</b> the new storage, it will be detached from this storage and use own memeory.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.GetEnumerator">
            <summary>
            enumerator returning elements as ElementType
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExtractRemovalParameter(ILNumerics.ILBaseArray[],System.Int32@,ILNumerics.Data.ILIntList@,ILNumerics.ILSize@)">
            <summary>
            helper function to gather some parameters for partial dimension removal 
            </summary>
            <param name="rng">object with index specifications. May be of 
            type ILBaseArray[] with numeric arrays or a string array according 
            to the format of <see cref="T:ILNumerics.Storage.ILRange"/>. 
            </param>
            <param name="dimensionIdx">Out parameter: index of dimension the indices to be removed lie in.</param>
            <param name="indices">Indices to be removed.</param>
            <param name="dimensions">Dimension structure, can be used to reshape the storage <b>before</b> the removal</param>
            <remarks>If range comprises a range dimension specification which is smaller than 
            the actual number of dimension of this storage, the storage must be reshaped in advance of the removal. 
            This reshaping proccess will <b>not</b> be done inside this function! However 
            the <c>dimension</c> value returned reflects the size of the storage before removing and therefore
            can be utilized for reshaping the storage.</remarks>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">If:<list type="bullet">
            <item>The length of range exceeds the dimensions of this storage.</item>
            <item>More than one or less than one dimension of <c>range</c> was not null.</item>
            <item>The type of range was invalid, or</item>
            <item>Range is of type <see cref="T:ILNumerics.ILBaseArray"/>, but the element type is not numeric</item>
            </list></exception>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(ILNumerics.Storage.ILLeftSideRange)">
            <summary>
            Expanded <b>this</b> storage for index addressing outside of my dimensions
            </summary>
            <param name="range">range specification with size for destination array</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.ExpandArray(System.Int32[])">
            <summary>
            Expand <b>this</b> storage for index addressing outside of my dimensions
            </summary>
            <param name="indices">sizes of dimensions for the new storage</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyUpperTriangle(System.Int32)">
            <summary>
            Copy upper triangular part of this array into new solid array.
            </summary>
            <param name="n">Length of first dimension of destination array.</param>
            <returns>Solid array of size [n x {ThisColumnCount})].</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.copyLowerTriangle">
            <summary>
            Copy lower triangular part of this array into new solid array.
            </summary>
            <returns>Solid array of same size than this array.</returns>
            <remarks>If this is not a 2D array, only the first dimension is referenced.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.#ctor(`0[],ILNumerics.ILSize)">
            <summary>
            create new dense storage
            </summary>
            <param name="system_array">countable array</param>
            <param name="dimensions">dimensions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Dispose(System.Boolean)">
            <summary>
            dispose this storage
            </summary>
            <remarks><para>Calling Dispose should be the last method called for an ILDenseStorage.</para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Detach">
            <summary>
            detach this storage: copy its countable array if necessary
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.Subarray(ILNumerics.ILBaseArray[])">
            <summary>
            Subarray from this array
            </summary>
            <param name="range"> arrays specifying the ranges to create subarray from</param>
            <returns>subarray as specified</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateRangedSubarray(ILNumerics.ILBaseArray{ILNumerics.Misc.ILRegularRange})">
            <summary>
            subarray from single dim, single range
            </summary>
            <returns>subarray (column vector)</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Linq.Expressions.Expression})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Double})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int64})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Int32})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageSequential(ILNumerics.ILBaseArray{System.Single})">
            <summary>
            create new subarray storage, sequentially addressed elements
            </summary>
            <param name="indices">sequential indices, arbitrary size</param>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorageFull">
            <summary>
            create column vector of all this array elements
            </summary>
            <returns>new storage, type of this storage, size and shape of indices</returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateSubarrayStorage(ILNumerics.Storage.ILRange)">
            <summary>
            create subarray from ILDenseStorage 
            </summary>
            <param name="range"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILDenseStorage`1.CreateShiftedStorage(System.Int32)">
            <summary>
            create new storage, shift dimensions 
            </summary>
            <param name="shift">number of dimensions to shift</param>
            <returns>shifted storage </returns>
        </member>
        <member name="P:ILNumerics.Storage.ILDenseStorage`1.ReferenceCount">
            <summary>
            number of storages referencing the current data array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILDenseStorage`1.IsDisposed">
            <summary>
            Determine, if this storage has already been disposed.
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.#ctor(ILNumerics.Storage.ILStorage[],ILNumerics.ILSize)">
            <summary>
            create new cell storage
            </summary>
            <param name="system_array">countable array</param>
            <param name="dimensions">dimensions</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetValueTyped(ILNumerics.Storage.ILStorage,System.Int32[])">
            <summary>
            replace array at specified location
            </summary>
            <param name="value">new scalar value for element</param>
            <param name="indices">indices of element to be altered, supports 'deep indexing'</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValueTyped(System.Int32[])">
            <summary>
            get element from this cell storage
            </summary>
            <param name="indices">indices of element</param>
            <returns>element </returns>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.IsTypeOf``1(ILNumerics.ILBaseArray[])">
            <summary>
            test if an element of the cell is an array of the given element type
            </summary>
            <typeparam name="T">the array element type to check the cell element against</typeparam>
            <param name="position">position of the cell element to be tested</param>
            <returns>true if the element found at the given position is an array of the element type <typeparamref name="T"/>, false otherwise</returns>
            <remarks>The method is helpful in order to investigate the contents of a cell array. If you are not sure about the 
            types of elements in the cell, this function can be used to make sure, elements are of the expected type before retrieving them as such.
            <para>In most situations, elements of a cell are stored arrays of a distinct element type. That element type is given to IsTypeOf as 
            typeparameter <typeparamref name="T"/>. That means, in order to find out, if the first cell element stores an array of int (<c>ILArray&lt;int></c>), 
            one may use <c>cell.IsTypeOf&lt;int>(0)</c></para>
            <para>In order to test, if a cell element is of cell type, one can provide the type <c>ILCell</c> as type parameter: 
            <c>cell.IsTypeOf&lt;ILCell>(0)</c>. Note the different semantic when checking for cell elements of type cell. Here we do not test for the 
            element type but for the array type itself, ie. <c>ILCell</c>. The reason of this is: the type of elements of <c>ILCell</c> is 
            an implementation detail and therefore hidden to the user.</para>
            </remarks>
            <example>
            <para>In the following example a ILCell of size 3x2 is created. It stores several array types, among which other cells are stored as elements of the outer cell.</para>
            <code>ILCell cell = ILMath.cell(new ILSize(3, 2) 
                                 , "first element"
                                 , 2.0
                                 , ILMath.cell(Math.PI, 100f)
                                 , ILMath.create&lt;short>(1, 2, 3, 4, 5, 6)
                                 , new double[] {-1.4, -1.5, -1.6});
            </code>
            The cell is now: 
            <code>ILCell [3,2]
                     &lt;String>      first element  &lt;Int16> [2,3,4,5,6] 
                     &lt;Double>          2          ILCell [1,3]           
                     ILCell [2,1]                                    (null)	
            </code>
            We test the element type of every element in the cell: 
            <code>
            Console.Out.WriteLine("cell[0,0] is of type 'string': {0}", cell.IsTypeOf&lt;string>(0));
            Console.Out.WriteLine("cell[0,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(0));
                                                 
            Console.Out.WriteLine("cell[1,0] is of type 'double': {0}", cell.IsTypeOf&lt;double>(1));
            Console.Out.WriteLine("cell[2,0] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(2));
                                                                                    
            Console.Out.WriteLine("cell[0,1] is of type 'short': {0}", cell.IsTypeOf&lt;short>(0, 1));
            Console.Out.WriteLine("cell[1,1] is of type 'ILCell': {0}", cell.IsTypeOf&lt;ILCell>(1, 1));
            Console.Out.WriteLine("cell[2,1] is of type 'double': {0}", cell.IsTypeOf&lt;double>(2, 1));
            </code>
            This gives the following output: 
            <code>
            cell[0,0] is element type 'string': True
            cell[0,0] is element type 'double': False
            cell[1,0] is element type 'double': True
            cell[2,0] is element type 'ILCell': True
            cell[0,1] is element type 'short': True
            cell[1,1] is element type 'ILCell': True
            cell[2,1] is element type 'double': False  // element is null, IsTypeOf&lt;> never gives true
            </code></example>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValue(System.Int32[])">
            <summary>
            gives clone of value addressed, supports deep index addressing
            </summary>
            <param name="indices"></param>
            <returns></returns>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.GetValue``1(System.Int32[])">
            <summary>
            get single element from cell storage, predefined element type 
            </summary>
            <typeparam name="T">predefined type</typeparam>
            <param name="indices">location of element to return</param>
            <returns>element</returns>
            <exception cref="T:ILNumerics.Exceptions.ILArgumentException">if the element found is not of the specified type</exception>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Double},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int64},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int32},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Int16},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.SetRange(ILNumerics.ILBaseArray{System.Single},ILNumerics.Storage.ILDenseStorage{ILNumerics.Storage.ILStorage})">
            <summary>
            Alter elements of this storage adressed by sequential indices 
            </summary>
            <param name="indices">array specifying the elements to be altered, sequential indexing</param>
            <param name="values">ILBaseArray of the same type than this array, holding the new values. 
            The number of elements of storage must match the 
            number of elements of indices. The only exception to this rule is if 'values' is a scalar array. The 
            single value of 'values' is than used to set all elements addressed by 'indices'.</param>
            <remarks><para>For empty arrays, scalar or vectors, indices outside the current bounds for 
            this array will expand this array to the size neccessary. 
            For other arrays the sequential indices given must fit inside this arrays dimensions. </para></remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.Detach">
            <summary>
            detach this storage: copy its countable array if needed
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCellStorage.DeepReferenceElements">
            <summary>
            walk all elements of this cell and recursively replace them with clones of themself 
            </summary>
            <remarks>Due to the cloning mechanism of ILNumerics, the full clone 
            will be cheap by using lazy copies of the data. Cloned elements will automatically be detached on write access.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32)">
            <summary>
            create new countable array by size
            </summary>
            <param name="length"></param>
            <remarks>The memory for the newly created array is requested from memory pool. All elements of the array 
            are initialized with default(ElementType).</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(System.Int32,System.Boolean)">
            <summary>
            create new countable array by size
            </summary>
            <param name="length"></param>
            <remarks>The memory for the newly created array is requested from memory pool. Depending on the value of 
            'clear', the elements of the array are NOT initialized and therefore may contain garbage data!.</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.#ctor(`0[],System.Int32)">
            <summary>
            create new countable array, provide system array
            </summary>
            <param name="data">system array to be used as storage array directly</param>
            <param name="length">minimum lenght of array needed</param>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference">
            <summary>
            increase reference counter 
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference">
            <summary>
            decrease reference counter
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.Dispose">
            <summary>
            Dispose off this array: register it in pool
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILCountableArray`1.CreateCopy">
            <summary>
            return (solid) copy of this countable array
            </summary>
            <returns>newly created array</returns>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.Data">
            <summary>
            Access to the internal system array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.Length">
            <summary>
            minimal length of the system array to be used for computations
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILCountableArray`1.ReferenceCount">
            <summary>
            number of storages referencing to this array
            </summary>
            <remarks>In order to in-/decrease the reference counter, use 
            the <see cref="M:ILNumerics.Storage.ILCountableArray`1.IncreaseReference"/>
            and <see cref="M:ILNumerics.Storage.ILCountableArray`1.DecreaseReference"/> functions.</remarks>
        </member>
        <member name="T:ILNumerics.Storage.ILRange">
            <summary>
            base class for ranges, used to define subarray ranges
            </summary>
            <description>ILRange is used to define those parts of indices of an array,
            which are to be extracted into a new subarray. 
            The class (and derived classes) parse indices given for each dimension and expand them into a 2-dimensional 
            integer array, needed for fast element traversal.
            <para>The class is internally used only and not intended to be used from outside ILNumerics.</para></description>
        </member>
        <member name="F:ILNumerics.Storage.ILRange.m_range">
            <summary>
            hold ranges as 2 dimensional System.Array
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.Map(System.Int32[],System.Int32[]@)">
            <summary>
            Evaluates (maps) index array on my range. 
            </summary>
            <param name="idx">int array indexing location inside this range</param>
            <param name="retIdx">(output) also return the result into array given</param>
            <returns>Mapped int[] array. It can be used for direct addressing the physical storage object.</returns>
            <remarks>retIdx must be at least of length m_nrDims. No check is made for this assumption!</remarks>
        </member>
        <member name="M:ILNumerics.Storage.ILRange.ParseDimension(System.String,System.Int32)">
            <summary>
            parse single dimension specifier from string
            </summary>
            <param name="indices">valid index specification</param>
            <param name="dimlen">number of elements in dimension to be parsed</param>
            <returns>array with indices defined in 'indices'</returns>
            <remarks>the indices are parsed the way needed for sequential addressing. This means: 
            full dimensions address the whole array. Full dimensions are transformed into negative 
            placeholder indices nevertheless! SetRange must handle that accordingly.</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.RangeArray">
            <summary>
            for performance reasons: give reference to internal array
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32)">
            <summary>
            Index access for ILRange objects. Set/returns Index array for specified dimension.
            </summary>
            <remarks>A reference to the internal object will be returned directly! (performance)</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Item(System.Int32,System.Int32)">
            <summary>
            Index access for ILRange objects. returns the destIndex destination dimension for dimension specifyied by dimNr.
            </summary>
            <remarks>The access is readonly! No checks are made, if the requested indices exist.</remarks>
        </member>
        <member name="P:ILNumerics.Storage.ILRange.Size">
            <summary>
            Create trimmed size descriptor from indices in ILRange object
            </summary>
            <returns>new size descriptor with the neccessary size to define 
            an array as defined by all indices in this range</returns>
        </member>
        <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expandDimensions">
            <summary>
            sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="F:ILNumerics.Storage.ILLeftSideRange.m_expanding">
            <summary>
            internal field, stores expanding flag
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLeftSideRange.Expanding">
            <summary>
            true for left side ranges, if at least one dimension must be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLeftSideRange.ExpandDimensions">
            <summary>
            array with sizes of dimensions to be expanded
            </summary>
        </member>
        <member name="P:ILNumerics.Storage.ILLogicalStorage.NumberNonZero">
            <summary>
            cached number of non-zero elements in this logical storage
            </summary>
        </member>
        <member name="M:ILNumerics.Storage.ILRightSideRange.#ctor(ILNumerics.ILSize,System.Int32[])">
            <summary>
            rempat consctructor - for performance reasons 
            </summary>
            <param name="dimension">source array dimensions</param>
            <param name="range">destination array repmattings </param>
        </member>
        <member name="T:ILGLU">
            <summary>
            This is a managed replacement for the OpenGL utilities library
            </summary>
        </member>
        <member name="M:ILGLU.LookAt(ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df,ILNumerics.Drawing.ILPoint3Df)">
            <summary>
            Looks at eye, target, top and moveOffset.
            </summary>
            <param name='eye'>
            Position of camera
            </param>
            <param name='target'>
            Point the camera aims at
            </param>
            <param name='top'>
            'up' vector of the camera
            </param>
            <param name='moveOffset'>
            offset for moving the whole scene slightly out of center
            </param>
            <remarks>Reference: http://www.opengl.org/sdk/docs/man/xhtml/gluLookAt.xml </remarks>
        </member>
        <member name="M:ILGLU.Project(ILNumerics.Drawing.ILPoint3Df,System.Double[],System.Double[],System.Int32[],ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            Get the screen coords of a point from world space coords
            </summary>
            <param name='worldCoords'>
            World coords.
            </param>
            <param name='mm'>
            Modelview matrix (as 1d double vector) 
            </param>
            <param name='pm'>
            Projection matrix (as 1d double vector)
            </param>
            <param name='vm'>
            View matrix (as 1d double vector) 
            </param>
            <param name='screen'>
            [Output] point with screen coords (and a z value, see OpenGL man pages)
            </param>
            <remarks>Reference:	http://www.opengl.org/sdk/docs/man/xhtml/gluProject.xml </remarks>
        </member>
        <member name="M:ILGLU.UnProject(ILNumerics.Drawing.ILPoint3Df,System.Double[],System.Double[],System.Int32[],ILNumerics.Drawing.ILPoint3Df@)">
            <summary>
            Convert screen coordinates into world coordinates
            </summary>
            <param name='screen'>
            Screen coordinates X,Y (and Z: see the OpenGL manual)
            </param>
            <param name='mm'>
            Modelview matrix
            </param>
            <param name='pm'>
            Projection matrix
            </param>
            <param name='vm'>
            View matrix
            </param>
            <param name='world'>
            [Output] World coordinates
            </param>
            <remarks>Reference: http://www.opengl.org/sdk/docs/man/xhtml/gluUnProject.xml </remarks>
        </member>
    </members>
</doc>
